{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Kevlar \u00b6 Abstract \u00b6 Kevlar is a security toolkit (library) for Android apps. It is divided in 3 packages ( antipiracy , rooting and integrity ), each containing specific tooling and components. Its purpose is to be an auditing tool, used to inspect the security environment on Android devices. A security environment is the security state of a device, which can be probed with the different packages. Each package focuses on a specific security environment area: antipiracy detects the presence of pirate software installed on the device (user-wise security); rooting detects the presence of root access, custom binaries, and abnormal system status on the OS (system-wise security); integrity detects certain types of tampering techniques your app may have been targeted with (app-wise security). Kevlar is intended to be used any time it is deemed necessary to determine whether the device your app is running on can be regarded as secure, according to your policies and security requirements. Security Environment \u00b6 The security environment is the status of the device. This is subdivided into system-wise security (system modifications, rooting, custom binaries, custom ROMs, emulator, SELinux), user-wise security (pirate stores and pirate apps), and app-wise security (tampering, recompiling, changed signature & metadata) Flexibility \u00b6 Kevlar does not automatically detect a \"standard\" unsafe environment and gives a 0/1 answer. The kind of environment that is acceptable for your app to run in can be configured in each package individually. You may be indifferent to some things (e.g. root detection) and very sensitive about others (e.g. app tampering & piracy). You can customize the set of checks the library executes in each package. Once you define your constraints, kevlar modules will act accordingly. Design \u00b6 Each kevlar package contains custom implementations for what it has to look for, but they all share the same overall structure to make it easy to work with. graph LR I[Inizialization] -.Settings..-> K{Kevlar}; AREQ[Attestation Requests] --> K K --> |Clear| P[Passed]; K --> |Failed| NP[Not Passed]; P --> ARES[Attestation Result] NP --> ARES The idea is of a flow of attestations. You initialize the package through its entry class, passing to it your settings (what you cant to check for), and then you can go ahead and start requesting attestations. An attestation can either be Clear (passed) or Failed (non-passed), according to your detection settings. There may be one or more types of attestation you can request, and you can choose what you want to give granular control and run efficiently. Under the hood, each package will call its implementations and run those checks against the operative system/current app, but you'll eventually get an Attestation back, so you only have to check whether it is clear or not. Use Cases \u00b6 Common use cases for security environment checks are applications managing sensitive resources, such as in-app purchases and subscriptions, costly server-side resources or APIs, financial transactions, and anything that has a value that gets managed through your app/client. Ideally, you should request an attestation whenever your client wants to verify the status of the security environment before proceeding with the action that has value. Kevlar is a sort of guard statement for those actions. Accuracy \u00b6 This tool is meant to be an approximate form of environment analysis and estimation. It covers a large number of attack vectors and does a good job at it. This does not mean that it is unbreakable. You can find more details in philosophy , but essentially it is a level 0 protection that can be removed by manually reverse engineering your app. This doesn't render it useless, it is very efficient in doing what it is designed to do : protecting against automated and unskilled attacks, which will most certainly be the vast majority of what your app will ever be put through. Additions & Alternatives \u00b6 Kevlar resembles what may look like an in-house protection system. It is open source, flexible and complete. For stricter scenarios where higher fidelity and accuracy are required, you should be using something more specific (and radically different). SafetyNet from Google; AppCheck from Firebase; ProGuard and DexGuard from GuardSquare. License \u00b6 This project is licensed under the Apache License, Version 2.0. Please refer to the LICENSE.md file inside the Github repository for the full text.","title":"Overview"},{"location":"#welcome-to-kevlar","text":"","title":"Welcome to Kevlar"},{"location":"#abstract","text":"Kevlar is a security toolkit (library) for Android apps. It is divided in 3 packages ( antipiracy , rooting and integrity ), each containing specific tooling and components. Its purpose is to be an auditing tool, used to inspect the security environment on Android devices. A security environment is the security state of a device, which can be probed with the different packages. Each package focuses on a specific security environment area: antipiracy detects the presence of pirate software installed on the device (user-wise security); rooting detects the presence of root access, custom binaries, and abnormal system status on the OS (system-wise security); integrity detects certain types of tampering techniques your app may have been targeted with (app-wise security). Kevlar is intended to be used any time it is deemed necessary to determine whether the device your app is running on can be regarded as secure, according to your policies and security requirements.","title":"Abstract"},{"location":"#security-environment","text":"The security environment is the status of the device. This is subdivided into system-wise security (system modifications, rooting, custom binaries, custom ROMs, emulator, SELinux), user-wise security (pirate stores and pirate apps), and app-wise security (tampering, recompiling, changed signature & metadata)","title":"Security Environment"},{"location":"#flexibility","text":"Kevlar does not automatically detect a \"standard\" unsafe environment and gives a 0/1 answer. The kind of environment that is acceptable for your app to run in can be configured in each package individually. You may be indifferent to some things (e.g. root detection) and very sensitive about others (e.g. app tampering & piracy). You can customize the set of checks the library executes in each package. Once you define your constraints, kevlar modules will act accordingly.","title":"Flexibility"},{"location":"#design","text":"Each kevlar package contains custom implementations for what it has to look for, but they all share the same overall structure to make it easy to work with. graph LR I[Inizialization] -.Settings..-> K{Kevlar}; AREQ[Attestation Requests] --> K K --> |Clear| P[Passed]; K --> |Failed| NP[Not Passed]; P --> ARES[Attestation Result] NP --> ARES The idea is of a flow of attestations. You initialize the package through its entry class, passing to it your settings (what you cant to check for), and then you can go ahead and start requesting attestations. An attestation can either be Clear (passed) or Failed (non-passed), according to your detection settings. There may be one or more types of attestation you can request, and you can choose what you want to give granular control and run efficiently. Under the hood, each package will call its implementations and run those checks against the operative system/current app, but you'll eventually get an Attestation back, so you only have to check whether it is clear or not.","title":"Design"},{"location":"#use-cases","text":"Common use cases for security environment checks are applications managing sensitive resources, such as in-app purchases and subscriptions, costly server-side resources or APIs, financial transactions, and anything that has a value that gets managed through your app/client. Ideally, you should request an attestation whenever your client wants to verify the status of the security environment before proceeding with the action that has value. Kevlar is a sort of guard statement for those actions.","title":"Use Cases"},{"location":"#accuracy","text":"This tool is meant to be an approximate form of environment analysis and estimation. It covers a large number of attack vectors and does a good job at it. This does not mean that it is unbreakable. You can find more details in philosophy , but essentially it is a level 0 protection that can be removed by manually reverse engineering your app. This doesn't render it useless, it is very efficient in doing what it is designed to do : protecting against automated and unskilled attacks, which will most certainly be the vast majority of what your app will ever be put through.","title":"Accuracy"},{"location":"#additions-alternatives","text":"Kevlar resembles what may look like an in-house protection system. It is open source, flexible and complete. For stricter scenarios where higher fidelity and accuracy are required, you should be using something more specific (and radically different). SafetyNet from Google; AppCheck from Firebase; ProGuard and DexGuard from GuardSquare.","title":"Additions &amp; Alternatives"},{"location":"#license","text":"This project is licensed under the Apache License, Version 2.0. Please refer to the LICENSE.md file inside the Github repository for the full text.","title":"License"},{"location":"pages/modules/antipiracy/antipiracy/","text":"Antipiracy \u00b6 graph LR I[Inizialization] -.Settings..-> K{KevlarAntipiracy}; DB[(Dataset)] === K AREQ[Attestation Requests] --> K K --> |Clear| P[Passed]; K --> |Failed| NP[Not Passed]; P --> ARES[AntipiracyAttestation] NP --> ARES The antipiracy package contains tools for the detection of different categories of pirate software that may be installed and running on target devices. At its core, this package runs a battery of tests against all the installed applications to check for potential active pirate software, which depending on your policies may be a security environment issue. It then compiles the results into an attestation (it can either be uninitialized, clear, or failed) which is returned to your app, where you can check what has been found and act accordingly. Purpose of the antipiracy package You may want to use this package if you consider that executing your app alongside pirate software which may be interfering/bypassing your code/protections is a security environment issue. Tampering and System protection The antipiracy package by itself does not do any kind of signature/tampering check (for that, refer to integrity package) or system wide verification ( rooting ). It just tells you whether software that may be trying/have already interfered/bypassed your protection mechanisms is installed or not. To implement this, you initialize KevlarAntipiracy and provide your desired settings (which influence what is to be detected and what not). Then you can submit attestation requests (which will be executed according to your settings). Each attestation request will cause Kevlar to grab the package list, run the appropriate checks and compile an attestation. The settings you provide influence what will be included in the attestation. Empty & default settings The settings on antipiracy are additive. If you leave a blank DSL, nothing will be detected, because no checks will be run, because the settings are empty. If you do not pass a DSL at all, the default settings will be used (they only scan for pirate apps, not stores nor collateral). Custom private val antipiracy = KevlarAntipiracy { scan { pirate () store () collateral () } } Empty private val antipiracy = KevlarAntipiracy { scan { } } Default private val antipiracy = KevlarAntipiracy () Attestation process overview \u00b6 When you require an attestation (through antipiracy.attestate(context) ), kevlar executes the following operations: The installed package list is queried from the PackageManager . Make sure to have the right permissions to do that; The test battery is initialized (to match your scan parameters) and ran on all packages, against the precompiled dataset onboard the library; The results are collected, processed, filtered, and returned. There is only one type of attestation that can be produced. The attestation is returned in AntipiracyAttestation (it is a sealed class), which depending on the detection status can be of three types: Blank : This is a non-processed status. It should not be interpreted, as it does not carry any meaning about the attestation result. It is not to be interpreted as Clear ; Clear : The attestation has passed. There is nothing to report. This means that no installed software has triggered the detection from the battery of tests that have been executed, in compliance with the given scan parameters; Failed : The attestation has not passed. Pirated software has been detected. You can read which software has tripped the detection in the attestation result. The action you were about to do may be compromised, and you should not proceed. Warning Blank is completely different from Clear (or Failed ). It means that the software is initialized but that nothing has been done yet. Do not mix them up. Performance \u00b6 Package detection and testing make use of coroutines to run scan operations in parallel for each package, to minimize the time taken to run through all packages. Most of the checks consist of some type of string analysis (characters & regex matching and abstract alphabet inference, more details in detection ), which have pretty decent running times while being precise and reliable tools. Scan settings are taken into account intelligently to analyze and run the battery of tests over all packages in one single pass, regardless of how many checks are to be performed, and to execute the single package battery test in parallel. Timing The full attestation process takes from start to finish \u2248 75-200ms for my devices and emulators. It is mainly influenced by the processing power of the device, the number of apps installed, and your scan configuration. It is moderately fast.","title":"Overview"},{"location":"pages/modules/antipiracy/antipiracy/#antipiracy","text":"graph LR I[Inizialization] -.Settings..-> K{KevlarAntipiracy}; DB[(Dataset)] === K AREQ[Attestation Requests] --> K K --> |Clear| P[Passed]; K --> |Failed| NP[Not Passed]; P --> ARES[AntipiracyAttestation] NP --> ARES The antipiracy package contains tools for the detection of different categories of pirate software that may be installed and running on target devices. At its core, this package runs a battery of tests against all the installed applications to check for potential active pirate software, which depending on your policies may be a security environment issue. It then compiles the results into an attestation (it can either be uninitialized, clear, or failed) which is returned to your app, where you can check what has been found and act accordingly. Purpose of the antipiracy package You may want to use this package if you consider that executing your app alongside pirate software which may be interfering/bypassing your code/protections is a security environment issue. Tampering and System protection The antipiracy package by itself does not do any kind of signature/tampering check (for that, refer to integrity package) or system wide verification ( rooting ). It just tells you whether software that may be trying/have already interfered/bypassed your protection mechanisms is installed or not. To implement this, you initialize KevlarAntipiracy and provide your desired settings (which influence what is to be detected and what not). Then you can submit attestation requests (which will be executed according to your settings). Each attestation request will cause Kevlar to grab the package list, run the appropriate checks and compile an attestation. The settings you provide influence what will be included in the attestation. Empty & default settings The settings on antipiracy are additive. If you leave a blank DSL, nothing will be detected, because no checks will be run, because the settings are empty. If you do not pass a DSL at all, the default settings will be used (they only scan for pirate apps, not stores nor collateral). Custom private val antipiracy = KevlarAntipiracy { scan { pirate () store () collateral () } } Empty private val antipiracy = KevlarAntipiracy { scan { } } Default private val antipiracy = KevlarAntipiracy ()","title":"Antipiracy"},{"location":"pages/modules/antipiracy/antipiracy/#attestation-process-overview","text":"When you require an attestation (through antipiracy.attestate(context) ), kevlar executes the following operations: The installed package list is queried from the PackageManager . Make sure to have the right permissions to do that; The test battery is initialized (to match your scan parameters) and ran on all packages, against the precompiled dataset onboard the library; The results are collected, processed, filtered, and returned. There is only one type of attestation that can be produced. The attestation is returned in AntipiracyAttestation (it is a sealed class), which depending on the detection status can be of three types: Blank : This is a non-processed status. It should not be interpreted, as it does not carry any meaning about the attestation result. It is not to be interpreted as Clear ; Clear : The attestation has passed. There is nothing to report. This means that no installed software has triggered the detection from the battery of tests that have been executed, in compliance with the given scan parameters; Failed : The attestation has not passed. Pirated software has been detected. You can read which software has tripped the detection in the attestation result. The action you were about to do may be compromised, and you should not proceed. Warning Blank is completely different from Clear (or Failed ). It means that the software is initialized but that nothing has been done yet. Do not mix them up.","title":"Attestation process overview"},{"location":"pages/modules/antipiracy/antipiracy/#performance","text":"Package detection and testing make use of coroutines to run scan operations in parallel for each package, to minimize the time taken to run through all packages. Most of the checks consist of some type of string analysis (characters & regex matching and abstract alphabet inference, more details in detection ), which have pretty decent running times while being precise and reliable tools. Scan settings are taken into account intelligently to analyze and run the battery of tests over all packages in one single pass, regardless of how many checks are to be performed, and to execute the single package battery test in parallel. Timing The full attestation process takes from start to finish \u2248 75-200ms for my devices and emulators. It is mainly influenced by the processing power of the device, the number of apps installed, and your scan configuration. It is moderately fast.","title":"Performance"},{"location":"pages/modules/antipiracy/database/","text":"Database \u00b6 Kevlar comes pre-packaged with definitions for the most common pirate software. A simplified summary is reported in the following table: Software is the common name of the given pirate software; Internal Code is what kevlar uses to reference and report a specific software; Type defines whether the given software is a pirate store or pirate app; Most Common Package gives a probable package name for out in the wild pirate software. Usually pirate software have multiple (often numerous) package names, which are not reported in the table (but are obviously implemented in the library); Range defines which battery of tests is available against a given package. H is heuristic detection (package metadata string matching), A is alphabetical analysis and C are collateral tests. Software Internal Code Type Most Common Package Range Action Launcher Patcher ACTION_LAUNCHER_PATCHER App zone.jasi2169.uretpatcher H AC Market AC_MARKET Store ac.market.store H AGK App Killer AGK App com.aag.killer H All In One Downloader AIOD Store com.allinone.free H App Cake APP_CAKE Store com.appcake H App Sara APP_SARA App com.appsara.app H Aptoide APTOIDE Store cm.aptoide.pt H Black Mart BLACK_MART Store org.blackmart.market H Content Guard Disabler CGD App com.oneminusone.disablecontentguard H Creeplays Patcher CREEPLAYS_PATCHER App org.creeplays.hack H Cree Hack CREE_HACK App apps.zhasik007.hack H Freedom FREEDOM App jase.freedom H Game Hacker GAME_HACKER App org.sbtools.gamehack H Game Killer Cheats GAME_KILLER App com.killerapp.gamekiller H Get Apk GET_APK Store com.repodroid.app H Get Jar GET_JAR Store com.getjar.reward H Happymod HAPPYMOD Store happygames.io H Leo Playcards LEO_PLAYCARDS App com.leo.playcard H Lucky Patcher LUCKY_PATCHER App good luck H , A , C Mobilism MOBILISM Store org.mobilism.android H Mobogenie MOB_GENIE Store com.mobogenie H 1Mobile ONE_MOBILE Store me.onemobile.android H Slide Me SLIDE_ME Store com.slideme.sam.manager H Uret Patcher URET_PATCHER App zone.jasi2169.uretpatcher H XModGames XMG App com.xmodgame H Z Market Z_MARKET Store com.zmapp H","title":"Database"},{"location":"pages/modules/antipiracy/database/#database","text":"Kevlar comes pre-packaged with definitions for the most common pirate software. A simplified summary is reported in the following table: Software is the common name of the given pirate software; Internal Code is what kevlar uses to reference and report a specific software; Type defines whether the given software is a pirate store or pirate app; Most Common Package gives a probable package name for out in the wild pirate software. Usually pirate software have multiple (often numerous) package names, which are not reported in the table (but are obviously implemented in the library); Range defines which battery of tests is available against a given package. H is heuristic detection (package metadata string matching), A is alphabetical analysis and C are collateral tests. Software Internal Code Type Most Common Package Range Action Launcher Patcher ACTION_LAUNCHER_PATCHER App zone.jasi2169.uretpatcher H AC Market AC_MARKET Store ac.market.store H AGK App Killer AGK App com.aag.killer H All In One Downloader AIOD Store com.allinone.free H App Cake APP_CAKE Store com.appcake H App Sara APP_SARA App com.appsara.app H Aptoide APTOIDE Store cm.aptoide.pt H Black Mart BLACK_MART Store org.blackmart.market H Content Guard Disabler CGD App com.oneminusone.disablecontentguard H Creeplays Patcher CREEPLAYS_PATCHER App org.creeplays.hack H Cree Hack CREE_HACK App apps.zhasik007.hack H Freedom FREEDOM App jase.freedom H Game Hacker GAME_HACKER App org.sbtools.gamehack H Game Killer Cheats GAME_KILLER App com.killerapp.gamekiller H Get Apk GET_APK Store com.repodroid.app H Get Jar GET_JAR Store com.getjar.reward H Happymod HAPPYMOD Store happygames.io H Leo Playcards LEO_PLAYCARDS App com.leo.playcard H Lucky Patcher LUCKY_PATCHER App good luck H , A , C Mobilism MOBILISM Store org.mobilism.android H Mobogenie MOB_GENIE Store com.mobogenie H 1Mobile ONE_MOBILE Store me.onemobile.android H Slide Me SLIDE_ME Store com.slideme.sam.manager H Uret Patcher URET_PATCHER App zone.jasi2169.uretpatcher H XModGames XMG App com.xmodgame H Z Market Z_MARKET Store com.zmapp H","title":"Database"},{"location":"pages/modules/antipiracy/detection/","text":"Detection Techniques \u00b6 This page details the detection techniques (aka tricks) employed in Kevlar Antipiracy. It should be stated that all checks are run against the local dataset (what kevlar thinks are pirate apps & stores, a summary of that is in database ), which is hardcoded in the library and therefore in your shipped software. Obfuscation complexity Writing good self-obfuscating software is hard. There are a few ways, but essentially you need an installer package that carries the payload and an algorithm to insert the actual software in a randomized stub. If you do it well, there is no way to characterize your package and it is, therefore, more difficult (if not borderline impossible) to detect automatically ( Magisk does this exceptionally well, to the point that it is almost useless to try to achieve aggressive detection) Doing slightly less than perfection will lead to detection. String matching \u00b6 This is the most basic yet efficient scanning tool. Running a basic string match against some package parameters does miracles for detection, since most non-super-sneaky pirate software has a fixed package name, a fixed app label, a fixed class name, or all three. If kevlar catches even one of those, then the software is detected and will be reported in the attestation. It doesn't even need to be a full string match really, most of the time you need a partial (containment) match to detect something. This is very useful (and implemented) against prefix/postfix switching. Regex matching \u00b6 Same as above, but with regex. You can have more elaborate patterns or filters, since some packages distribute the same builds under different package names, thinking they are doing something clever. Abstract Alphabet Inference \u00b6 This is the most advanced bit in package detection. Some packages will swap characters with something very similar (usually in the label name), but not equal (and usually belonging to obscure charsets), so that they break classic string matching and make regex a hell to work with (the character's binary encoding is different, even if it looks the same to your eyes). And since this process is usually randomized, you can not know in advance which of the characters will be swapped and which will be real, so you have to take that into account. The solution is fast abstract matching, where we describe on a high level which string (word) we are looking for, and then kevlar will automatically run the check on every package translating the high-level description to known sneaky characters (1 abstract character maps to many sneaky characters). This can be checked strictly (full match), partially (contains), or probabilistically (given a minimum percentage of matches) For FSA people, this is like having multiple arcs from one state to the next, with all the sneaky characters as transitions. Word acceptance is equivalent to detection. Sneaky characters The usual roll includes characters from Latin fullwidth, Cyrillic, greek, a lot of weird uncategorized characters, and like 20 variations of the symbols /, _ and -. You can go check out the full list at AsciiVariations.kt . I'd advise doing so on an empty stomach. Collateral tools \u00b6 Some techniques may have non-zero false positive rates, and they are disabled by default. Kevlar's objective is to achieve accurate detection, with a non-zero false-negative rate, but a zero false-positive rate. Enabling collateral tools is a form of aggressive detection, and it should be used in scenarios where you are willing to accept some risk to get (very) slightly better detection for the price of non-zero false positives. The detection works because we know how some specific software tries to obfuscate/randomize its stub. We can therefore match for the distribution of those values in all installed packages, and if one matches then it may be what we are looking for. Collateral example in package name randomization The easiest example to illustrate this technique is with Lucky Patcher . Its installer generates a randomized stub, inserts the payload (the actual pirate software), and installs it. While the stub's package name has random bits, it is not completely random. It always starts with \"ru.\", followed by 8 random characters, followed by a \".\", followed by another 9 random characters. stateDiagram-v2 direction LR [*] --> ru. ru. --> 8? 8? --> . . --> 9? 9? --> . . --> [*] Using this technique will successfully detect lucky patcher's stub if installed, along with any other software whose package name happens to match the given specification","title":"Detection"},{"location":"pages/modules/antipiracy/detection/#detection-techniques","text":"This page details the detection techniques (aka tricks) employed in Kevlar Antipiracy. It should be stated that all checks are run against the local dataset (what kevlar thinks are pirate apps & stores, a summary of that is in database ), which is hardcoded in the library and therefore in your shipped software. Obfuscation complexity Writing good self-obfuscating software is hard. There are a few ways, but essentially you need an installer package that carries the payload and an algorithm to insert the actual software in a randomized stub. If you do it well, there is no way to characterize your package and it is, therefore, more difficult (if not borderline impossible) to detect automatically ( Magisk does this exceptionally well, to the point that it is almost useless to try to achieve aggressive detection) Doing slightly less than perfection will lead to detection.","title":"Detection Techniques"},{"location":"pages/modules/antipiracy/detection/#string-matching","text":"This is the most basic yet efficient scanning tool. Running a basic string match against some package parameters does miracles for detection, since most non-super-sneaky pirate software has a fixed package name, a fixed app label, a fixed class name, or all three. If kevlar catches even one of those, then the software is detected and will be reported in the attestation. It doesn't even need to be a full string match really, most of the time you need a partial (containment) match to detect something. This is very useful (and implemented) against prefix/postfix switching.","title":"String matching"},{"location":"pages/modules/antipiracy/detection/#regex-matching","text":"Same as above, but with regex. You can have more elaborate patterns or filters, since some packages distribute the same builds under different package names, thinking they are doing something clever.","title":"Regex matching"},{"location":"pages/modules/antipiracy/detection/#abstract-alphabet-inference","text":"This is the most advanced bit in package detection. Some packages will swap characters with something very similar (usually in the label name), but not equal (and usually belonging to obscure charsets), so that they break classic string matching and make regex a hell to work with (the character's binary encoding is different, even if it looks the same to your eyes). And since this process is usually randomized, you can not know in advance which of the characters will be swapped and which will be real, so you have to take that into account. The solution is fast abstract matching, where we describe on a high level which string (word) we are looking for, and then kevlar will automatically run the check on every package translating the high-level description to known sneaky characters (1 abstract character maps to many sneaky characters). This can be checked strictly (full match), partially (contains), or probabilistically (given a minimum percentage of matches) For FSA people, this is like having multiple arcs from one state to the next, with all the sneaky characters as transitions. Word acceptance is equivalent to detection. Sneaky characters The usual roll includes characters from Latin fullwidth, Cyrillic, greek, a lot of weird uncategorized characters, and like 20 variations of the symbols /, _ and -. You can go check out the full list at AsciiVariations.kt . I'd advise doing so on an empty stomach.","title":"Abstract Alphabet Inference"},{"location":"pages/modules/antipiracy/detection/#collateral-tools","text":"Some techniques may have non-zero false positive rates, and they are disabled by default. Kevlar's objective is to achieve accurate detection, with a non-zero false-negative rate, but a zero false-positive rate. Enabling collateral tools is a form of aggressive detection, and it should be used in scenarios where you are willing to accept some risk to get (very) slightly better detection for the price of non-zero false positives. The detection works because we know how some specific software tries to obfuscate/randomize its stub. We can therefore match for the distribution of those values in all installed packages, and if one matches then it may be what we are looking for. Collateral example in package name randomization The easiest example to illustrate this technique is with Lucky Patcher . Its installer generates a randomized stub, inserts the payload (the actual pirate software), and installs it. While the stub's package name has random bits, it is not completely random. It always starts with \"ru.\", followed by 8 random characters, followed by a \".\", followed by another 9 random characters. stateDiagram-v2 direction LR [*] --> ru. ru. --> 8? 8? --> . . --> 9? 9? --> . . --> [*] Using this technique will successfully detect lucky patcher's stub if installed, along with any other software whose package name happens to match the given specification","title":"Collateral tools"},{"location":"pages/modules/antipiracy/implementation/","text":"Implementation \u00b6 A working example for the antipiracy module can be found in the github repository under the :showcase module. Dependency \u00b6 Gradle dependencies { implementation \"com.github.kevlar-kt:antipiracy:1.0.0\" } Kotlin DSL dependencies { implementation ( \"com.github.kevlar-kt:antipiracy:1.0.0\" ) } Maven <dependency> <groupId> com.github.kevlar-kt </groupId> <artifactId> antipiracy </artifactId> <version> 1.0.0 </version> <type> pom </type> </dependency> Permissions \u00b6 You can read the details in privacy , but essentially since android R (API 30) it is necessary to include the following permission in your app's AndroidManifest.xml in order to successfully query the package list. <uses-permission android:name= \"android.permission.QUERY_ALL_PACKAGES\" tools:ignore= \"QueryAllPackagesPermission\" /> Initialization & Attestations \u00b6 You need to create a KevlarAntipiracy instance (which is the way you will be requesting attestations), along with your desired parameters (either global, local or in your repository layer, if you are using MVVM/MVC). Once you have that, you just go ahead and call antipiracy.attestate() in a coroutine and your system will be analyzed, according to the provided parameters. AntipiracyAttestation will be returned from the call (it's a sealed class), containing the found software list, if any. Note that we will be initializing KevlarAntipiracy with custom scan settings, but you could leave it as default. In-Place \u00b6 This is the most concise way to implement piracy checks. InPlace.kt val antipiracy = KevlarAntipiracy { scan { // your scan configuration pirate () store () } } CoroutineScope ( Dispatchers . Default ). launch { // Attestation request when ( val attestation = antipiracy . attestate ( context )) { is AntipiracyAttestation . Blank -> { // Pending attestation, no information yet. // Don't do anything. } is AntipiracyAttestation . Clear -> { // Good to go. } is AntipiracyAttestation . Failed -> { // Pirate software detected. } } } This packs everything in one file. It is not excellent when writing a modern applications but it does its job. ViewModel + Repository + SharedFlow + DI with Hilt \u00b6 Activity: \u00b6 AntipiracyActivity.kt @AndroidEntryPoint class AntipiracyActivity : AppCompatActivity () { private val vm : ActivityViewModel by viewModels () override fun onCreate ( savedInstanceState : Bundle?) { super . onCreate ( savedInstanceState ) lifecycleScope . launch { lifecycle . repeatOnLifecycle ( Lifecycle . State . STARTED ) { vm . attestation . collectLatest { when ( it ) { is AntipiracyAttestation . Blank -> { // Pending attestation, no information yet. // Don't do anything. } is AntipiracyAttestation . Clear -> { // Good to go. } is AntipiracyAttestation . Failed -> { // Pirate software detected. } } } } } CoroutineScope ( Dispatchers . Main ). launch { vm . requestAttestation () } } } View model: \u00b6 ActivityViewModel.kt @HiltViewModel class ActivityViewModel @Inject constructor ( private val securityRepository : AntipiracyRepository ) : ViewModel () { private val _attestationState = MutableStateFlow ( KevlarAntipiracy . blankAttestation ()) val attestation : SharedFlow < AntipiracyAttestation > = _attestationState . stateIn ( viewModelScope , SharingStarted . Eagerly , initialValue = KevlarAntipiracy . blankAttestation () ) fun requestAttestation () { viewModelScope . launch { _attestationState . value = securityRepository . attestate () } } } Repository \u00b6 AntipiracyRepository.kt class AntipiracyRepository @Inject constructor ( @ApplicationContext val context : Context , @IoDispatcher val externalDispatcher : CoroutineDispatcher ) { private val antipiracy = KevlarAntipiracy { scan { // your scan configuration DSL here pirate () store () } } suspend fun attestate (): AntipiracyAttestation = withContext ( externalDispatcher ) { antipiracy . attestate ( context ) } }","title":"Implementation"},{"location":"pages/modules/antipiracy/implementation/#implementation","text":"A working example for the antipiracy module can be found in the github repository under the :showcase module.","title":"Implementation"},{"location":"pages/modules/antipiracy/implementation/#dependency","text":"Gradle dependencies { implementation \"com.github.kevlar-kt:antipiracy:1.0.0\" } Kotlin DSL dependencies { implementation ( \"com.github.kevlar-kt:antipiracy:1.0.0\" ) } Maven <dependency> <groupId> com.github.kevlar-kt </groupId> <artifactId> antipiracy </artifactId> <version> 1.0.0 </version> <type> pom </type> </dependency>","title":"Dependency"},{"location":"pages/modules/antipiracy/implementation/#permissions","text":"You can read the details in privacy , but essentially since android R (API 30) it is necessary to include the following permission in your app's AndroidManifest.xml in order to successfully query the package list. <uses-permission android:name= \"android.permission.QUERY_ALL_PACKAGES\" tools:ignore= \"QueryAllPackagesPermission\" />","title":"Permissions"},{"location":"pages/modules/antipiracy/implementation/#initialization-attestations","text":"You need to create a KevlarAntipiracy instance (which is the way you will be requesting attestations), along with your desired parameters (either global, local or in your repository layer, if you are using MVVM/MVC). Once you have that, you just go ahead and call antipiracy.attestate() in a coroutine and your system will be analyzed, according to the provided parameters. AntipiracyAttestation will be returned from the call (it's a sealed class), containing the found software list, if any. Note that we will be initializing KevlarAntipiracy with custom scan settings, but you could leave it as default.","title":"Initialization &amp; Attestations"},{"location":"pages/modules/antipiracy/implementation/#in-place","text":"This is the most concise way to implement piracy checks. InPlace.kt val antipiracy = KevlarAntipiracy { scan { // your scan configuration pirate () store () } } CoroutineScope ( Dispatchers . Default ). launch { // Attestation request when ( val attestation = antipiracy . attestate ( context )) { is AntipiracyAttestation . Blank -> { // Pending attestation, no information yet. // Don't do anything. } is AntipiracyAttestation . Clear -> { // Good to go. } is AntipiracyAttestation . Failed -> { // Pirate software detected. } } } This packs everything in one file. It is not excellent when writing a modern applications but it does its job.","title":"In-Place"},{"location":"pages/modules/antipiracy/implementation/#viewmodel-repository-sharedflow-di-with-hilt","text":"","title":"ViewModel + Repository + SharedFlow + DI with Hilt"},{"location":"pages/modules/antipiracy/implementation/#activity","text":"AntipiracyActivity.kt @AndroidEntryPoint class AntipiracyActivity : AppCompatActivity () { private val vm : ActivityViewModel by viewModels () override fun onCreate ( savedInstanceState : Bundle?) { super . onCreate ( savedInstanceState ) lifecycleScope . launch { lifecycle . repeatOnLifecycle ( Lifecycle . State . STARTED ) { vm . attestation . collectLatest { when ( it ) { is AntipiracyAttestation . Blank -> { // Pending attestation, no information yet. // Don't do anything. } is AntipiracyAttestation . Clear -> { // Good to go. } is AntipiracyAttestation . Failed -> { // Pirate software detected. } } } } } CoroutineScope ( Dispatchers . Main ). launch { vm . requestAttestation () } } }","title":"Activity:"},{"location":"pages/modules/antipiracy/implementation/#view-model","text":"ActivityViewModel.kt @HiltViewModel class ActivityViewModel @Inject constructor ( private val securityRepository : AntipiracyRepository ) : ViewModel () { private val _attestationState = MutableStateFlow ( KevlarAntipiracy . blankAttestation ()) val attestation : SharedFlow < AntipiracyAttestation > = _attestationState . stateIn ( viewModelScope , SharingStarted . Eagerly , initialValue = KevlarAntipiracy . blankAttestation () ) fun requestAttestation () { viewModelScope . launch { _attestationState . value = securityRepository . attestate () } } }","title":"View model:"},{"location":"pages/modules/antipiracy/implementation/#repository","text":"AntipiracyRepository.kt class AntipiracyRepository @Inject constructor ( @ApplicationContext val context : Context , @IoDispatcher val externalDispatcher : CoroutineDispatcher ) { private val antipiracy = KevlarAntipiracy { scan { // your scan configuration DSL here pirate () store () } } suspend fun attestate (): AntipiracyAttestation = withContext ( externalDispatcher ) { antipiracy . attestate ( context ) } }","title":"Repository"},{"location":"pages/modules/antipiracy/privacy/","text":"Privacy & Package Queries \u00b6 The antipiracy module is designed to check user-wide security. As such, it is the layer that is closest to the user data and thus needs to take extra care to enforce user privacy requirements. Package Queries \u00b6 A crucial element in this process is retrieving the application list, in which all the checks are subsequently run on. This is increasingly getting difficult. Since Android 11 (API 30) the full package list is filtered by default , and there are more privacy-friendly (less intrusive) methods for querying apps. Those don't work as well with pirate app detection because usually pirate software actively tries to hide its presence with camouflage techniques A not-so-elegant but 100% functional solution is to add the QUERY_ALL_PACKAGES permission in the manifest, so that your app has clearance to query the whole app spectrum, enabling pirate apps detection. <uses-permission android:name= \"android.permission.QUERY_ALL_PACKAGES\" tools:ignore= \"QueryAllPackagesPermission\" /> User Privacy & Attitude \u00b6 Another delicate aspect of querying installed packages is the way you communicate to the user that you just scanned all the packages and found pirate software, and therefore will not let them proceed to the purchase they were about to happily crack. While obviously, you should not by any means be afraid to deny the purchase/transaction/service to a malevolent user, there are varying degrees of directness with which you can communicate your decision to the end user. Usually, they are not best pleased with the discovery, so a little bit of touch is advised. Some implementations go the other way and just do not work/act as broken, while in reality they did a much deeper check, found that the environment is unsafe, assumed that the currently running software is pirated, and refused to proceed. Usually, this works because the user knows it is doing something wrong and it expects that something may break or that some self-checking is in place. Protection & Reviews I have implemented in all my commercial Android software some sort of piracy checks, and while I'd like to show you some store reviews, I will refrain from exposing your uninitialized eyes to the unfathomable pain I went through while reading them in the first place. Let's just say it usually goes down like this: User tries to crack your app with pirate software; Your app picks up the pirate software, and refuses to start the in-app transaction because the environment is unsecured; Said user suddenly becomes a mobile security expert and goes on the store to angrily review your app as garbage/spyware/malware/trojan/...","title":"Privacy & Permissions"},{"location":"pages/modules/antipiracy/privacy/#privacy-package-queries","text":"The antipiracy module is designed to check user-wide security. As such, it is the layer that is closest to the user data and thus needs to take extra care to enforce user privacy requirements.","title":"Privacy &amp; Package Queries"},{"location":"pages/modules/antipiracy/privacy/#package-queries","text":"A crucial element in this process is retrieving the application list, in which all the checks are subsequently run on. This is increasingly getting difficult. Since Android 11 (API 30) the full package list is filtered by default , and there are more privacy-friendly (less intrusive) methods for querying apps. Those don't work as well with pirate app detection because usually pirate software actively tries to hide its presence with camouflage techniques A not-so-elegant but 100% functional solution is to add the QUERY_ALL_PACKAGES permission in the manifest, so that your app has clearance to query the whole app spectrum, enabling pirate apps detection. <uses-permission android:name= \"android.permission.QUERY_ALL_PACKAGES\" tools:ignore= \"QueryAllPackagesPermission\" />","title":"Package Queries"},{"location":"pages/modules/antipiracy/privacy/#user-privacy-attitude","text":"Another delicate aspect of querying installed packages is the way you communicate to the user that you just scanned all the packages and found pirate software, and therefore will not let them proceed to the purchase they were about to happily crack. While obviously, you should not by any means be afraid to deny the purchase/transaction/service to a malevolent user, there are varying degrees of directness with which you can communicate your decision to the end user. Usually, they are not best pleased with the discovery, so a little bit of touch is advised. Some implementations go the other way and just do not work/act as broken, while in reality they did a much deeper check, found that the environment is unsafe, assumed that the currently running software is pirated, and refused to proceed. Usually, this works because the user knows it is doing something wrong and it expects that something may break or that some self-checking is in place. Protection & Reviews I have implemented in all my commercial Android software some sort of piracy checks, and while I'd like to show you some store reviews, I will refrain from exposing your uninitialized eyes to the unfathomable pain I went through while reading them in the first place. Let's just say it usually goes down like this: User tries to crack your app with pirate software; Your app picks up the pirate software, and refuses to start the in-app transaction because the environment is unsecured; Said user suddenly becomes a mobile security expert and goes on the store to angrily review your app as garbage/spyware/malware/trojan/...","title":"User Privacy &amp; Attitude"},{"location":"pages/modules/antipiracy/tradeoffs/","text":"Tradeoffs \u00b6 kevlar is not an antivirus. It is not designed to be on that end of the spectrum. It is an heuristic to quickly catch most of the junk installed on the device. As a general rule of thumb: If you want more precision, you need more time (There are advanced and stricter checks used in financial software: archive and directory scanning, extended signature checks, and everything done with professional security software, but doing that defeats the purpose ). If you want less running time, you will have less precision.","title":"Tradeoffs"},{"location":"pages/modules/antipiracy/tradeoffs/#tradeoffs","text":"kevlar is not an antivirus. It is not designed to be on that end of the spectrum. It is an heuristic to quickly catch most of the junk installed on the device. As a general rule of thumb: If you want more precision, you need more time (There are advanced and stricter checks used in financial software: archive and directory scanning, extended signature checks, and everything done with professional security software, but doing that defeats the purpose ). If you want less running time, you will have less precision.","title":"Tradeoffs"},{"location":"pages/modules/integrity/hardcoding/","text":"Hardcoded data \u00b6 When an application is being tampered with, its code can change. Its behavior can mutate. Its features may (and will) be radically different than what you have developed in production. This introduces all kinds of issues regarding the consistency of the code itself. The key to detection is being able to avoid some of those code changes on hardcoded data, and detecting inconsistencies Nintendo Antipiracy & Consistency checks Some Nintendo games are known to have self-checking and inconsistency detection for antipiracy purposes. They may, for instance, read from a non-existent memory slot [on purpose] as a form of check, and if the read operation is successful then it is likely that the program is being run in a pirate environment (tape, emulator, or custom hardware), as opposed to an original one, where the read operation would have failed. Package name change \u00b6 A simple example would be an attack that aims at changing the package name of your app. They usually just change application metadata and packages and try to recompile them. If it is done well, they may try to also run a text search inside application strings to look for the package, just in case it was saved in a string variable, and change it too. If it is done extremely well (not implemented anywhere afaik), then they may also try to break some of the easy string obfuscation (base64 or other text encodings & charsets) and produce a different string that de-obfuscates to what the changed package name is. About signature changes Whatever you sign is eternal. Signature verification is extremely important because nobody else can sign software with your signature (since you have your private key in the Keystore). Modifying even one bit inside your app requires the attacker to sign the application. And since they don't have access to your Keystore, they can only resign it with their key or a debug key. But the point is, it is not your one. As soon as you detect that your signature doesn't match the one on the package that's running, you know that something has gone wrong. Protection through Obfuscation \u00b6 As much as this may look like security through obscurity, it is a necessary technique employed to make sure that automatic attacks against your app's code do not also intercept your hardcoded data. This is because an automated attack may try to find any hardcoded metadata and replace it with the new value they are trying to change to. Creating a safe container for those truth values is vital for the checks so that they can compare the original hardcoded value with the runtime value, and match them.","title":"Hardcoding"},{"location":"pages/modules/integrity/hardcoding/#hardcoded-data","text":"When an application is being tampered with, its code can change. Its behavior can mutate. Its features may (and will) be radically different than what you have developed in production. This introduces all kinds of issues regarding the consistency of the code itself. The key to detection is being able to avoid some of those code changes on hardcoded data, and detecting inconsistencies Nintendo Antipiracy & Consistency checks Some Nintendo games are known to have self-checking and inconsistency detection for antipiracy purposes. They may, for instance, read from a non-existent memory slot [on purpose] as a form of check, and if the read operation is successful then it is likely that the program is being run in a pirate environment (tape, emulator, or custom hardware), as opposed to an original one, where the read operation would have failed.","title":"Hardcoded data"},{"location":"pages/modules/integrity/hardcoding/#package-name-change","text":"A simple example would be an attack that aims at changing the package name of your app. They usually just change application metadata and packages and try to recompile them. If it is done well, they may try to also run a text search inside application strings to look for the package, just in case it was saved in a string variable, and change it too. If it is done extremely well (not implemented anywhere afaik), then they may also try to break some of the easy string obfuscation (base64 or other text encodings & charsets) and produce a different string that de-obfuscates to what the changed package name is. About signature changes Whatever you sign is eternal. Signature verification is extremely important because nobody else can sign software with your signature (since you have your private key in the Keystore). Modifying even one bit inside your app requires the attacker to sign the application. And since they don't have access to your Keystore, they can only resign it with their key or a debug key. But the point is, it is not your one. As soon as you detect that your signature doesn't match the one on the package that's running, you know that something has gone wrong.","title":"Package name change"},{"location":"pages/modules/integrity/hardcoding/#protection-through-obfuscation","text":"As much as this may look like security through obscurity, it is a necessary technique employed to make sure that automatic attacks against your app's code do not also intercept your hardcoded data. This is because an automated attack may try to find any hardcoded metadata and replace it with the new value they are trying to change to. Creating a safe container for those truth values is vital for the checks so that they can compare the original hardcoded value with the runtime value, and match them.","title":"Protection through Obfuscation"},{"location":"pages/modules/integrity/implementation/","text":"Implementation \u00b6 Implementing integrity requires, on top of a KevlarAntipiracy and the attestation infrastructure, a tiny bit of information about your application's metadata, which will be hardcoded inside it. This is necessary to provide kevlar a truth value to match the runtime values (which may have been tampered and altered) against. The obfuscation is necessary because we need to conceal the truth values, since they will be looked for by the attacker (software or human), and make it as hard as possible to automatically find and patch them. A working example for the integrity module can be found in the github repository under the :showcase module. Dependency \u00b6 Gradle dependencies { implementation \"com.github.kevlar-kt:integrity:1.0.0\" } Kotlin DSL dependencies { implementation ( \"com.github.kevlar-kt:integrity:1.0.0\" ) } Maven <dependency> <groupId> com.github.kevlar-kt </groupId> <artifactId> integrity </artifactId> <version> 1.0.0 </version> <type> pom </type> </dependency> Hardcoded metadata \u00b6 The first step is getting the necessary metadata. You need the following: Your application package name ; Your application signature . They go right in a class which is required in order to initialize KevlarIntegrity . hardcoded_metadata.kt private val hardcodedMetadata = HardcodedMetadata ( packageName = \"com.kevlar.showcase\" , // showcase package name signature = \"K+wrXLluOI8B5LkisWQPE4jLew=\" // debug signature ) Finding metadata \u00b6 You already know the package name, and the signature can be extracted directly from kevlar with: KevlarIntegrity . obtainCurrentAppSignature ( context ) Grab that string value and save it along with your package name. Do not Maybe, just maybe, you may be tempted to so something like this: VERY_BAD_hardcoded_metadata.kt private val notAtAllHardcodedMetadata = HardcodedMetadata ( packageName = context . getPackageName (), signature = getRuntimeSignature () ) Refrain from coding this monstruosity. The sole purpose of HardcodedMetadata is hardcoding truth values inside your app. This little snippet single handedly kills the whole library (because obviously the runtime package name will match the runtime package name) and is like shooting yourself in the foot with a cannon. Don't. Obfuscating metadata \u00b6 The second step (optional but recommended) is obfuscating the metadata you just read, so that it is saved in an obfuscated form (in your bytecode, so that automatic tools can't find it), but passed to kevlar deobfuscated (so that we have the original truth values). There are a few ways to do it: No obfuscation (not recommended) \u00b6 You just save the values as they are and pass them in HardcodedMetadata unobfuscated_hardcoded_metadata.kt private const val packageName = \"\"\"com.kevlar.showcase\"\"\" private const val signature = \"\"\"J+nqXLfuIO8B2AmhkMYHGE4jDyw=\"\"\" private val hardcodedMetadata = HardcodedMetadata ( packageName , signature ) Bytecode The produced kotlin bytecode clearly exposes the raw values: 1 2 3 4 5 6 7 8 9 10 11 L1 ALOAD 0 NEW com/kevlar/integrity/model/HardcodedMetadata DUP L2 LDC \"com.kevlar.showcase\" L3 LDC \"J+nqXLfuIO8B2AmhkMYHGE4jDyw=\" L4 INVOKESPECIAL com/kevlar/integrity/model/HardcodedMetadata.<init> (Ljava/lang/String;Ljava/lang/String;)V PUTFIELD com/kevlar/showcase/data/repo/IntegrityRepository.hardcodedMetadata : Lcom/kevlar/integrity/model/HardcodedMetadata; Base64 obfuscation \u00b6 You store the package name and signature values as Base64-encoded byte arrays, and they go through the Base64.decode() function when creating HardcodedMetadata . base64_obfuscated_hardcoded_metadata.kt private val packageName = \"\"\"Y29tLmtldmxhci5zaG93Y2FzZQ==\"\"\" . toByteArray ( Charsets . UTF_8 ) private val signature = \"\"\"SitucVhMZnVJTzhCMkFtaGtNWUhHRTRqRHl3PQ==\"\"\" . toByteArray ( Charsets . UTF_8 ) private val base64ObfuscatedHardcodedMetadata = HardcodedMetadata ( Base64 . decode ( packageName , Base64 . DEFAULT ). toString ( Charsets . UTF_8 ), Base64 . decode ( signature , Base64 . DEFAULT ). toString ( Charsets . UTF_8 ) ) Where Y29tLmtldmxhci5zaG93Y2FzZQ== is the base64 encoding of com.kevlar.showcase , and SitucVhMZnVJTzhCMkFtaGtNWUhHRTRqRHl3PQ== of J+nqXLfuIO8B2AmhkMYHGE4jDyw= . You can look them up online , grab them from your app or use openssl base64 in the terminal. Base64 flags & charset The flag field and charset don't necessarily need to be Base64.DEFAULT and UTF_8 . Even though they are the most popular, you may choose something else if you prefer, as long as you preserve consistency. Bytecode Here the metadata is hidden and not targetable with basic find-and-replace techniques 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 L6 ALOAD 0 LDC \"Y29tLmtldmxhci5zaG93Y2FzZQ==\" ASTORE 3 GETSTATIC kotlin/text/Charsets.UTF_8 : Ljava/nio/charset/Charset; ASTORE 4 L7 ALOAD 3 L8 ALOAD 4 INVOKEVIRTUAL java/lang/String.getBytes (Ljava/nio/charset/Charset;)[B DUP LDC \"(this as java.lang.String).getBytes(charset)\" INVOKESTATIC kotlin/jvm/internal/Intrinsics.checkNotNullExpressionValue (Ljava/lang/Object;Ljava/lang/String;)V L9 PUTFIELD com/kevlar/showcase/data/repo/IntegrityRepository.packageName : [B L10 ALOAD 0 LDC \"SitucVhMZnVJTzhCMkFtaGtNWUhHRTRqRHl3PQ==\" ASTORE 3 GETSTATIC kotlin/text/Charsets.UTF_8 : Ljava/nio/charset/Charset; ASTORE 4 L11 ALOAD 3 L12 ALOAD 4 INVOKEVIRTUAL java/lang/String.getBytes (Ljava/nio/charset/Charset;)[B DUP LDC \"(this as java.lang.String).getBytes(charset)\" INVOKESTATIC kotlin/jvm/internal/Intrinsics.checkNotNullExpressionValue (Ljava/lang/Object;Ljava/lang/String;)V L13 PUTFIELD com/kevlar/showcase/data/repo/IntegrityRepository.signature : [B L14 ALOAD 0 NEW com/kevlar/integrity/model/HardcodedMetadata DUP L15 ALOAD 0 GETFIELD com/kevlar/showcase/data/repo/IntegrityRepository.packageName : [B ICONST_0 INVOKESTATIC android/util/Base64.decode ([BI)[B DUP LDC \"Base64.decode(packageName, Base64.DEFAULT)\" INVOKESTATIC kotlin/jvm/internal/Intrinsics.checkNotNullExpressionValue (Ljava/lang/Object;Ljava/lang/String;)V ASTORE 3 GETSTATIC kotlin/text/Charsets.UTF_8 : Ljava/nio/charset/Charset; ASTORE 4 L16 NEW java/lang/String DUP ALOAD 3 ALOAD 4 INVOKESPECIAL java/lang/String.<init> ([BLjava/nio/charset/Charset;)V L17 L18 ALOAD 0 GETFIELD com/kevlar/showcase/data/repo/IntegrityRepository.signature : [B ICONST_0 INVOKESTATIC android/util/Base64.decode ([BI)[B DUP LDC \"Base64.decode(signature, Base64.DEFAULT)\" INVOKESTATIC kotlin/jvm/internal/Intrinsics.checkNotNullExpressionValue (Ljava/lang/Object;Ljava/lang/String;)V ASTORE 3 GETSTATIC kotlin/text/Charsets.UTF_8 : Ljava/nio/charset/Charset; ASTORE 4 L19 NEW java/lang/String DUP ALOAD 3 ALOAD 4 INVOKESPECIAL java/lang/String.<init> ([BLjava/nio/charset/Charset;)V L20 L21 INVOKESPECIAL com/kevlar/integrity/model/HardcodedMetadata.<init> (Ljava/lang/String;Ljava/lang/String;)V PUTFIELD com/kevlar/showcase/data/repo/IntegrityRepository.base64ObfuscatedHardcodedMetadata : Lcom/kevlar/integrity/model/HardcodedMetadata; Encryption (+base64) \u00b6 A better alternative is to encrypt the hardcoded metadata, store them in an encrypted form, and send them through a decryption function when creating HardcodedMetadata . encrypted_hardcoded_metadata.kt private val key256 = \"\"\"4t7w!z%C*F-JaNcRfUjXn2r5u8x/A?D\"\"\" private val packageName = \"\"\"s3wf/AOYtr9BEMVFrweeLnkmerryUykMA8O77S5tMlI=\"\"\" . toByteArray ( Charsets . UTF_8 ) private val signature = \"\"\"tqMJquO3D+EKx1rx4R7/qzmsuEgpp1bKwxXe9AeB/WU=\"\"\" . toByteArray ( Charsets . UTF_8 ) private val encryptedHardcodedMetadata = HardcodedMetadata ( EncryptionUtil . decrypt ( packageName , key256 ), EncryptionUtil . decrypt ( signature , key256 ) ) Where 7KAa2CFkhPQOUouDu32KZJLqOzGFbTTnJA3rGxMlAg4= is the encrypted value of com.kevlar.showcase , and +ylMx63kwFRmXKHQU0cbzyb8MJ1iiGW1g8+MjDRcS/o= of J+nqXLfuIO8B2AmhkMYHGE4jDyw= . This ensures that there is no possibility that an automatic attack picks up the string as a package name or signature, and trivial string substitutions or encodings like base64 won't give any information away (the ciphertext is encoded in base64). AES128 or AES256 is recommended as the encryption algorithm (it's a little overkill but it does the job). The ciphertext may also be stored as a byte array. Encryption utility This tiny class (from the showcase module in the repository) is a basic AES encryption/decryption utility. EncryptionUtil.kt import android.util.Base64 import javax.crypto.Cipher import javax.crypto.SecretKey import javax.crypto.spec.SecretKeySpec object EncryptionUtil { private const val algorithm = \"AES\" private const val transformation = \"AES/ECB/PKCS5Padding\" fun generateKey ( key : String ): SecretKey = SecretKeySpec ( key . toByteArray (), algorithm ) fun encrypt ( text : ByteArray , secret : SecretKey ): String { val cipher : Cipher = Cipher . getInstance ( transformation ). apply { init ( Cipher . ENCRYPT_MODE , secret ) } return Base64 . encodeToString ( cipher . doFinal ( text ), Base64 . NO_WRAP ) ?: \"\" } fun decrypt ( ciphertext : ByteArray , secret : SecretKey ): String { val cipher : Cipher = Cipher . getInstance ( transformation ). apply { init ( Cipher . DECRYPT_MODE , secret ) } return String ( cipher . doFinal ( Base64 . decode ( ciphertext , Base64 . NO_WRAP )), Charsets . UTF_8 ) } } Bytecode Here detecting and reconstructing the original package name automatically is basically impossible 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 L22 ALOAD 0 LDC \"4t7w!z%C*F-JaNcRfUjXn2r5u8x/A?Ds\" PUTFIELD com/kevlar/showcase/data/repo/IntegrityRepository.key256 : Ljava/lang/String; L23 ALOAD 0 LDC \"s3wf/AOYtr9BEMVFrweeLnkmerryUykMA8O77S5tMlI=\" ASTORE 3 GETSTATIC kotlin/text/Charsets.UTF_8 : Ljava/nio/charset/Charset; ASTORE 4 L24 ALOAD 3 L25 ALOAD 4 INVOKEVIRTUAL java/lang/String.getBytes (Ljava/nio/charset/Charset;)[B DUP LDC \"(this as java.lang.String).getBytes(charset)\" INVOKESTATIC kotlin/jvm/internal/Intrinsics.checkNotNullExpressionValue (Ljava/lang/Object;Ljava/lang/String;)V L26 PUTFIELD com/kevlar/showcase/data/repo/IntegrityRepository.encryptedPackageName : [B L27 ALOAD 0 LDC \"tqMJquO3D+EKx1rx4R7/qzmsuEgpp1bKwxXe9AeB/WU=\" ASTORE 3 GETSTATIC kotlin/text/Charsets.UTF_8 : Ljava/nio/charset/Charset; ASTORE 4 L28 ALOAD 3 L29 ALOAD 4 INVOKEVIRTUAL java/lang/String.getBytes (Ljava/nio/charset/Charset;)[B DUP LDC \"(this as java.lang.String).getBytes(charset)\" INVOKESTATIC kotlin/jvm/internal/Intrinsics.checkNotNullExpressionValue (Ljava/lang/Object;Ljava/lang/String;)V L30 PUTFIELD com/kevlar/showcase/data/repo/IntegrityRepository.encryptedSignature : [B L31 ALOAD 0 NEW com/kevlar/integrity/model/HardcodedMetadata DUP L32 GETSTATIC com/kevlar/showcase/util/EncryptionUtil.INSTANCE : Lcom/kevlar/showcase/util/EncryptionUtil; ALOAD 0 GETFIELD com/kevlar/showcase/data/repo/IntegrityRepository.encryptedPackageName : [B GETSTATIC com/kevlar/showcase/util/EncryptionUtil.INSTANCE : Lcom/kevlar/showcase/util/EncryptionUtil; ALOAD 0 GETFIELD com/kevlar/showcase/data/repo/IntegrityRepository.key256 : Ljava/lang/String; INVOKEVIRTUAL com/kevlar/showcase/util/EncryptionUtil.generateKey (Ljava/lang/String;)Ljavax/crypto/SecretKey; INVOKEVIRTUAL com/kevlar/showcase/util/EncryptionUtil.decrypt ([BLjavax/crypto/SecretKey;)Ljava/lang/String; L33 GETSTATIC com/kevlar/showcase/util/EncryptionUtil.INSTANCE : Lcom/kevlar/showcase/util/EncryptionUtil; ALOAD 0 GETFIELD com/kevlar/showcase/data/repo/IntegrityRepository.encryptedSignature : [B GETSTATIC com/kevlar/showcase/util/EncryptionUtil.INSTANCE : Lcom/kevlar/showcase/util/EncryptionUtil; ALOAD 0 GETFIELD com/kevlar/showcase/data/repo/IntegrityRepository.key256 : Ljava/lang/String; INVOKEVIRTUAL com/kevlar/showcase/util/EncryptionUtil.generateKey (Ljava/lang/String;)Ljavax/crypto/SecretKey; INVOKEVIRTUAL com/kevlar/showcase/util/EncryptionUtil.decrypt ([BLjavax/crypto/SecretKey;)Ljava/lang/String; L34 INVOKESPECIAL com/kevlar/integrity/model/HardcodedMetadata.<init> (Ljava/lang/String;Ljava/lang/String;)V PUTFIELD com/kevlar/showcase/data/repo/IntegrityRepository.aes256EncryptedHardcodedMetadata : Lcom/kevlar/integrity/model/HardcodedMetadata; Hashing \u00b6 This hasn't been developed yet, but it may be possible to let kevlar know only the hash of your hardcoded data, and let it match directly on the runtime signatures and package names hashes. This would require multiple options of composite hash functions to be secure enough. It is not implemented. Initialization & Attestations \u00b6 You need to create a KevlarIntegrity instance (which is the way you will be requesting attestations), along with your desired parameters (either global, local or in your repository layer, if you are using MVVM/MVC). Once you have that, you just go ahead and call integrity.attestate() in a coroutine and your application running metadata will be checked, according to the provided parameters. IntegrityAttestation will be returned from the call (it's a sealed class), containing the checks which failed, if any. Note that we will be initializing KevlarIntegrity with custom scan settings, but you could leave it as default. In-Place \u00b6 This is the most concise (and complete) way to implement this package. InPlace.kt // com.kevlar.showcase val base64PackageName = \"\"\"Y29tLmtldmxhci5zaG93Y2FzZQ==\"\"\" . toByteArray ( Charsets . UTF_8 ) // J+nqXLfuIO8B2AmhkMYHGE4jDyw= val base64Signature = \"\"\"SitucVhMZnVJTzhCMkFtaGtNWUhHRTRqRHl3PQ==\"\"\" . toByteArray ( Charsets . UTF_8 ) val base64ObfuscatedHardcodedMetadata = HardcodedMetadata ( Base64 . decode ( base64PackageName , Base64 . DEFAULT ). toString ( Charsets . UTF_8 ), Base64 . decode ( base64Signature , Base64 . DEFAULT ). toString ( Charsets . UTF_8 ) ) val integrity = KevlarIntegrity ( base64ObfuscatedHardcodedMetadata ) { checks { signature () packageName () installer () debug () } } CoroutineScope ( Dispatchers . Default ). launch { // Attestation request when ( val attestation = integrity . attestate ( context )) { is IntegrityAttestation . Blank -> { // Pending attestation, no information yet. // Don't do anything. } is IntegrityAttestation . Clear -> { // Good to go. } is IntegrityAttestation . Failed -> { // One or more checks have failed. } } } This packs everything in one file. It is not excellent when writing a modern applications but it does its job. ViewModel + Repository + SharedFlow + DI with Hilt \u00b6 Activity: \u00b6 IntegrityActivity.kt @AndroidEntryPoint class IntegrityActivity : AppCompatActivity () { private val vm : ActivityViewModel by viewModels () override fun onCreate ( savedInstanceState : Bundle?) { super . onCreate ( savedInstanceState ) lifecycleScope . launch { lifecycle . repeatOnLifecycle ( Lifecycle . State . STARTED ) { vm . attestation . collectLatest { when ( it ) { is IntegrityAttestation . Blank -> { // Pending attestation, no information yet. // Don't do anything. } is IntegrityAttestation . Clear -> { // Good to go. } is IntegrityAttestation . Failed -> { // Pirate software detected. } } } } } CoroutineScope ( Dispatchers . Main ). launch { vm . requestAttestation () } } } View model: \u00b6 ActivityViewModel.kt @HiltViewModel class ActivityViewModel @Inject constructor ( private val integrityRepository : IntegrityRepository ) : ViewModel () { private val _attestation = MutableStateFlow ( KevlarIntegrity . blankAttestation ()) internal val attestation : SharedFlow < IntegrityAttestation > = _attestation . stateIn ( viewModelScope , SharingStarted . Eagerly , initialValue = KevlarIntegrity . blankAttestation () ) fun requestAttestation () { viewModelScope . launch { _attestation . value = integrityRepository . attestate () } } } Repository \u00b6 IntegrityRepository.kt class IntegrityRepository @Inject constructor ( @ApplicationContext val context : Context , @IoDispatcher val externalDispatcher : CoroutineDispatcher ) { /** * Base64 obfuscated * */ private val base64PackageName = \"\"\"Y29tLmtldmxhci5zaG93Y2FzZQ==\"\"\" . toByteArray ( Charsets . UTF_8 ) private val base64Signature = \"\"\"SitucVhMZnVJTzhCMkFtaGtNWUhHRTRqRHl3PQ==\"\"\" . toByteArray ( Charsets . UTF_8 ) private val base64ObfuscatedHardcodedMetadata = HardcodedMetadata ( Base64 . decode ( base64PackageName , Base64 . DEFAULT ). toString ( Charsets . UTF_8 ), Base64 . decode ( base64Signature , Base64 . DEFAULT ). toString ( Charsets . UTF_8 ) ) /** * Integrity package * */ private val integrity = KevlarIntegrity ( plaintextHardcodedMetadata ) { checks { signature () packageName () installer () debug () } } suspend fun attestate (): IntegrityAttestation = withContext ( externalDispatcher ) { integrity . attestate ( context ) } }","title":"Implementation"},{"location":"pages/modules/integrity/implementation/#implementation","text":"Implementing integrity requires, on top of a KevlarAntipiracy and the attestation infrastructure, a tiny bit of information about your application's metadata, which will be hardcoded inside it. This is necessary to provide kevlar a truth value to match the runtime values (which may have been tampered and altered) against. The obfuscation is necessary because we need to conceal the truth values, since they will be looked for by the attacker (software or human), and make it as hard as possible to automatically find and patch them. A working example for the integrity module can be found in the github repository under the :showcase module.","title":"Implementation"},{"location":"pages/modules/integrity/implementation/#dependency","text":"Gradle dependencies { implementation \"com.github.kevlar-kt:integrity:1.0.0\" } Kotlin DSL dependencies { implementation ( \"com.github.kevlar-kt:integrity:1.0.0\" ) } Maven <dependency> <groupId> com.github.kevlar-kt </groupId> <artifactId> integrity </artifactId> <version> 1.0.0 </version> <type> pom </type> </dependency>","title":"Dependency"},{"location":"pages/modules/integrity/implementation/#hardcoded-metadata","text":"The first step is getting the necessary metadata. You need the following: Your application package name ; Your application signature . They go right in a class which is required in order to initialize KevlarIntegrity . hardcoded_metadata.kt private val hardcodedMetadata = HardcodedMetadata ( packageName = \"com.kevlar.showcase\" , // showcase package name signature = \"K+wrXLluOI8B5LkisWQPE4jLew=\" // debug signature )","title":"Hardcoded metadata"},{"location":"pages/modules/integrity/implementation/#finding-metadata","text":"You already know the package name, and the signature can be extracted directly from kevlar with: KevlarIntegrity . obtainCurrentAppSignature ( context ) Grab that string value and save it along with your package name. Do not Maybe, just maybe, you may be tempted to so something like this: VERY_BAD_hardcoded_metadata.kt private val notAtAllHardcodedMetadata = HardcodedMetadata ( packageName = context . getPackageName (), signature = getRuntimeSignature () ) Refrain from coding this monstruosity. The sole purpose of HardcodedMetadata is hardcoding truth values inside your app. This little snippet single handedly kills the whole library (because obviously the runtime package name will match the runtime package name) and is like shooting yourself in the foot with a cannon. Don't.","title":"Finding metadata"},{"location":"pages/modules/integrity/implementation/#obfuscating-metadata","text":"The second step (optional but recommended) is obfuscating the metadata you just read, so that it is saved in an obfuscated form (in your bytecode, so that automatic tools can't find it), but passed to kevlar deobfuscated (so that we have the original truth values). There are a few ways to do it:","title":"Obfuscating metadata"},{"location":"pages/modules/integrity/implementation/#no-obfuscation-not-recommended","text":"You just save the values as they are and pass them in HardcodedMetadata unobfuscated_hardcoded_metadata.kt private const val packageName = \"\"\"com.kevlar.showcase\"\"\" private const val signature = \"\"\"J+nqXLfuIO8B2AmhkMYHGE4jDyw=\"\"\" private val hardcodedMetadata = HardcodedMetadata ( packageName , signature ) Bytecode The produced kotlin bytecode clearly exposes the raw values: 1 2 3 4 5 6 7 8 9 10 11 L1 ALOAD 0 NEW com/kevlar/integrity/model/HardcodedMetadata DUP L2 LDC \"com.kevlar.showcase\" L3 LDC \"J+nqXLfuIO8B2AmhkMYHGE4jDyw=\" L4 INVOKESPECIAL com/kevlar/integrity/model/HardcodedMetadata.<init> (Ljava/lang/String;Ljava/lang/String;)V PUTFIELD com/kevlar/showcase/data/repo/IntegrityRepository.hardcodedMetadata : Lcom/kevlar/integrity/model/HardcodedMetadata;","title":"No obfuscation (not recommended)"},{"location":"pages/modules/integrity/implementation/#base64-obfuscation","text":"You store the package name and signature values as Base64-encoded byte arrays, and they go through the Base64.decode() function when creating HardcodedMetadata . base64_obfuscated_hardcoded_metadata.kt private val packageName = \"\"\"Y29tLmtldmxhci5zaG93Y2FzZQ==\"\"\" . toByteArray ( Charsets . UTF_8 ) private val signature = \"\"\"SitucVhMZnVJTzhCMkFtaGtNWUhHRTRqRHl3PQ==\"\"\" . toByteArray ( Charsets . UTF_8 ) private val base64ObfuscatedHardcodedMetadata = HardcodedMetadata ( Base64 . decode ( packageName , Base64 . DEFAULT ). toString ( Charsets . UTF_8 ), Base64 . decode ( signature , Base64 . DEFAULT ). toString ( Charsets . UTF_8 ) ) Where Y29tLmtldmxhci5zaG93Y2FzZQ== is the base64 encoding of com.kevlar.showcase , and SitucVhMZnVJTzhCMkFtaGtNWUhHRTRqRHl3PQ== of J+nqXLfuIO8B2AmhkMYHGE4jDyw= . You can look them up online , grab them from your app or use openssl base64 in the terminal. Base64 flags & charset The flag field and charset don't necessarily need to be Base64.DEFAULT and UTF_8 . Even though they are the most popular, you may choose something else if you prefer, as long as you preserve consistency. Bytecode Here the metadata is hidden and not targetable with basic find-and-replace techniques 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 L6 ALOAD 0 LDC \"Y29tLmtldmxhci5zaG93Y2FzZQ==\" ASTORE 3 GETSTATIC kotlin/text/Charsets.UTF_8 : Ljava/nio/charset/Charset; ASTORE 4 L7 ALOAD 3 L8 ALOAD 4 INVOKEVIRTUAL java/lang/String.getBytes (Ljava/nio/charset/Charset;)[B DUP LDC \"(this as java.lang.String).getBytes(charset)\" INVOKESTATIC kotlin/jvm/internal/Intrinsics.checkNotNullExpressionValue (Ljava/lang/Object;Ljava/lang/String;)V L9 PUTFIELD com/kevlar/showcase/data/repo/IntegrityRepository.packageName : [B L10 ALOAD 0 LDC \"SitucVhMZnVJTzhCMkFtaGtNWUhHRTRqRHl3PQ==\" ASTORE 3 GETSTATIC kotlin/text/Charsets.UTF_8 : Ljava/nio/charset/Charset; ASTORE 4 L11 ALOAD 3 L12 ALOAD 4 INVOKEVIRTUAL java/lang/String.getBytes (Ljava/nio/charset/Charset;)[B DUP LDC \"(this as java.lang.String).getBytes(charset)\" INVOKESTATIC kotlin/jvm/internal/Intrinsics.checkNotNullExpressionValue (Ljava/lang/Object;Ljava/lang/String;)V L13 PUTFIELD com/kevlar/showcase/data/repo/IntegrityRepository.signature : [B L14 ALOAD 0 NEW com/kevlar/integrity/model/HardcodedMetadata DUP L15 ALOAD 0 GETFIELD com/kevlar/showcase/data/repo/IntegrityRepository.packageName : [B ICONST_0 INVOKESTATIC android/util/Base64.decode ([BI)[B DUP LDC \"Base64.decode(packageName, Base64.DEFAULT)\" INVOKESTATIC kotlin/jvm/internal/Intrinsics.checkNotNullExpressionValue (Ljava/lang/Object;Ljava/lang/String;)V ASTORE 3 GETSTATIC kotlin/text/Charsets.UTF_8 : Ljava/nio/charset/Charset; ASTORE 4 L16 NEW java/lang/String DUP ALOAD 3 ALOAD 4 INVOKESPECIAL java/lang/String.<init> ([BLjava/nio/charset/Charset;)V L17 L18 ALOAD 0 GETFIELD com/kevlar/showcase/data/repo/IntegrityRepository.signature : [B ICONST_0 INVOKESTATIC android/util/Base64.decode ([BI)[B DUP LDC \"Base64.decode(signature, Base64.DEFAULT)\" INVOKESTATIC kotlin/jvm/internal/Intrinsics.checkNotNullExpressionValue (Ljava/lang/Object;Ljava/lang/String;)V ASTORE 3 GETSTATIC kotlin/text/Charsets.UTF_8 : Ljava/nio/charset/Charset; ASTORE 4 L19 NEW java/lang/String DUP ALOAD 3 ALOAD 4 INVOKESPECIAL java/lang/String.<init> ([BLjava/nio/charset/Charset;)V L20 L21 INVOKESPECIAL com/kevlar/integrity/model/HardcodedMetadata.<init> (Ljava/lang/String;Ljava/lang/String;)V PUTFIELD com/kevlar/showcase/data/repo/IntegrityRepository.base64ObfuscatedHardcodedMetadata : Lcom/kevlar/integrity/model/HardcodedMetadata;","title":"Base64 obfuscation"},{"location":"pages/modules/integrity/implementation/#encryption-base64","text":"A better alternative is to encrypt the hardcoded metadata, store them in an encrypted form, and send them through a decryption function when creating HardcodedMetadata . encrypted_hardcoded_metadata.kt private val key256 = \"\"\"4t7w!z%C*F-JaNcRfUjXn2r5u8x/A?D\"\"\" private val packageName = \"\"\"s3wf/AOYtr9BEMVFrweeLnkmerryUykMA8O77S5tMlI=\"\"\" . toByteArray ( Charsets . UTF_8 ) private val signature = \"\"\"tqMJquO3D+EKx1rx4R7/qzmsuEgpp1bKwxXe9AeB/WU=\"\"\" . toByteArray ( Charsets . UTF_8 ) private val encryptedHardcodedMetadata = HardcodedMetadata ( EncryptionUtil . decrypt ( packageName , key256 ), EncryptionUtil . decrypt ( signature , key256 ) ) Where 7KAa2CFkhPQOUouDu32KZJLqOzGFbTTnJA3rGxMlAg4= is the encrypted value of com.kevlar.showcase , and +ylMx63kwFRmXKHQU0cbzyb8MJ1iiGW1g8+MjDRcS/o= of J+nqXLfuIO8B2AmhkMYHGE4jDyw= . This ensures that there is no possibility that an automatic attack picks up the string as a package name or signature, and trivial string substitutions or encodings like base64 won't give any information away (the ciphertext is encoded in base64). AES128 or AES256 is recommended as the encryption algorithm (it's a little overkill but it does the job). The ciphertext may also be stored as a byte array. Encryption utility This tiny class (from the showcase module in the repository) is a basic AES encryption/decryption utility. EncryptionUtil.kt import android.util.Base64 import javax.crypto.Cipher import javax.crypto.SecretKey import javax.crypto.spec.SecretKeySpec object EncryptionUtil { private const val algorithm = \"AES\" private const val transformation = \"AES/ECB/PKCS5Padding\" fun generateKey ( key : String ): SecretKey = SecretKeySpec ( key . toByteArray (), algorithm ) fun encrypt ( text : ByteArray , secret : SecretKey ): String { val cipher : Cipher = Cipher . getInstance ( transformation ). apply { init ( Cipher . ENCRYPT_MODE , secret ) } return Base64 . encodeToString ( cipher . doFinal ( text ), Base64 . NO_WRAP ) ?: \"\" } fun decrypt ( ciphertext : ByteArray , secret : SecretKey ): String { val cipher : Cipher = Cipher . getInstance ( transformation ). apply { init ( Cipher . DECRYPT_MODE , secret ) } return String ( cipher . doFinal ( Base64 . decode ( ciphertext , Base64 . NO_WRAP )), Charsets . UTF_8 ) } } Bytecode Here detecting and reconstructing the original package name automatically is basically impossible 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 L22 ALOAD 0 LDC \"4t7w!z%C*F-JaNcRfUjXn2r5u8x/A?Ds\" PUTFIELD com/kevlar/showcase/data/repo/IntegrityRepository.key256 : Ljava/lang/String; L23 ALOAD 0 LDC \"s3wf/AOYtr9BEMVFrweeLnkmerryUykMA8O77S5tMlI=\" ASTORE 3 GETSTATIC kotlin/text/Charsets.UTF_8 : Ljava/nio/charset/Charset; ASTORE 4 L24 ALOAD 3 L25 ALOAD 4 INVOKEVIRTUAL java/lang/String.getBytes (Ljava/nio/charset/Charset;)[B DUP LDC \"(this as java.lang.String).getBytes(charset)\" INVOKESTATIC kotlin/jvm/internal/Intrinsics.checkNotNullExpressionValue (Ljava/lang/Object;Ljava/lang/String;)V L26 PUTFIELD com/kevlar/showcase/data/repo/IntegrityRepository.encryptedPackageName : [B L27 ALOAD 0 LDC \"tqMJquO3D+EKx1rx4R7/qzmsuEgpp1bKwxXe9AeB/WU=\" ASTORE 3 GETSTATIC kotlin/text/Charsets.UTF_8 : Ljava/nio/charset/Charset; ASTORE 4 L28 ALOAD 3 L29 ALOAD 4 INVOKEVIRTUAL java/lang/String.getBytes (Ljava/nio/charset/Charset;)[B DUP LDC \"(this as java.lang.String).getBytes(charset)\" INVOKESTATIC kotlin/jvm/internal/Intrinsics.checkNotNullExpressionValue (Ljava/lang/Object;Ljava/lang/String;)V L30 PUTFIELD com/kevlar/showcase/data/repo/IntegrityRepository.encryptedSignature : [B L31 ALOAD 0 NEW com/kevlar/integrity/model/HardcodedMetadata DUP L32 GETSTATIC com/kevlar/showcase/util/EncryptionUtil.INSTANCE : Lcom/kevlar/showcase/util/EncryptionUtil; ALOAD 0 GETFIELD com/kevlar/showcase/data/repo/IntegrityRepository.encryptedPackageName : [B GETSTATIC com/kevlar/showcase/util/EncryptionUtil.INSTANCE : Lcom/kevlar/showcase/util/EncryptionUtil; ALOAD 0 GETFIELD com/kevlar/showcase/data/repo/IntegrityRepository.key256 : Ljava/lang/String; INVOKEVIRTUAL com/kevlar/showcase/util/EncryptionUtil.generateKey (Ljava/lang/String;)Ljavax/crypto/SecretKey; INVOKEVIRTUAL com/kevlar/showcase/util/EncryptionUtil.decrypt ([BLjavax/crypto/SecretKey;)Ljava/lang/String; L33 GETSTATIC com/kevlar/showcase/util/EncryptionUtil.INSTANCE : Lcom/kevlar/showcase/util/EncryptionUtil; ALOAD 0 GETFIELD com/kevlar/showcase/data/repo/IntegrityRepository.encryptedSignature : [B GETSTATIC com/kevlar/showcase/util/EncryptionUtil.INSTANCE : Lcom/kevlar/showcase/util/EncryptionUtil; ALOAD 0 GETFIELD com/kevlar/showcase/data/repo/IntegrityRepository.key256 : Ljava/lang/String; INVOKEVIRTUAL com/kevlar/showcase/util/EncryptionUtil.generateKey (Ljava/lang/String;)Ljavax/crypto/SecretKey; INVOKEVIRTUAL com/kevlar/showcase/util/EncryptionUtil.decrypt ([BLjavax/crypto/SecretKey;)Ljava/lang/String; L34 INVOKESPECIAL com/kevlar/integrity/model/HardcodedMetadata.<init> (Ljava/lang/String;Ljava/lang/String;)V PUTFIELD com/kevlar/showcase/data/repo/IntegrityRepository.aes256EncryptedHardcodedMetadata : Lcom/kevlar/integrity/model/HardcodedMetadata;","title":"Encryption (+base64)"},{"location":"pages/modules/integrity/implementation/#hashing","text":"This hasn't been developed yet, but it may be possible to let kevlar know only the hash of your hardcoded data, and let it match directly on the runtime signatures and package names hashes. This would require multiple options of composite hash functions to be secure enough. It is not implemented.","title":"Hashing"},{"location":"pages/modules/integrity/implementation/#initialization-attestations","text":"You need to create a KevlarIntegrity instance (which is the way you will be requesting attestations), along with your desired parameters (either global, local or in your repository layer, if you are using MVVM/MVC). Once you have that, you just go ahead and call integrity.attestate() in a coroutine and your application running metadata will be checked, according to the provided parameters. IntegrityAttestation will be returned from the call (it's a sealed class), containing the checks which failed, if any. Note that we will be initializing KevlarIntegrity with custom scan settings, but you could leave it as default.","title":"Initialization &amp; Attestations"},{"location":"pages/modules/integrity/implementation/#in-place","text":"This is the most concise (and complete) way to implement this package. InPlace.kt // com.kevlar.showcase val base64PackageName = \"\"\"Y29tLmtldmxhci5zaG93Y2FzZQ==\"\"\" . toByteArray ( Charsets . UTF_8 ) // J+nqXLfuIO8B2AmhkMYHGE4jDyw= val base64Signature = \"\"\"SitucVhMZnVJTzhCMkFtaGtNWUhHRTRqRHl3PQ==\"\"\" . toByteArray ( Charsets . UTF_8 ) val base64ObfuscatedHardcodedMetadata = HardcodedMetadata ( Base64 . decode ( base64PackageName , Base64 . DEFAULT ). toString ( Charsets . UTF_8 ), Base64 . decode ( base64Signature , Base64 . DEFAULT ). toString ( Charsets . UTF_8 ) ) val integrity = KevlarIntegrity ( base64ObfuscatedHardcodedMetadata ) { checks { signature () packageName () installer () debug () } } CoroutineScope ( Dispatchers . Default ). launch { // Attestation request when ( val attestation = integrity . attestate ( context )) { is IntegrityAttestation . Blank -> { // Pending attestation, no information yet. // Don't do anything. } is IntegrityAttestation . Clear -> { // Good to go. } is IntegrityAttestation . Failed -> { // One or more checks have failed. } } } This packs everything in one file. It is not excellent when writing a modern applications but it does its job.","title":"In-Place"},{"location":"pages/modules/integrity/implementation/#viewmodel-repository-sharedflow-di-with-hilt","text":"","title":"ViewModel + Repository + SharedFlow + DI with Hilt"},{"location":"pages/modules/integrity/implementation/#activity","text":"IntegrityActivity.kt @AndroidEntryPoint class IntegrityActivity : AppCompatActivity () { private val vm : ActivityViewModel by viewModels () override fun onCreate ( savedInstanceState : Bundle?) { super . onCreate ( savedInstanceState ) lifecycleScope . launch { lifecycle . repeatOnLifecycle ( Lifecycle . State . STARTED ) { vm . attestation . collectLatest { when ( it ) { is IntegrityAttestation . Blank -> { // Pending attestation, no information yet. // Don't do anything. } is IntegrityAttestation . Clear -> { // Good to go. } is IntegrityAttestation . Failed -> { // Pirate software detected. } } } } } CoroutineScope ( Dispatchers . Main ). launch { vm . requestAttestation () } } }","title":"Activity:"},{"location":"pages/modules/integrity/implementation/#view-model","text":"ActivityViewModel.kt @HiltViewModel class ActivityViewModel @Inject constructor ( private val integrityRepository : IntegrityRepository ) : ViewModel () { private val _attestation = MutableStateFlow ( KevlarIntegrity . blankAttestation ()) internal val attestation : SharedFlow < IntegrityAttestation > = _attestation . stateIn ( viewModelScope , SharingStarted . Eagerly , initialValue = KevlarIntegrity . blankAttestation () ) fun requestAttestation () { viewModelScope . launch { _attestation . value = integrityRepository . attestate () } } }","title":"View model:"},{"location":"pages/modules/integrity/implementation/#repository","text":"IntegrityRepository.kt class IntegrityRepository @Inject constructor ( @ApplicationContext val context : Context , @IoDispatcher val externalDispatcher : CoroutineDispatcher ) { /** * Base64 obfuscated * */ private val base64PackageName = \"\"\"Y29tLmtldmxhci5zaG93Y2FzZQ==\"\"\" . toByteArray ( Charsets . UTF_8 ) private val base64Signature = \"\"\"SitucVhMZnVJTzhCMkFtaGtNWUhHRTRqRHl3PQ==\"\"\" . toByteArray ( Charsets . UTF_8 ) private val base64ObfuscatedHardcodedMetadata = HardcodedMetadata ( Base64 . decode ( base64PackageName , Base64 . DEFAULT ). toString ( Charsets . UTF_8 ), Base64 . decode ( base64Signature , Base64 . DEFAULT ). toString ( Charsets . UTF_8 ) ) /** * Integrity package * */ private val integrity = KevlarIntegrity ( plaintextHardcodedMetadata ) { checks { signature () packageName () installer () debug () } } suspend fun attestate (): IntegrityAttestation = withContext ( externalDispatcher ) { integrity . attestate ( context ) } }","title":"Repository"},{"location":"pages/modules/integrity/integrity/","text":"Integrity \u00b6 graph LR I[Inizialization] -.Settings..-> K{KevlarIntegrity}; DB([Hardcoded & Obfuscated Metadata]) === K AR1[Attestation Requests] --> K K --> |Clear| P[Passed]; K --> |Failed| NP[Not Passed]; P --> A[IntegrityAssestation] NP --> A The integrity package contains tools for the detection of tampering attempts against your app. It requires a bit of effort to implement (you need to find, code and obfuscate your app metadata, all the instructions are in implementation ), but once you have it runs quickly and works extremely well. It is capable of detecting: Signature mismatches (the running app's signature and the hardcoded signature are different) Package name mismatches (the running app's package name and the hardcoded package name are different) Debuggable flag (the running app is debuggable, which should never happen for production apps) Disallowed Installers (the running app has been installed through a disallowed package installer) Purpose of the integrity package You want to use this package if you need to give your app a layer of protection against tampering attacks (see anatomy for more details). Enabling just a few checks and implementing basic obfuscation will make your app harder to crack. Warning This package is the best defense against automatic and/or unskilled attacks. If implemented well, it will kill off most of them To implement this, you initialize KevlarIntegrity and provide your desired settings (which influence what is to be checked and what not). Then you can submit attestation requests (which will be executed according to your settings). Empty & default settings The settings on integrity are additive. If you leave a blank DSL, nothing will be detected, because no checks will be run, because the settings are empty. If you do not pass a DSL at all, the default settings will be used (they scan for signature, package name, and debug). Custom private val integrity = KevlarIntegrity { checks { signature () packageName () debug () installer () } } Empty private val integrity = KevlarIntegrity { checks { } } Default private val integrity = KevlarIntegrity () Attestation process overview \u00b6 When you require an attestation (through integrity.attestate(context) ), kevlar executes the following operations: Depending on what integrity checks you selected, the appropriate battery of tests for those targets is initialized and run; The results are collected, processed, filtered, and returned. There is only one type of attestation that can be produced. The attestation is returned in IntegrityAttestation (it is a sealed class), which depending on the detection status can be of three types: Blank : This is a non-processed status. It should not be interpreted, as it does not carry any meaning about the attestation result. It is not to be interpreted as Clear ; Clear : The attestation has passed. There is nothing to report. This means that no system modification/status has triggered the detection from the battery of tests that have been executed, in compliance with the given check parameters; Failed : The attestation has not passed. Integrity or tampering issues have been detected. You can check which check has failed (which inconsistency has been found between the hardcoded and runtime values) in the attestation result. Warning Blank is completely different from Clear (or Failed ). It means that the software is initialized but that nothing has been done yet. Do not mix them up. Use cases \u00b6 This is a pretty typical scenario for any application where it is critical to preserve self-integrity and run unmodified code.","title":"Overview"},{"location":"pages/modules/integrity/integrity/#integrity","text":"graph LR I[Inizialization] -.Settings..-> K{KevlarIntegrity}; DB([Hardcoded & Obfuscated Metadata]) === K AR1[Attestation Requests] --> K K --> |Clear| P[Passed]; K --> |Failed| NP[Not Passed]; P --> A[IntegrityAssestation] NP --> A The integrity package contains tools for the detection of tampering attempts against your app. It requires a bit of effort to implement (you need to find, code and obfuscate your app metadata, all the instructions are in implementation ), but once you have it runs quickly and works extremely well. It is capable of detecting: Signature mismatches (the running app's signature and the hardcoded signature are different) Package name mismatches (the running app's package name and the hardcoded package name are different) Debuggable flag (the running app is debuggable, which should never happen for production apps) Disallowed Installers (the running app has been installed through a disallowed package installer) Purpose of the integrity package You want to use this package if you need to give your app a layer of protection against tampering attacks (see anatomy for more details). Enabling just a few checks and implementing basic obfuscation will make your app harder to crack. Warning This package is the best defense against automatic and/or unskilled attacks. If implemented well, it will kill off most of them To implement this, you initialize KevlarIntegrity and provide your desired settings (which influence what is to be checked and what not). Then you can submit attestation requests (which will be executed according to your settings). Empty & default settings The settings on integrity are additive. If you leave a blank DSL, nothing will be detected, because no checks will be run, because the settings are empty. If you do not pass a DSL at all, the default settings will be used (they scan for signature, package name, and debug). Custom private val integrity = KevlarIntegrity { checks { signature () packageName () debug () installer () } } Empty private val integrity = KevlarIntegrity { checks { } } Default private val integrity = KevlarIntegrity ()","title":"Integrity"},{"location":"pages/modules/integrity/integrity/#attestation-process-overview","text":"When you require an attestation (through integrity.attestate(context) ), kevlar executes the following operations: Depending on what integrity checks you selected, the appropriate battery of tests for those targets is initialized and run; The results are collected, processed, filtered, and returned. There is only one type of attestation that can be produced. The attestation is returned in IntegrityAttestation (it is a sealed class), which depending on the detection status can be of three types: Blank : This is a non-processed status. It should not be interpreted, as it does not carry any meaning about the attestation result. It is not to be interpreted as Clear ; Clear : The attestation has passed. There is nothing to report. This means that no system modification/status has triggered the detection from the battery of tests that have been executed, in compliance with the given check parameters; Failed : The attestation has not passed. Integrity or tampering issues have been detected. You can check which check has failed (which inconsistency has been found between the hardcoded and runtime values) in the attestation result. Warning Blank is completely different from Clear (or Failed ). It means that the software is initialized but that nothing has been done yet. Do not mix them up.","title":"Attestation process overview"},{"location":"pages/modules/integrity/integrity/#use-cases","text":"This is a pretty typical scenario for any application where it is critical to preserve self-integrity and run unmodified code.","title":"Use cases"},{"location":"pages/modules/rooting/implementation/","text":"Implementation \u00b6 A working example for the rooting module can be found in the github repository under the :showcase module. Dependency \u00b6 Gradle dependencies { implementation \"com.github.kevlar-kt:rooting:1.0.0\" } Kotlin DSL dependencies { implementation ( \"com.github.kevlar-kt:rooting:1.0.0\" ) } Maven <dependency> <groupId> com.github.kevlar-kt </groupId> <artifactId> rooting </artifactId> <version> 1.0.0 </version> <type> pom </type> </dependency> Initialization & Attestations \u00b6 You need to create a KevlarRooting instance (which is the way you will be requesting attestations), along with your desired parameters (either global, local or in your repository layer, if you are using MVVM/MVC). The rooting package has 2 attestations: TargetRootingAttestation and StatusRootingAttestation . Depending on what your security requirements impose, you may need to run one or both checks. You go ahead and request whichever attestation(s) you need. The will produce two different sealed classes (since the results will be different in case of failure, the attestations will contain different data). We go ahead and create a working single-attestation example (for system modifications aka targets). For two attestations refer to the sample code in the :showcase module of the github repository. In-Place \u00b6 This is the most concise way to implement rooting. InPlace.kt val rooting = KevlarRooting { targets { root () busybox () } } CoroutineScope ( Dispatchers . Default ). launch { // Attestation request when ( val attestation = rooting . attestateTargets ( context )) { is TargetRootingAttestation . Blank -> { // Pending attestation, no information yet. // Don't do anything. } is TargetRootingAttestation . Clear -> { // Good to go. } is TargetRootingAttestation . Failed -> { // System modifications detected. } } } ViewModel + Repository + SharedFlow + DI with Hilt \u00b6 Activity: \u00b6 RootingActivity.kt @AndroidEntryPoint class RootingActivity : AppCompatActivity () { private val vm : ActivityViewModel by viewModels () override fun onCreate ( savedInstanceState : Bundle?) { super . onCreate ( savedInstanceState ) lifecycleScope . launch { lifecycle . repeatOnLifecycle ( Lifecycle . State . STARTED ) { vm . taregtsAttestation . collectLatest { when ( it ) { is TargetRootingAttestation . Blank -> { // Pending attestation, no information yet. // Don't do anything. } is TargetRootingAttestation . Clear -> { // Good to go. } is TargetRootingAttestation . Failed -> { // Pirate software detected. } } } } } CoroutineScope ( Dispatchers . Main ). launch { vm . requestTargetsAttestation () } } } View model: \u00b6 ActivityViewModel.kt @HiltViewModel class ActivityViewModel @Inject constructor ( private val securityRepository : RootingRepository ) : ViewModel () { private val _targetAttestationState = MutableStateFlow ( KevlarRooting . blankTargetAttestation ()) val targetAttestation : SharedFlow < TargetRootingAttestation > = _rootAttestationState . stateIn ( viewModelScope , SharingStarted . Eagerly , initialValue = KevlarRooting . blankTargetAttestation () ) fun requestTargetsAttestation () { viewModelScope . launch { _rootAttestationState . value = rootingRepository . attestateRoot () } } } Repository \u00b6 RootingRepository.kt class RootingRepository @Inject constructor ( @ApplicationContext val context : Context , @IoDispatcher val externalDispatcher : CoroutineDispatcher ) { private val rooting = KevlarRooting { targets { root () busybox () } } suspend fun attestateRoot (): TargetRootingAttestation = withContext ( externalDispatcher ) { rooting . attestateTargets ( context ) } }","title":"Implementation"},{"location":"pages/modules/rooting/implementation/#implementation","text":"A working example for the rooting module can be found in the github repository under the :showcase module.","title":"Implementation"},{"location":"pages/modules/rooting/implementation/#dependency","text":"Gradle dependencies { implementation \"com.github.kevlar-kt:rooting:1.0.0\" } Kotlin DSL dependencies { implementation ( \"com.github.kevlar-kt:rooting:1.0.0\" ) } Maven <dependency> <groupId> com.github.kevlar-kt </groupId> <artifactId> rooting </artifactId> <version> 1.0.0 </version> <type> pom </type> </dependency>","title":"Dependency"},{"location":"pages/modules/rooting/implementation/#initialization-attestations","text":"You need to create a KevlarRooting instance (which is the way you will be requesting attestations), along with your desired parameters (either global, local or in your repository layer, if you are using MVVM/MVC). The rooting package has 2 attestations: TargetRootingAttestation and StatusRootingAttestation . Depending on what your security requirements impose, you may need to run one or both checks. You go ahead and request whichever attestation(s) you need. The will produce two different sealed classes (since the results will be different in case of failure, the attestations will contain different data). We go ahead and create a working single-attestation example (for system modifications aka targets). For two attestations refer to the sample code in the :showcase module of the github repository.","title":"Initialization &amp; Attestations"},{"location":"pages/modules/rooting/implementation/#in-place","text":"This is the most concise way to implement rooting. InPlace.kt val rooting = KevlarRooting { targets { root () busybox () } } CoroutineScope ( Dispatchers . Default ). launch { // Attestation request when ( val attestation = rooting . attestateTargets ( context )) { is TargetRootingAttestation . Blank -> { // Pending attestation, no information yet. // Don't do anything. } is TargetRootingAttestation . Clear -> { // Good to go. } is TargetRootingAttestation . Failed -> { // System modifications detected. } } }","title":"In-Place"},{"location":"pages/modules/rooting/implementation/#viewmodel-repository-sharedflow-di-with-hilt","text":"","title":"ViewModel + Repository + SharedFlow + DI with Hilt"},{"location":"pages/modules/rooting/implementation/#activity","text":"RootingActivity.kt @AndroidEntryPoint class RootingActivity : AppCompatActivity () { private val vm : ActivityViewModel by viewModels () override fun onCreate ( savedInstanceState : Bundle?) { super . onCreate ( savedInstanceState ) lifecycleScope . launch { lifecycle . repeatOnLifecycle ( Lifecycle . State . STARTED ) { vm . taregtsAttestation . collectLatest { when ( it ) { is TargetRootingAttestation . Blank -> { // Pending attestation, no information yet. // Don't do anything. } is TargetRootingAttestation . Clear -> { // Good to go. } is TargetRootingAttestation . Failed -> { // Pirate software detected. } } } } } CoroutineScope ( Dispatchers . Main ). launch { vm . requestTargetsAttestation () } } }","title":"Activity:"},{"location":"pages/modules/rooting/implementation/#view-model","text":"ActivityViewModel.kt @HiltViewModel class ActivityViewModel @Inject constructor ( private val securityRepository : RootingRepository ) : ViewModel () { private val _targetAttestationState = MutableStateFlow ( KevlarRooting . blankTargetAttestation ()) val targetAttestation : SharedFlow < TargetRootingAttestation > = _rootAttestationState . stateIn ( viewModelScope , SharingStarted . Eagerly , initialValue = KevlarRooting . blankTargetAttestation () ) fun requestTargetsAttestation () { viewModelScope . launch { _rootAttestationState . value = rootingRepository . attestateRoot () } } }","title":"View model:"},{"location":"pages/modules/rooting/implementation/#repository","text":"RootingRepository.kt class RootingRepository @Inject constructor ( @ApplicationContext val context : Context , @IoDispatcher val externalDispatcher : CoroutineDispatcher ) { private val rooting = KevlarRooting { targets { root () busybox () } } suspend fun attestateRoot (): TargetRootingAttestation = withContext ( externalDispatcher ) { rooting . attestateTargets ( context ) } }","title":"Repository"},{"location":"pages/modules/rooting/internals/","text":"Internals \u00b6 Detecting system targets and statuses is easy and difficult at the same time. There are conditions which are really simple and only require a binary check to determine. There are other kind of features which are harder to identify and classify reliably, given how different they get across versions of android, versions of the feature and settings of the feature. Binary dumping \u00b6 For a lot of features we can check if the associated binary executable is present. If it is, then we consider that the feature is present as well. This check can be ran at different permission levels with different results. Custom checking \u00b6 Xposed framework requires a specific check on a system file to determine whether it is active or not. Notes \u00b6 The rooting module relies on libsu for shell command execution. This may be a debatable choice, but it is one of the only well-written libraries and it works both efficiently and reliably. The alternative would have been implementing a custom shell execution mechanism, which is not hard to do but it is hard to do well .","title":"Internals"},{"location":"pages/modules/rooting/internals/#internals","text":"Detecting system targets and statuses is easy and difficult at the same time. There are conditions which are really simple and only require a binary check to determine. There are other kind of features which are harder to identify and classify reliably, given how different they get across versions of android, versions of the feature and settings of the feature.","title":"Internals"},{"location":"pages/modules/rooting/internals/#binary-dumping","text":"For a lot of features we can check if the associated binary executable is present. If it is, then we consider that the feature is present as well. This check can be ran at different permission levels with different results.","title":"Binary dumping"},{"location":"pages/modules/rooting/internals/#custom-checking","text":"Xposed framework requires a specific check on a system file to determine whether it is active or not.","title":"Custom checking"},{"location":"pages/modules/rooting/internals/#notes","text":"The rooting module relies on libsu for shell command execution. This may be a debatable choice, but it is one of the only well-written libraries and it works both efficiently and reliably. The alternative would have been implementing a custom shell execution mechanism, which is not hard to do but it is hard to do well .","title":"Notes"},{"location":"pages/modules/rooting/rooting/","text":"Rooting \u00b6 graph LR I[Inizialization] -.Settings..-> K{KevlarRooting}; DB([Android OS]) === K AR1[Target Attestation Requests] --> K AR2[Status Attestation Requests] --> K K --> |Clear| P[Passed]; K --> |Failed| NP[Not Passed]; P --> A1[TargetAssestation] NP --> A1 P --> A2[StatusAttestation] NP --> A2 The rooting package contains tools for the detection of system modifications that may be active on the device running your app. Once configured with settings, the package can quickly run different batteries of tests on the operative system (through shell commands) to check if the target modifications are present on the device. It produces two different kinds of attestations: one searching for system modification and one for system conditions. It is capable of detecting the following system modifications (through the targets attestation) root access; magisk installations (not hidden); busybox binaries; toybox binaries; Xposed framework. And the following system conditions (through the status attestation) emulator execution; test keys; SELinux status. Depending on what you need to check, you may choose one or run both. Purpose of the rooting package You may want to use this package if you care about the system-wide security status, or if you consider that your application running on rooted/modified devices is a security risk. Notation In the rooting package, the words \"target\" and \"status\" are used loosely, but they actually have a special meaning. Targets means system modification. Something that may be installed (and detectable) over the operating system. It is a kind of add-on, a custom software component. Status means a system condition. Something that is itself part of the operating system out of the box, and whose status we want to check. To implement this, you initialize KevlarRooting and provide your desired settings (which influence what is to be checked and what not). Then you can submit attestation requests of whichever kind you prefer (which will be executed according to your settings). Empty & default settings The settings on rooting are additive. If you leave a blank DSL, nothing will be detected, because no checks will be run, because the settings are empty. If you do not pass a DSL at all, the default settings will be used (they only scan for root access and emulator + SELinux). Custom private val rooting = KevlarRooting { targets { root () magisk () busybox () } status { emulator () SELinux { flagPermissive () } } allowRootCheck () } Empty private val rooting = KevlarRooting { targets {} status {} } Default private val rooting = KevlarRooting () Attestation process overview \u00b6 This package can produce two different kinds of attestations: a TargetAssestation and a StatusAttestation . When you require an attestation, kevlar performs the following operations: for the targets attestation (through rooting.attestateTargets(context) ): Depending on what system modification you selected, the appropriate battery of tests for that system modification is initialized and run; The results are collected, processed, filtered, and returned. for the status attestation (through rooting.attestateStatus() ): Depending on what system condition you selected, the appropriate check for that system status flag is initialized and ran; The results are collected, processed, filtered, and returned. The attestation is returned either in TargetRootingAttestation or StatusRootingAttestation (both are sealed classes), which depending on the detection status can be of three types (with different fields): Blank : This is a non-processed status. It should not be interpreted, as it does not carry any meaning about the attestation result. It is not to be interpreted as Clear ; Clear : The attestation has passed. There is nothing to report. This means that no system modification/status has triggered the detection from the battery of tests that have been executed, in compliance with the given scan parameters; Failed : The attestation has not passed. A target/status has been detected. You can read which one has tripped the detection in the attestation result. Warning Blank is completely different from Clear (or Failed ). It means that the software is initialized but that nothing has been done yet. Do not mix them up. Use cases \u00b6 This is a pretty typical scenario for any banking/financial application, game, or software managing sensitive resources (files, records, data)","title":"Overview"},{"location":"pages/modules/rooting/rooting/#rooting","text":"graph LR I[Inizialization] -.Settings..-> K{KevlarRooting}; DB([Android OS]) === K AR1[Target Attestation Requests] --> K AR2[Status Attestation Requests] --> K K --> |Clear| P[Passed]; K --> |Failed| NP[Not Passed]; P --> A1[TargetAssestation] NP --> A1 P --> A2[StatusAttestation] NP --> A2 The rooting package contains tools for the detection of system modifications that may be active on the device running your app. Once configured with settings, the package can quickly run different batteries of tests on the operative system (through shell commands) to check if the target modifications are present on the device. It produces two different kinds of attestations: one searching for system modification and one for system conditions. It is capable of detecting the following system modifications (through the targets attestation) root access; magisk installations (not hidden); busybox binaries; toybox binaries; Xposed framework. And the following system conditions (through the status attestation) emulator execution; test keys; SELinux status. Depending on what you need to check, you may choose one or run both. Purpose of the rooting package You may want to use this package if you care about the system-wide security status, or if you consider that your application running on rooted/modified devices is a security risk. Notation In the rooting package, the words \"target\" and \"status\" are used loosely, but they actually have a special meaning. Targets means system modification. Something that may be installed (and detectable) over the operating system. It is a kind of add-on, a custom software component. Status means a system condition. Something that is itself part of the operating system out of the box, and whose status we want to check. To implement this, you initialize KevlarRooting and provide your desired settings (which influence what is to be checked and what not). Then you can submit attestation requests of whichever kind you prefer (which will be executed according to your settings). Empty & default settings The settings on rooting are additive. If you leave a blank DSL, nothing will be detected, because no checks will be run, because the settings are empty. If you do not pass a DSL at all, the default settings will be used (they only scan for root access and emulator + SELinux). Custom private val rooting = KevlarRooting { targets { root () magisk () busybox () } status { emulator () SELinux { flagPermissive () } } allowRootCheck () } Empty private val rooting = KevlarRooting { targets {} status {} } Default private val rooting = KevlarRooting ()","title":"Rooting"},{"location":"pages/modules/rooting/rooting/#attestation-process-overview","text":"This package can produce two different kinds of attestations: a TargetAssestation and a StatusAttestation . When you require an attestation, kevlar performs the following operations: for the targets attestation (through rooting.attestateTargets(context) ): Depending on what system modification you selected, the appropriate battery of tests for that system modification is initialized and run; The results are collected, processed, filtered, and returned. for the status attestation (through rooting.attestateStatus() ): Depending on what system condition you selected, the appropriate check for that system status flag is initialized and ran; The results are collected, processed, filtered, and returned. The attestation is returned either in TargetRootingAttestation or StatusRootingAttestation (both are sealed classes), which depending on the detection status can be of three types (with different fields): Blank : This is a non-processed status. It should not be interpreted, as it does not carry any meaning about the attestation result. It is not to be interpreted as Clear ; Clear : The attestation has passed. There is nothing to report. This means that no system modification/status has triggered the detection from the battery of tests that have been executed, in compliance with the given scan parameters; Failed : The attestation has not passed. A target/status has been detected. You can read which one has tripped the detection in the attestation result. Warning Blank is completely different from Clear (or Failed ). It means that the software is initialized but that nothing has been done yet. Do not mix them up.","title":"Attestation process overview"},{"location":"pages/modules/rooting/rooting/#use-cases","text":"This is a pretty typical scenario for any banking/financial application, game, or software managing sensitive resources (files, records, data)","title":"Use cases"},{"location":"pages/overview/anatomy_of_attacks/","text":"Anatomy of an attack against an Android app \u00b6 This is a general informal introductory text detailing the most well-known and used attack techniques against Android apps. We will start with the most basic and gradually build up to the most skilled ones. Attack techniques are presented in order of time taken to employ (weaponize) them successfully against an unguarded application. While being different in shape and form, all the attacks follow the same basic principle: you have a target application that we want to attack (with a target in mind. Usually bypassing certain mechanisms, overriding rules, or adding/removing features), which is decompiled, then analyzed; its bytecode is modified according to the target of the attack (a payload is inserted, safety checks are removed, code is altered or replaced), then it all gets recompiled, repackaged and possibly resigned into an apk file which is installed and run. Popular tools for this are apktool on desktop and ApkEditor on mobile. Warning This page tends to be a little subjective because there is not a science studying those things and I am not an expert in this field, so take everything with a grain of salt. 0: Automatic patching \u00b6 This is by far the most common since (once the engine is ready) it is done completely automatically, without any human intervention or brainpower. There are various pirate apps able to perform this to some extent (most notably Lucky Patcher ). They all more or less all use a string-matching engine to perform a (very sophisticated) pattern \"find-and-replace\" over your application bytecode. This is done to achieve what the target of the attack is: it may be removing advertising from your app, changing signature verification, disabling or enabling some features, inhibiting security mechanisms, or purchasing protection. The target determines the pattern used to do the dirty work. Then the app is rebuilt and it's done. It is the lowest form of attack since the software itself does not know what it is doing exactly but follows a general rule set. But this does not render it any less dangerous: if your software is unprepared, you will fall for this. Against this level of attack you can employ all kevlar's arsenal with the antipiracy and integrity packages. Kevlar has more or less been built and designed to fight this kind of attack, by performing safety checks over your package metadata and giving you runtime warnings for the presence of malicious software which is interfering or directing your app. The nice thing (for us developers) is that the automation of the attack is very hard to do, even on a basic level, and putting up barriers for this is comparatively quick. 1: Unskilled custom attacks \u00b6 This tends to be a less likely kind of attack because an actual human brain is looking at your decompiled bytecode and trying to figure out what needs to be done to achieve its goal. When I say unskilled I mean done by amateurs without in-depth knowledge of the techniques involved. They will essentially be manually searching through your bytecode and looking for code pieces that they recognize and want to remove/edit/expand. This is usually done by searching a determinate resource, which is referenced somewhere in the code, finding that code, and trying to change its logic. Bytecode note Bytecode is the raw language that the JVM executes. In Android, everything shifts from JVM to ART but it's the same thing. There are reconstruction utilities, which will try to take the bytecode and un-compile it to grab the original source code. Most likely that is what an attacker might want to be looking at. Obfuscation A machine does not care whether your code is obfuscated. A human brain does. You should always heavily shrink, optimize and obfuscate your production code (i.e. using ProGuard on release builds) to make it harder for attackers to make sense of it. 2: Root access enabled attacks \u00b6 When a device is rooted, there are a whole lot of new variables to take into account when looking at security, since the operating system itself is compromised and will obey the user commands. It's not like you can do a lot if you are running on that system, but what you can do is preemptively disable some application features to protect them from modification, if applicable and necessary according to your security standards. That's what a lot of games or bank software do since they are targeted by custom attacks that can, with the help of root access, alter the application behavior without having to recompile it (on the fly). Either they shut down completely or they inhibit come functionality. Casing point every Supercell game. Data editing An easy way to crack many (not well secured) applications is by editing the files (XML SharedPreferences or SQLite databases) on which they store data. I've seen countless \"is_pro\" strings inside SharedPreferences or XML/JSON settings where you can enable paid features without the app checking it, and it only takes a few bytes flips to have complete access to anything you want. That specific attack can be made harder by encrypting and obfuscating your application preference strings. 3: Professional custom attack \u00b6 There is very little to say here: if someone knows what he/she is doing, they are going to strip away every bit of self-checking and security controls you put in place, and they will implement whatever target they have. While obfuscation helps, security through obscurity should not even be an option, and other techniques will make it harder to decipher what your code does, eventually, a determined mind will find a way to do what it wants to, and there is nothing you can do about it. After all, if you can modify your code to write software that adheres to the attack targets, so can they. Cracked software distribution Every commercial app I wrote that surpassed about 100k downloads (TurboUnfollow and Androoster) has been custom patched and redistributed on the internet. This happens regularly and, while being sad, is a reminder that perfect security protection does not exist. This happens because you do not have control over the device your user is running your app on. It stops being your control when the bytes are transferred and installed as a package on the device, then they are binary data open for modifications and hacks. The only efficient way to mitigate this is by regulating what you have control over. Server-side access and APIs, data validation, in-house or professional security checks, and so on, will limit the control your app has over its working and puts it in your secure hands. Extra concepts \u00b6 Conditional Consistency \u00b6 It is a little bit meta to talk about your application code being modified, either by recompilation or root attacks, since you can not know how it will be changed. This process can introduce all sorts of discrepancies and inconsistencies in the newly created software. Coding software with conditional consistency is a practice where you insert security checks that can tell when the software is itself not genuine or modified. And while ALL those checks can theoretically be stripped away or disabled, this makes it harder to find them all and avoid detection. This is a bit overkill for android apps, but more advanced software uses those concepts to add extra nets of protection.","title":"Anatomy of an Attack"},{"location":"pages/overview/anatomy_of_attacks/#anatomy-of-an-attack-against-an-android-app","text":"This is a general informal introductory text detailing the most well-known and used attack techniques against Android apps. We will start with the most basic and gradually build up to the most skilled ones. Attack techniques are presented in order of time taken to employ (weaponize) them successfully against an unguarded application. While being different in shape and form, all the attacks follow the same basic principle: you have a target application that we want to attack (with a target in mind. Usually bypassing certain mechanisms, overriding rules, or adding/removing features), which is decompiled, then analyzed; its bytecode is modified according to the target of the attack (a payload is inserted, safety checks are removed, code is altered or replaced), then it all gets recompiled, repackaged and possibly resigned into an apk file which is installed and run. Popular tools for this are apktool on desktop and ApkEditor on mobile. Warning This page tends to be a little subjective because there is not a science studying those things and I am not an expert in this field, so take everything with a grain of salt.","title":"Anatomy of an attack against an Android app"},{"location":"pages/overview/anatomy_of_attacks/#0-automatic-patching","text":"This is by far the most common since (once the engine is ready) it is done completely automatically, without any human intervention or brainpower. There are various pirate apps able to perform this to some extent (most notably Lucky Patcher ). They all more or less all use a string-matching engine to perform a (very sophisticated) pattern \"find-and-replace\" over your application bytecode. This is done to achieve what the target of the attack is: it may be removing advertising from your app, changing signature verification, disabling or enabling some features, inhibiting security mechanisms, or purchasing protection. The target determines the pattern used to do the dirty work. Then the app is rebuilt and it's done. It is the lowest form of attack since the software itself does not know what it is doing exactly but follows a general rule set. But this does not render it any less dangerous: if your software is unprepared, you will fall for this. Against this level of attack you can employ all kevlar's arsenal with the antipiracy and integrity packages. Kevlar has more or less been built and designed to fight this kind of attack, by performing safety checks over your package metadata and giving you runtime warnings for the presence of malicious software which is interfering or directing your app. The nice thing (for us developers) is that the automation of the attack is very hard to do, even on a basic level, and putting up barriers for this is comparatively quick.","title":"0: Automatic patching"},{"location":"pages/overview/anatomy_of_attacks/#1-unskilled-custom-attacks","text":"This tends to be a less likely kind of attack because an actual human brain is looking at your decompiled bytecode and trying to figure out what needs to be done to achieve its goal. When I say unskilled I mean done by amateurs without in-depth knowledge of the techniques involved. They will essentially be manually searching through your bytecode and looking for code pieces that they recognize and want to remove/edit/expand. This is usually done by searching a determinate resource, which is referenced somewhere in the code, finding that code, and trying to change its logic. Bytecode note Bytecode is the raw language that the JVM executes. In Android, everything shifts from JVM to ART but it's the same thing. There are reconstruction utilities, which will try to take the bytecode and un-compile it to grab the original source code. Most likely that is what an attacker might want to be looking at. Obfuscation A machine does not care whether your code is obfuscated. A human brain does. You should always heavily shrink, optimize and obfuscate your production code (i.e. using ProGuard on release builds) to make it harder for attackers to make sense of it.","title":"1: Unskilled custom attacks"},{"location":"pages/overview/anatomy_of_attacks/#2-root-access-enabled-attacks","text":"When a device is rooted, there are a whole lot of new variables to take into account when looking at security, since the operating system itself is compromised and will obey the user commands. It's not like you can do a lot if you are running on that system, but what you can do is preemptively disable some application features to protect them from modification, if applicable and necessary according to your security standards. That's what a lot of games or bank software do since they are targeted by custom attacks that can, with the help of root access, alter the application behavior without having to recompile it (on the fly). Either they shut down completely or they inhibit come functionality. Casing point every Supercell game. Data editing An easy way to crack many (not well secured) applications is by editing the files (XML SharedPreferences or SQLite databases) on which they store data. I've seen countless \"is_pro\" strings inside SharedPreferences or XML/JSON settings where you can enable paid features without the app checking it, and it only takes a few bytes flips to have complete access to anything you want. That specific attack can be made harder by encrypting and obfuscating your application preference strings.","title":"2: Root access enabled attacks"},{"location":"pages/overview/anatomy_of_attacks/#3-professional-custom-attack","text":"There is very little to say here: if someone knows what he/she is doing, they are going to strip away every bit of self-checking and security controls you put in place, and they will implement whatever target they have. While obfuscation helps, security through obscurity should not even be an option, and other techniques will make it harder to decipher what your code does, eventually, a determined mind will find a way to do what it wants to, and there is nothing you can do about it. After all, if you can modify your code to write software that adheres to the attack targets, so can they. Cracked software distribution Every commercial app I wrote that surpassed about 100k downloads (TurboUnfollow and Androoster) has been custom patched and redistributed on the internet. This happens regularly and, while being sad, is a reminder that perfect security protection does not exist. This happens because you do not have control over the device your user is running your app on. It stops being your control when the bytes are transferred and installed as a package on the device, then they are binary data open for modifications and hacks. The only efficient way to mitigate this is by regulating what you have control over. Server-side access and APIs, data validation, in-house or professional security checks, and so on, will limit the control your app has over its working and puts it in your secure hands.","title":"3: Professional custom attack"},{"location":"pages/overview/anatomy_of_attacks/#extra-concepts","text":"","title":"Extra concepts"},{"location":"pages/overview/anatomy_of_attacks/#conditional-consistency","text":"It is a little bit meta to talk about your application code being modified, either by recompilation or root attacks, since you can not know how it will be changed. This process can introduce all sorts of discrepancies and inconsistencies in the newly created software. Coding software with conditional consistency is a practice where you insert security checks that can tell when the software is itself not genuine or modified. And while ALL those checks can theoretically be stripped away or disabled, this makes it harder to find them all and avoid detection. This is a bit overkill for android apps, but more advanced software uses those concepts to add extra nets of protection.","title":"Conditional Consistency"},{"location":"pages/overview/choosing/","text":"Choosing packages \u00b6 Kevlar's flexible infrastructure allows for very granular and efficient configuration. it is divided in 3 packages, each targeting a specific scope (system-wise security, user-wise security and app-wise security), and within each package you have fully customizable attestation checks. This is done to help you reach your desired security level and only bundle in your app what you need.","title":"Choosing packages"},{"location":"pages/overview/choosing/#choosing-packages","text":"Kevlar's flexible infrastructure allows for very granular and efficient configuration. it is divided in 3 packages, each targeting a specific scope (system-wise security, user-wise security and app-wise security), and within each package you have fully customizable attestation checks. This is done to help you reach your desired security level and only bundle in your app what you need.","title":"Choosing packages"},{"location":"pages/overview/dependencies_integration/","text":"Dependencies and Integration \u00b6 Publishing \u00b6 All the dependencies are published on MavenCentral. Make sure to have it included in your reporitories block in the top level build.gradle file. repositories { mavenCentral () } Project Requirements \u00b6 Java 8+ is required; compileOptions { sourceCompatibility JavaVersion . VERSION_1_8 targetCompatibility JavaVersion . VERSION_1_8 } minSdk 19+ is required. Antipiracy \u00b6 Gradle dependencies { implementation \"com.github.kevlar-kt:antipiracy:1.0.0\" } Kotlin DSL dependencies { implementation ( \"com.github.kevlar-kt:antipiracy:1.0.0\" ) } Maven <dependency> <groupId> com.github.kevlar-kt </groupId> <artifactId> antipiracy </artifactId> <version> 1.0.0 </version> <type> pom </type> </dependency> Rooting \u00b6 Gradle dependencies { implementation \"com.github.kevlar-kt:rooting:1.0.0\" } Kotlin DSL dependencies { implementation ( \"com.github.kevlar-kt:rooting:1.0.0\" ) } Maven <dependency> <groupId> com.github.kevlar-kt </groupId> <artifactId> rooting </artifactId> <version> 1.0.0 </version> <type> pom </type> </dependency> Integrity \u00b6 Gradle dependencies { implementation \"com.github.kevlar-kt:integrity:1.0.0\" } Kotlin DSL dependencies { implementation ( \"com.github.kevlar-kt:integrity:1.0.0\" ) } Maven <dependency> <groupId> com.github.kevlar-kt </groupId> <artifactId> integrity </artifactId> <version> 1.0.0 </version> <type> pom </type> </dependency>","title":"Dependencies & Integration"},{"location":"pages/overview/dependencies_integration/#dependencies-and-integration","text":"","title":"Dependencies and Integration"},{"location":"pages/overview/dependencies_integration/#publishing","text":"All the dependencies are published on MavenCentral. Make sure to have it included in your reporitories block in the top level build.gradle file. repositories { mavenCentral () }","title":"Publishing"},{"location":"pages/overview/dependencies_integration/#project-requirements","text":"Java 8+ is required; compileOptions { sourceCompatibility JavaVersion . VERSION_1_8 targetCompatibility JavaVersion . VERSION_1_8 } minSdk 19+ is required.","title":"Project Requirements"},{"location":"pages/overview/dependencies_integration/#antipiracy","text":"Gradle dependencies { implementation \"com.github.kevlar-kt:antipiracy:1.0.0\" } Kotlin DSL dependencies { implementation ( \"com.github.kevlar-kt:antipiracy:1.0.0\" ) } Maven <dependency> <groupId> com.github.kevlar-kt </groupId> <artifactId> antipiracy </artifactId> <version> 1.0.0 </version> <type> pom </type> </dependency>","title":"Antipiracy"},{"location":"pages/overview/dependencies_integration/#rooting","text":"Gradle dependencies { implementation \"com.github.kevlar-kt:rooting:1.0.0\" } Kotlin DSL dependencies { implementation ( \"com.github.kevlar-kt:rooting:1.0.0\" ) } Maven <dependency> <groupId> com.github.kevlar-kt </groupId> <artifactId> rooting </artifactId> <version> 1.0.0 </version> <type> pom </type> </dependency>","title":"Rooting"},{"location":"pages/overview/dependencies_integration/#integrity","text":"Gradle dependencies { implementation \"com.github.kevlar-kt:integrity:1.0.0\" } Kotlin DSL dependencies { implementation ( \"com.github.kevlar-kt:integrity:1.0.0\" ) } Maven <dependency> <groupId> com.github.kevlar-kt </groupId> <artifactId> integrity </artifactId> <version> 1.0.0 </version> <type> pom </type> </dependency>","title":"Integrity"},{"location":"pages/overview/material/","text":"Technical Material \u00b6 Prevention material, checking & tamper detection \u00b6 https://www.airpair.com/android/posts/adding-tampering-detection-to-your-android-app https://en.wikipedia.org/wiki/Security_through_obscurity ; https://darvincitech.wordpress.com/2020/03/01/yet-another-tamper-detection-in-android/ ; https://medium.com/avi-parshan-studios/protecting-your-android-app-against-reverse-engineering-and-tampering-a727768b2e9e ; https://medium.com/@mplacona/tampering-detection-in-android-d213998ecc4f https://developer.android.com/training/safetynet/index.html ; https://www.indusface.com/learning/how-to-implement-root-detection-in-android-applications/ ; https://stackoverflow.com/questions/33850864/how-to-verify-purchase-for-android-app-in-server-side-google-play-in-app-billin . Server-Side checks \u00b6 https://developer.android.com/training/safetynet ; https://medium.com/@lahirumaramba/protecting-your-own-backend-services-with-firebase-app-check-1daaef229f32 . Attack vectors \u00b6 https://mobile-security.gitbook.io/mobile-security-testing-guide/android-testing-guide/0x05c-reverse-engineering-and-tampering . Code \u00b6 https://gist.github.com/scottyab/b849701972d57cf9562e ; https://github.com/mukeshsolanki/Android-Tamper-Detector ; https://stackoverflow.com/questions/50126775/detecting-code-tampering-in-apk ; https://stackoverflow.com/questions/13445598/lucky-patcher-how-can-i-protect-from-it .","title":"Technical Material"},{"location":"pages/overview/material/#technical-material","text":"","title":"Technical Material"},{"location":"pages/overview/material/#prevention-material-checking-tamper-detection","text":"https://www.airpair.com/android/posts/adding-tampering-detection-to-your-android-app https://en.wikipedia.org/wiki/Security_through_obscurity ; https://darvincitech.wordpress.com/2020/03/01/yet-another-tamper-detection-in-android/ ; https://medium.com/avi-parshan-studios/protecting-your-android-app-against-reverse-engineering-and-tampering-a727768b2e9e ; https://medium.com/@mplacona/tampering-detection-in-android-d213998ecc4f https://developer.android.com/training/safetynet/index.html ; https://www.indusface.com/learning/how-to-implement-root-detection-in-android-applications/ ; https://stackoverflow.com/questions/33850864/how-to-verify-purchase-for-android-app-in-server-side-google-play-in-app-billin .","title":"Prevention material, checking &amp; tamper detection"},{"location":"pages/overview/material/#server-side-checks","text":"https://developer.android.com/training/safetynet ; https://medium.com/@lahirumaramba/protecting-your-own-backend-services-with-firebase-app-check-1daaef229f32 .","title":"Server-Side checks"},{"location":"pages/overview/material/#attack-vectors","text":"https://mobile-security.gitbook.io/mobile-security-testing-guide/android-testing-guide/0x05c-reverse-engineering-and-tampering .","title":"Attack vectors"},{"location":"pages/overview/material/#code","text":"https://gist.github.com/scottyab/b849701972d57cf9562e ; https://github.com/mukeshsolanki/Android-Tamper-Detector ; https://stackoverflow.com/questions/50126775/detecting-code-tampering-in-apk ; https://stackoverflow.com/questions/13445598/lucky-patcher-how-can-i-protect-from-it .","title":"Code"},{"location":"pages/overview/philosophy/","text":"Philosophy \u00b6 What does it do? \u00b6 It warns your application when a specific security requirement is not met by the system, userspace, or app. Each kevlar package shares a common structure: they all produce an attestation regarding (an aspect of) the security state of the Android device running your app. The idea behind it is being able to quickly capture every meaningful security information regarding a certain field, with a certain accuracy. These modules provide an array of detection methods that can be used to ensure the app is running in its proper intended environment Note A general rule of thumb is to include only what you need, and nothing more. There is little to no point in using antipiracy protection if you do not have sensitive in-app material and/or transactions you want to protect, same with rooting or integrity. Does it always work? \u00b6 No. It does most of the time, but there is no guarantee of a 100% success rate. What kevlar provides is an accurate heuristic, which is relatively cheap to run and provides a valuable assessment within an acceptable margin of error. If you require a higher success rate, you will need much more sophisticated and ad-hoc levels of protection. Kevlar catches what can be caught in a reasonable amount of time, space, and lines of code. In a similar fashion as the pareto distribution , to slightly improve the detection rate you will need much more complicated software, much more time, or much more space. And for the record, any software trying to claim that it achieves 100% detection is factually wrong (there is a theorem in computability and decidability theory stating that you can not do that). Naming decisions \u00b6 Kevlar is a material used in bulletproof vests. And besides starting with a k (which at this point appears to be an implicit requirement for any cool kotlin library), it perfectly embodies its philosophy. A soldier in the field is a target for the enemy force. Soldiers shoot bullets at each other and who is hit die. Wearing a bulletproof vest is a way of reducing the chance of you dying. It makes practical sense: it is a light material, not difficult to carry around, and it provides life-saving protection. Kevlar is lightweight body armor for your app, to check and shield against incoming hostile attacks. If you are being targeted with high precision sniper fire, a javelin anti-tank launcher, or a Royal Naval vessel in the immediate vicinity launches a missile strike on your location, even if you are James Bond there is little left to do. If your app is reverse engineered, the security bits stripped away and then recompiled (more details in Anatomy of an Attack ), you are going to be vulnerable, and there is nothing you can do about it. But while being imperfect, it manages to be efficient and deflect the majority of automated and non-specialized patches and attacks, which is the majority of what you will (hopefully) be exposed to. Another similarity is about what you want to protect. People don't usually wear a bulletproof vest at home [redacted U.S. joke] . It doesn't make much sense, since the attack is not likely. The same thing goes with putting kevlar on a calculator app. You can. It does not make much sense if it does not have valuable commercial features or APIs (On WolframAlpha it does). Success rates Given the success rate of this library against patches versus the success rate of kevlar vests against bullets, this could have easily been called full body armor, but that didn't sound as cool. Security Through Obscurity \u00b6 Kevlar does not rely on security through obscurity . Its source code, logic, and dataset is public. Since the purpose of kevlar is to be a generic barrier to defeat automated and unskilled attacks, going to the extent of obfuscating code that, if ever reverse engineered, would just be stripped away, seems like a fruitless idea. It would be necessary to introduce such mechanisms only if hostile software would try to automatically target specific kevlar components. While I doubt this would ever happen, introducing basic internal safety checks or compile-time randomized obfuscation would surely make that kind of detection unfeasible. Accuracy and Precision \u00b6 It is fairly accurate (since there are just a few checks to run to check the security status, we are pretty confident that most of the time we will get the information right), and has excellent precision (since checks are deterministic and predictable, given an initial condition, the result will always be the same, accurate or not) (See accuracy vs precision ) History \u00b6 This project has been alive since 2017 (by the former name billing-protector) to counteract automatic attacks against android applications (AAAAA). The original project was mainly aimed at protecting apps from Lucky Patcher, an infamous patch tool used to modify (recompile with automated code replacement and modification, more details in security/attacks) apps to bypass IAP (In-app purchases), and essentially crack them. It has evolved in a more general and flexible","title":"Philosophy"},{"location":"pages/overview/philosophy/#philosophy","text":"","title":"Philosophy"},{"location":"pages/overview/philosophy/#what-does-it-do","text":"It warns your application when a specific security requirement is not met by the system, userspace, or app. Each kevlar package shares a common structure: they all produce an attestation regarding (an aspect of) the security state of the Android device running your app. The idea behind it is being able to quickly capture every meaningful security information regarding a certain field, with a certain accuracy. These modules provide an array of detection methods that can be used to ensure the app is running in its proper intended environment Note A general rule of thumb is to include only what you need, and nothing more. There is little to no point in using antipiracy protection if you do not have sensitive in-app material and/or transactions you want to protect, same with rooting or integrity.","title":"What does it do?"},{"location":"pages/overview/philosophy/#does-it-always-work","text":"No. It does most of the time, but there is no guarantee of a 100% success rate. What kevlar provides is an accurate heuristic, which is relatively cheap to run and provides a valuable assessment within an acceptable margin of error. If you require a higher success rate, you will need much more sophisticated and ad-hoc levels of protection. Kevlar catches what can be caught in a reasonable amount of time, space, and lines of code. In a similar fashion as the pareto distribution , to slightly improve the detection rate you will need much more complicated software, much more time, or much more space. And for the record, any software trying to claim that it achieves 100% detection is factually wrong (there is a theorem in computability and decidability theory stating that you can not do that).","title":"Does it always work?"},{"location":"pages/overview/philosophy/#naming-decisions","text":"Kevlar is a material used in bulletproof vests. And besides starting with a k (which at this point appears to be an implicit requirement for any cool kotlin library), it perfectly embodies its philosophy. A soldier in the field is a target for the enemy force. Soldiers shoot bullets at each other and who is hit die. Wearing a bulletproof vest is a way of reducing the chance of you dying. It makes practical sense: it is a light material, not difficult to carry around, and it provides life-saving protection. Kevlar is lightweight body armor for your app, to check and shield against incoming hostile attacks. If you are being targeted with high precision sniper fire, a javelin anti-tank launcher, or a Royal Naval vessel in the immediate vicinity launches a missile strike on your location, even if you are James Bond there is little left to do. If your app is reverse engineered, the security bits stripped away and then recompiled (more details in Anatomy of an Attack ), you are going to be vulnerable, and there is nothing you can do about it. But while being imperfect, it manages to be efficient and deflect the majority of automated and non-specialized patches and attacks, which is the majority of what you will (hopefully) be exposed to. Another similarity is about what you want to protect. People don't usually wear a bulletproof vest at home [redacted U.S. joke] . It doesn't make much sense, since the attack is not likely. The same thing goes with putting kevlar on a calculator app. You can. It does not make much sense if it does not have valuable commercial features or APIs (On WolframAlpha it does). Success rates Given the success rate of this library against patches versus the success rate of kevlar vests against bullets, this could have easily been called full body armor, but that didn't sound as cool.","title":"Naming decisions"},{"location":"pages/overview/philosophy/#security-through-obscurity","text":"Kevlar does not rely on security through obscurity . Its source code, logic, and dataset is public. Since the purpose of kevlar is to be a generic barrier to defeat automated and unskilled attacks, going to the extent of obfuscating code that, if ever reverse engineered, would just be stripped away, seems like a fruitless idea. It would be necessary to introduce such mechanisms only if hostile software would try to automatically target specific kevlar components. While I doubt this would ever happen, introducing basic internal safety checks or compile-time randomized obfuscation would surely make that kind of detection unfeasible.","title":"Security Through Obscurity"},{"location":"pages/overview/philosophy/#accuracy-and-precision","text":"It is fairly accurate (since there are just a few checks to run to check the security status, we are pretty confident that most of the time we will get the information right), and has excellent precision (since checks are deterministic and predictable, given an initial condition, the result will always be the same, accurate or not) (See accuracy vs precision )","title":"Accuracy and Precision"},{"location":"pages/overview/philosophy/#history","text":"This project has been alive since 2017 (by the former name billing-protector) to counteract automatic attacks against android applications (AAAAA). The original project was mainly aimed at protecting apps from Lucky Patcher, an infamous patch tool used to modify (recompile with automated code replacement and modification, more details in security/attacks) apps to bypass IAP (In-app purchases), and essentially crack them. It has evolved in a more general and flexible","title":"History"}]}