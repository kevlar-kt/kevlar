{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Kevlar","text":""},{"location":"#abstract","title":"Abstract","text":"<p>Kevlar is a security toolkit (library) for Android apps. It is divided in 3 packages (antipiracy, rooting and integrity), each containing specific tooling and components.</p> <p>Its purpose is to be an auditing tool, used to inspect the security environment on Android devices.</p> <p>A security environment is the security state of a device, which can be probed with the different packages kevlar provides.</p> <p>Each package focuses on a specific security environment area:</p> <ul> <li><code>antipiracy</code> detects the presence of pirate software installed on the device (user-wise security);</li> <li><code>rooting</code> detects the presence of root access, custom binaries, and abnormal OS status (system-wise security);</li> <li><code>integrity</code> detects certain types of tampering attempts your app may have been targeted with (app-wise security).</li> </ul> <p>Kevlar is intended to be used any time it is deemed necessary to determine whether the device your app is running on can be regarded as secure, according to your policies and security requirements.</p>"},{"location":"#security-environment","title":"Security Environment","text":"<p>The security environment is the status of the device. This is subdivided into system-wise security (system modifications, rooting, custom binaries, custom ROMs, emulator, SELinux), user-wise security (pirate stores and pirate apps), and app-wise security (tampering, recompiling, changed signature &amp; metadata)</p>"},{"location":"#flexibility","title":"Flexibility","text":"<p>Kevlar does not automatically detect a \"standard\" unsafe environment and gives a 0/1 answer. The kind of environment that is acceptable for your app to run in can be configured in each package individually.</p> <p>You may be indifferent to some things (e.g. root detection) and very sensitive about others (e.g. app tampering &amp; piracy detection). You can customize the set of checks the library executes in each package. Once you define your constraints, kevlar modules will operate accordingly.</p> <p>If you don't explicitly instruct kevlar to check for a feature, then that feature will not be reported, regardless of its presence (or absence) on the device.</p>"},{"location":"#design","title":"Design","text":"<p>Each kevlar package contains custom implementations for what it has to scan for, but they all share the same overall structure, to make it easy to work with. Once you learn how to use a package, then you can transfer that knowledge to the other ones.</p> <pre><code>graph LR\n  I[Inizialization] -.Settings..-&gt; K{Kevlar};\n  AREQ[Attestation Requests] --&gt; K\n  K --&gt; |Clear| P[Passed];\n  K --&gt; |Failed| NP[Not Passed];\n  P --&gt; ARES[Attestation Result]\n  NP --&gt; ARES</code></pre> <p>The founding idea is a flow of attestations. You initialize the package passing to it your settings (what you want to check for). Then you can go ahead and start requesting attestations. An attestation can either be Clear (passed) or Failed (non passed), according to your detection settings.</p> <p>There may be one or more types of attestation you can request, and you can choose what you want by requesting different ones, to enforce granular control and run efficiently.</p> <p>Under the hood, each package will call its implementations and run those checks against the operating system/current app, but you'll eventually get an <code>Attestation</code> back, so your only job is to check whether it is clear or not.</p> <p>This makes security declarative: you express your constraints and requirements once while configuring kevlar, which will then take care of - when asked -  producing a report (attestation) for your specific configuration, telling you what was found. And finally you can analyze this report and act accordingly, repeating the process as many times as needed.</p>"},{"location":"#use-cases","title":"Use Cases","text":"<p>Common use cases for security environment checks are applications managing sensitive resources, such as in-app purchases and subscriptions, valuable server-side resources or APIs, financial transactions, and anything that has a value that gets managed through your app/client.</p> <p>Ideally, you should request an attestation whenever your client wants to verify the status of the security environment before proceeding with the high-value action.</p> <p>Kevlar is a sort of guard statement for those actions, which should decrease the probability of an attacker successfully breaking your application's high-value transaction.</p>"},{"location":"#accuracy","title":"Accuracy","text":"<p>This tool is meant to be an approximate form of environment analysis and estimation. It covers a large number of attack vectors and does a good job at it.</p> <p>This does not mean that it is unbreakable. You can find more details in philosophy, but essentially it is a level 0 protection that can be removed by manually reverse engineering your app.</p> <p>This doesn't render it useless, it is very efficient in doing what it is designed to do: protecting against automated and unskilled attacks, which will most certainly be the vast majority of what your app will ever be put through.</p>"},{"location":"#additions-alternatives","title":"Additions &amp; Alternatives","text":"<p>Kevlar resembles what may look like an in-house protection system. It is open source, flexible and rich of features.</p> <p>For stricter scenarios where higher fidelity and accuracy are required, you should be using something more specific (and radically different).</p> <ul> <li>Play Integrity &amp; SafetyNet from Google;</li> <li>AppCheck from Firebase;</li> <li>ProGuard and DexGuard from GuardSquare.</li> </ul>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the Apache License, Version 2.0. Please refer to the <code>LICENSE.md</code> file inside the Github repository for the full text.</p>"},{"location":"pages/modules/antipiracy/antipiracy/","title":"Antipiracy","text":"<pre><code>graph LR\n  I[Inizialization] -.Settings..-&gt; K{KevlarAntipiracy};\n  DB[(Dataset)] === K\n  AREQ[Attestation Requests] --&gt; K\n  K --&gt; |Clear| P[Passed];\n  K --&gt; |Failed| NP[Not Passed];\n  P --&gt; ARES[AntipiracyAttestation]\n  NP --&gt; ARES</code></pre> <p>The antipiracy package contains tools for the detection of different categories of pirate software that may be installed and running on target devices. </p> <p>At its core, this package runs a battery of tests against all the installed applications to check for potential active pirate software, which depending on your policies may be a security environment issue.  It then compiles the results into an attestation (it can either be uninitialized, clear, or failed) which is returned to your app, where you can check what has been found and act accordingly.</p> <p>Purpose of the <code>antipiracy</code> package</p> <p>You may want to use this package if you consider that executing your app alongside pirate software which may be interfering/bypassing your code/protections is a security environment issue.</p> <p>Tampering and System protection</p> <p>The <code>antipiracy</code> package by itself does not do any kind of signature/tampering check (for that, refer to integrity package) or system wide verification (rooting). It just tells you whether software that may be trying/have already interfered/bypassed your protection mechanisms is installed or not.</p> <p>To implement this, you initialize <code>KevlarAntipiracy</code> and provide your desired settings (which influence what is to be detected and what not). Then you can submit attestation requests (which will be executed according to your settings).</p> <p>Each attestation request will cause Kevlar to grab the package list, run the appropriate checks and return an attestation.</p> <p>The settings you provide influence what will be included in the attestation.</p>"},{"location":"pages/modules/antipiracy/antipiracy/#attestation-process-overview","title":"Attestation process overview","text":"<p>When you require an attestation (through <code>antipiracy.attestate(context)</code>), kevlar executes the following operations:</p> <ol> <li>The installed package list is queried from the <code>PackageManager</code>. Make sure to have the right permissions to do that, since from Android 11 you need to add queries in your app's manifest, see the implement page;</li> <li>The test battery is initialized (to match your scan parameters) and ran on all packages, against the precompiled dataset onboard the library;</li> <li>The results are collected, processed, filtered, and returned in an <code>AntipiracyAttestation</code>.</li> </ol> <p>There is only one type of attestation that can be produced.</p> <p>The attestation is returned in <code>AntipiracyAttestation</code> (sealed class), which depending on the detection status can be of three types:</p> <ul> <li><code>Blank</code>: This is a non-processed status. It should not be interpreted, as it does not carry any meaning about the attestation result. It is not to be interpreted as <code>Clear</code>;</li> <li><code>Clear</code>: The attestation has passed. There is nothing to report. This means that no installed software has triggered the detection from the battery of tests that have been executed, in compliance with the given scan parameters;</li> <li><code>Failed</code>: The attestation has not passed. Pirated software has been detected. You can read which software has tripped the detection in the attestation result. The action you were about to do may be compromised, and you should not proceed.</li> </ul> <p>Warning</p> <p><code>Blank</code> is completely different from <code>Clear</code> (or <code>Failed</code>). It means that the software is initialized but that nothing has been done yet. Do not mix them up.</p>"},{"location":"pages/modules/antipiracy/antipiracy/#performance","title":"Performance","text":"<p>Package detection and testing make use of coroutines to run scan operations in parallel for each package, to minimize the time taken to run through all packages.</p> <p>Most of the checks consist of some type of string analysis (characters &amp; regex matching and abstract alphabet inference, more details in detection), which have pretty decent running times while being precise and reliable tools.</p> <p>Scan settings are taken into account intelligently to analyze and run the battery of tests over all packages in one single pass, regardless of how many checks are to be performed, and to execute the single package battery test in parallel.</p> <p>Timing</p> <p>The full attestation process takes from start to finish \u2248 75-200ms for my devices and emulators (assuming the full app list is returned, which it won't for Android 11+ [which is actually good news for performance, since the time taken for computing the whole attestation is linearly proportional to the number of applications returned by <code>PackageManager</code>]). It is mainly influenced by the processing power of the device, the number of apps installed, and your scan configuration.</p> <p>It is decently fast, given that it is intended to be run quickly in the background before business-critical transactions (e.g. when the user clicks \"purchase\", we first check that the device is clean and then actually contact Google Play to initiate the high-value transaction).</p>"},{"location":"pages/modules/antipiracy/antipiracy/#configuring-kevlarantipiracy","title":"Configuring <code>KevlarAntipiracy</code>","text":"<p>The antipiracy module is easy to configure, since it works automatically: you just have to choose which search criteria is used.</p> <p>You may choose to configure the antipiracy module manually (using the dedicated DSL, more flexibility), or just using one of the default configurations.</p> Default Configurations<pre><code>private val antipiracy = KevlarAntipiracy.Defaults.Full()\n</code></pre> Manual DSL<pre><code>private val antipiracy = KevlarAntipiracy {\n    scan {\n        pirate()\n        collateral()\n    }\n}\n</code></pre> <p>You can find more information about each individual item in the reference page.</p> <p>The settings are additive. If you leave a blank DSL, nothing will be detected, because no checks will be run, because the settings are empty.</p> Empty<pre><code>private val antipiracy = KevlarAntipiracy {\n    scan {}\n}\n</code></pre>"},{"location":"pages/modules/antipiracy/database/","title":"Database","text":"<p>Kevlar comes pre-packaged with definitions for the most common pirate software.</p> <p>A brief summary is reported in the following table:</p> <ul> <li><code>Software</code> is the common name of the given pirate software;</li> <li><code>Internal Code</code> is what kevlar uses to reference and report a specific software;</li> <li><code>Type</code> defines whether the given software is a pirate store or pirate app;</li> <li><code>Most Common Package</code> gives a probable package name for out in the wild pirate software. Usually pirate software have multiple (often numerous) package names, which are not reported in the table (but are obviously implemented in the library);</li> <li><code>Range</code> defines which battery of tests is available against a given package. <code>H</code> is heuristic detection (package metadata string matching), <code>A</code> is alphabetical analysis and <code>C</code> are collateral tests.</li> </ul> Software Internal Code Type Most Common Package Range Action Launcher Patcher ACTION_LAUNCHER_PATCHER <code>App</code> zone.jasi2169.uretpatcher <code>H</code> AC Market AC_MARKET <code>Store</code> ac.market.store <code>H</code> AGK App Killer AGK <code>App</code> com.aag.killer <code>H</code> All In One Downloader AIOD <code>Store</code> com.allinone.free <code>H</code> App Cake APP_CAKE <code>Store</code> com.appcake <code>H</code> App Sara APP_SARA <code>App</code> com.appsara.app <code>H</code> Aptoide APTOIDE <code>Store</code> cm.aptoide.pt <code>H</code> Black Mart BLACK_MART <code>Store</code> org.blackmart.market <code>H</code> Content Guard Disabler CGD <code>App</code> com.oneminusone.disablecontentguard <code>H</code> Creeplays Patcher CREEPLAYS_PATCHER <code>App</code> org.creeplays.hack <code>H</code> Cree Hack CREE_HACK <code>App</code> apps.zhasik007.hack <code>H</code> Freedom FREEDOM <code>App</code> jase.freedom <code>H</code> Game Hacker GAME_HACKER <code>App</code> org.sbtools.gamehack <code>H</code> Game Killer Cheats GAME_KILLER <code>App</code> com.killerapp.gamekiller <code>H</code> Get Apk GET_APK <code>Store</code> com.repodroid.app <code>H</code> Get Jar GET_JAR <code>Store</code> com.getjar.reward <code>H</code> Happymod HAPPYMOD <code>Store</code> happygames.io <code>H</code> Leo Playcards LEO_PLAYCARDS <code>App</code> com.leo.playcard <code>H</code> Lucky Patcher LUCKY_PATCHER <code>App</code> good luck <code>H</code>, <code>A</code>,<code>C</code> Mobilism MOBILISM <code>Store</code> org.mobilism.android <code>H</code> Mobogenie MOB_GENIE <code>Store</code> com.mobogenie <code>H</code> 1Mobile ONE_MOBILE <code>Store</code> me.onemobile.android <code>H</code> Slide Me SLIDE_ME <code>Store</code> com.slideme.sam.manager <code>H</code> Uret Patcher URET_PATCHER <code>App</code> zone.jasi2169.uretpatcher <code>H</code> XModGames XMG <code>App</code> com.xmodgame <code>H</code> Z Market Z_MARKET <code>Store</code> com.zmapp <code>H</code>"},{"location":"pages/modules/antipiracy/detection/","title":"Detection Techniques","text":"<p>This page details the detection techniques (aka tricks) employed in Kevlar Antipiracy.</p> <p>It should be stated that all checks are run against the local dataset (what kevlar thinks are pirate apps &amp; stores, a summary of that is in database), which is hardcoded in the library and therefore in your shipped software.</p> <p>Obfuscation complexity</p> <p>Writing good self-obfuscating software is hard.  There are a few ways, but essentially you need an installer package that carries the payload and an algorithm to insert the actual software in a randomized stub. If you do it well enough, there is no way to easily characterize your package and becomes more difficult (if not borderline unfeasible) to detect automatically. MagiskHide did this exceptionally well, to the point that it is almost useless to try to achieve fast detection. It can be done switching to more aggressive detection techniques, which kinda defeats the purpose of kevlar.</p>"},{"location":"pages/modules/antipiracy/detection/#string-matching","title":"String matching","text":"<p>This is the most basic yet efficient scanning tool.  Running a basic string match against some package parameters does miracles for detection, since most non-super-sneaky pirate software has a fixed package name, a fixed app label, a fixed class name, or all three.</p> <p>If kevlar catches even one of those, then the software is detected and will be reported in the attestation.</p> <p>It doesn't even need to be a full string match really, most of the time you need a partial (containment) match to detect something. </p> <p>This is very useful (and implemented) against prefix/postfix switching.</p>"},{"location":"pages/modules/antipiracy/detection/#regex-matching","title":"Regex matching","text":"<p>Same as above, but with regex. You can have more elaborate patterns or filters, since some packages distribute the same builds under different package names, thinking they are doing something clever.</p>"},{"location":"pages/modules/antipiracy/detection/#abstract-alphabet-inference","title":"Abstract Alphabet Inference","text":"<p>This is the most advanced bit in package detection. </p> <p>Some packages will swap characters with something very similar (usually in the label name), but not equal (and usually belonging to obscure charsets), so that they break classic string matching and make regex a hell to work with (the character's binary encoding is different, even if it looks the same to your eyes).</p> <p>And since this process is usually randomized, you can not know in advance which of the characters will be swapped and which will be real, so you have to take that into account.</p> <p>The solution is fast abstract matching, where we describe on a high level which string (word) we are looking for,  and then kevlar will automatically run the check on every package translating the high-level description to known sneaky characters (1 abstract character maps to many sneaky characters).</p> <p>This can be checked strictly (full match), partially (contains), or probabilistically (given a minimum percentage of matches)</p> <p>For FSA people, this is like having multiple arcs from one state to the next, with all the sneaky characters as transitions. Word acceptance is equivalent to detection.</p> <p>Sneaky characters</p> <p>The usual roll includes characters from Latin fullwidth, Cyrillic, Greek, a lot of weird uncategorized characters, and like 20 variations of the symbols <code>/</code>, <code>_</code> and <code>-</code>. You can go check out the full list at <code>AsciiVariations.kt</code>. I'd advise doing so on an empty stomach.</p> <p>These characters can be extracted from the installer package of said self-camouflaging pirate software.</p>"},{"location":"pages/modules/antipiracy/detection/#collateral-tools","title":"Collateral tools","text":"<p>Some techniques may have non-zero false positive rates, and they are disabled by default. Kevlar's objective is to achieve accurate detection, with a non-zero false-negative rate, but a zero false-positive rate. You can think of it as the judgement in a court trial: the defendant (package) is presumed to be innocent until proven guilty. And without using collateral techniques, we know we won't wrongly classify a normal package as a pirate one.</p> <p>Enabling collateral tools is a form of aggressive detection, and it should be used in scenarios where you are willing to accept some (little) risk to get stronger detection against self-obfuscating, for the price of non-zero false positives.</p> <p>The detection works because we know how some specific software tries to obfuscate/randomize its stub.  We can therefore match for the distribution of those values in all installed packages, and if one matches then it may be what we are looking for. It may also be something else. By default we assume it is innocuous, but enabling these checks will treat these matches as hits, and will be included in the attestation.</p> <p>Collateral example in package name randomization</p> <p>The easiest example to illustrate this technique is with Lucky Patcher.  Its installer generates a randomized stub, inserts the payload (the actual pirate software), and installs it. </p> <p>While the stub's package name has random bits, it is not completely random. It always starts with \"ru.\", followed by 8 random characters, followed by a \".\", followed by another 9 random characters. And we can form a pattern-detection test detecting these fixed occourrences. Here's a FSM:</p> <pre><code>stateDiagram-v2\ndirection LR\n[*] --&gt; ru.\nru. --&gt; 8?\n8? --&gt; .\n. --&gt; 9?\n9? --&gt; .\n. --&gt; [*]</code></pre> <p>Using this technique will successfully detect lucky patcher's stub if installed, along with any other software whose package name happens to match the given specification</p>"},{"location":"pages/modules/antipiracy/implementation/","title":"Implementation","text":"<p>A working example for the antipiracy module can be found in the github repository under the <code>:showcase</code> module.</p>"},{"location":"pages/modules/antipiracy/implementation/#dependency","title":"Dependency","text":"Gradle <pre><code>dependencies {\n    implementation \"io.github.kevlar-kt:antipiracy:1.1.1\"\n}\n</code></pre> Kotlin DSL <pre><code>dependencies {\n    implementation(\"io.github.kevlar-kt:antipiracy:1.1.1\")\n}\n</code></pre> Maven <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;io.github.kevlar-kt&lt;/groupId&gt;\n    &lt;artifactId&gt;antipiracy&lt;/artifactId&gt;\n    &lt;version&gt;1.1.1&lt;/version&gt;\n    &lt;type&gt;pom&lt;/type&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"pages/modules/antipiracy/implementation/#permissions","title":"Permissions","text":"<p>Kevlar's antipiracy module works essentially by running heuristics and filters on the list of installed packages, against a local dataset, matching and reporting the results as they are found.</p> <p>Since Android 11 (API 30), there have been some changes regarding the behaviour of <code>PackageManager</code> (and the visibility of installed packages). Specifically, if you query all the installed packages (just like kevlar does, via <code>PackageManager#getInstalledApplications</code>), only a specified subset of installed apps are visible by default, and they are packages that may interact with your app.</p> <p>This, in turn, would break the attestation process, because malicious software may not be returned in said package list, and won't therefore be detected.</p> <p>There are a few workarounds for this: either listing in the app's manifest a few query entries that will enable <code>PackageManager</code> to return the packages that kevlar's engine may detect, or adding a special permission to your app's manifest (with a few drawbacks)</p> <p>You can more about this in privacy.</p>"},{"location":"pages/modules/antipiracy/implementation/#kevlar-manifest-queries","title":"Kevlar Manifest Queries","text":"<p>The following queries will enable Kevlar to read, among the other app-related packages, all the packages which it will be looking for. This fixes the problem, as you can have a working antipiracy system, without adding the <code>QUERY_ALL_PACKAGES</code> permission</p> <p>Include the queries statement in your manifest like so:</p> AndroidManifest.xml (single line)<pre><code>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:tools=\"http://schemas.android.com/tools\"&gt;\n\n    &lt;queries&gt;\n        &lt;package android:name=\"uret.jasi2169.patcher\" /&gt; &lt;package android:name=\"zone.jasi2169.uretpatcher\" /&gt; &lt;package android:name=\"org.creeplays.hack\" /&gt; &lt;package android:name=\"apps.zhasik007.hack\" /&gt; &lt;package android:name=\"com.leo.playcard\" /&gt; &lt;package android:name=\"com.appsara.app\" /&gt; &lt;package android:name=\"com.xmodgame\" /&gt; &lt;package android:name=\"org.sbtools.gamehack\" /&gt; &lt;package android:name=\"com.zune.gamekiller\" /&gt; &lt;package android:name=\"com.killerapp.gamekiller\" /&gt; &lt;package android:name=\"cn.lm.sq\" /&gt; &lt;package android:name=\"com.aag.killer\" /&gt; &lt;package android:name=\"com.github.oneminusone.disablecontentguard\" /&gt; &lt;package android:name=\"com.oneminusone.disablecontentguard\" /&gt; &lt;package android:name=\"madkite.freedom\" /&gt; &lt;package android:name=\"jase.freedom\" /&gt; &lt;package android:name=\"cc.jase.freedom\" /&gt; &lt;package android:name=\"cc.madkite.freedom\" /&gt; &lt;package android:name=\"cc.cz.madkite.freedom\" /&gt; &lt;package android:name=\"com.devadvance.rootcloak\" /&gt; &lt;package android:name=\"com.devadvance.rootcloakplus\" /&gt; &lt;package android:name=\"com.formyhm.hideroot\" /&gt; &lt;package android:name=\"com.formyhm.hiderootpremium\" /&gt; &lt;package android:name=\"com.amphoras.hidemyroot\" /&gt; &lt;package android:name=\"com.amphoras.hidemyrootadfree\" /&gt; &lt;package android:name=\"com.zachspong.temprootremovejb\" /&gt; &lt;package android:name=\"cm.aptoide.pt\" /&gt; &lt;package android:name=\"com.happymod.apk\" /&gt; &lt;package android:name=\"happygames.io\" /&gt; &lt;package android:name=\"org.blackmart.market\" /&gt; &lt;package android:name=\"com.blackmartalpha\" /&gt; &lt;package android:name=\"com.mobogenie\" /&gt; &lt;package android:name=\"me.onemobile.android\" /&gt; &lt;package android:name=\"com.repodroid.app\" /&gt; &lt;package android:name=\"com.getjar.reward\" /&gt; &lt;package android:name=\"com.slideme.sam.manager\" /&gt; &lt;package android:name=\"ac.market.store\" /&gt; &lt;package android:name=\"net.appcake\" /&gt; &lt;package android:name=\"com.appcake\" /&gt; &lt;package android:name=\"com.zmapp\" /&gt; &lt;package android:name=\"org.mobilism.android\" /&gt; &lt;package android:name=\"com.allinone.free\" /&gt; &lt;package android:name=\"com.chelpus.lackypatch\" /&gt; &lt;package android:name=\"com.dimonvideo.luckypatcher\" /&gt; &lt;package android:name=\"com.forpda.lp\" /&gt; &lt;package android:name=\"com.android.vendinc\" /&gt; &lt;package android:name=\"com.android.vending.licensing.ILicensingService\" /&gt; &lt;package android:name=\"com.android.vending.billing.InAppBillingService.LOCK\" /&gt;\n\n        &lt;intent&gt;\n                &lt;action android:name=\"android.intent.action.SEND_MULTIPLE\" /&gt;\n                &lt;data android:mimeType=\"*/*\" /&gt;\n        &lt;/intent&gt;\n    &lt;/queries&gt;\n\n\n    &lt;application\n        android:name=\"com.kevlar.showcase.App\"\n        android:icon=\"@mipmap/ic_launcher\"\n        android:label=\"@string/app_name\"\n        android:theme=\"@style/AppTheme\"&gt;\n\n        &lt;activity\n            android:name=\"com.kevlar.showcase.ui.activities.main.MainActivity\"\n            android:exported=\"true\"&gt;\n\n            &lt;intent-filter&gt;\n                &lt;action android:name=\"android.intent.action.MAIN\" /&gt;\n\n                &lt;category android:name=\"android.intent.category.LAUNCHER\" /&gt;\n            &lt;/intent-filter&gt;\n        &lt;/activity&gt;\n    &lt;/application&gt;\n&lt;/manifest&gt;\n</code></pre> Multi-line AndroidManifest.xml<pre><code>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:tools=\"http://schemas.android.com/tools\"&gt;\n\n    &lt;queries&gt;\n        &lt;package android:name=\"uret.jasi2169.patcher\" /&gt;\n        &lt;package android:name=\"zone.jasi2169.uretpatcher\" /&gt;\n        &lt;package android:name=\"org.creeplays.hack\" /&gt;\n        &lt;package android:name=\"apps.zhasik007.hack\" /&gt;\n        &lt;package android:name=\"com.leo.playcard\" /&gt;\n        &lt;package android:name=\"com.appsara.app\" /&gt;\n        &lt;package android:name=\"com.xmodgame\" /&gt;\n        &lt;package android:name=\"org.sbtools.gamehack\" /&gt;\n        &lt;package android:name=\"com.zune.gamekiller\" /&gt;\n        &lt;package android:name=\"com.killerapp.gamekiller\" /&gt;\n        &lt;package android:name=\"cn.lm.sq\" /&gt;\n        &lt;package android:name=\"com.aag.killer\" /&gt;\n        &lt;package android:name=\"com.github.oneminusone.disablecontentguard\" /&gt;\n        &lt;package android:name=\"com.oneminusone.disablecontentguard\" /&gt;\n        &lt;package android:name=\"madkite.freedom\" /&gt;\n        &lt;package android:name=\"jase.freedom\" /&gt;\n        &lt;package android:name=\"cc.jase.freedom\" /&gt;\n        &lt;package android:name=\"cc.madkite.freedom\" /&gt;\n        &lt;package android:name=\"cc.cz.madkite.freedom\" /&gt;\n        &lt;package android:name=\"com.devadvance.rootcloak\" /&gt;\n        &lt;package android:name=\"com.devadvance.rootcloakplus\" /&gt;\n        &lt;package android:name=\"com.formyhm.hideroot\" /&gt;\n        &lt;package android:name=\"com.formyhm.hiderootpremium\" /&gt;\n        &lt;package android:name=\"com.amphoras.hidemyroot\" /&gt;\n        &lt;package android:name=\"com.amphoras.hidemyrootadfree\" /&gt;\n        &lt;package android:name=\"com.zachspong.temprootremovejb\" /&gt;\n        &lt;package android:name=\"cm.aptoide.pt\" /&gt;\n        &lt;package android:name=\"com.happymod.apk\" /&gt;\n        &lt;package android:name=\"happygames.io\" /&gt;\n        &lt;package android:name=\"org.blackmart.market\" /&gt;\n        &lt;package android:name=\"com.blackmartalpha\" /&gt;\n        &lt;package android:name=\"com.mobogenie\" /&gt;\n        &lt;package android:name=\"me.onemobile.android\" /&gt;\n        &lt;package android:name=\"com.repodroid.app\" /&gt;\n        &lt;package android:name=\"com.getjar.reward\" /&gt;\n        &lt;package android:name=\"com.slideme.sam.manager\" /&gt;\n        &lt;package android:name=\"ac.market.store\" /&gt;\n        &lt;package android:name=\"net.appcake\" /&gt;\n        &lt;package android:name=\"com.appcake\" /&gt;\n        &lt;package android:name=\"com.zmapp\" /&gt;\n        &lt;package android:name=\"org.mobilism.android\" /&gt;\n        &lt;package android:name=\"com.allinone.free\" /&gt;\n        &lt;package android:name=\"com.chelpus.lackypatch\" /&gt;\n        &lt;package android:name=\"com.dimonvideo.luckypatcher\" /&gt;\n        &lt;package android:name=\"com.forpda.lp\" /&gt;\n        &lt;package android:name=\"com.android.vendinc\" /&gt;\n        &lt;package android:name=\"com.android.vending.licensing.ILicensingService\" /&gt;\n        &lt;package android:name=\"com.android.vending.billing.InAppBillingService.LOCK\" /&gt;\n\n        &lt;intent&gt;\n                &lt;action android:name=\"android.intent.action.SEND_MULTIPLE\" /&gt;\n                &lt;!-- &lt;category android:name=\"android.intent.category.DEFAULT\" /&gt; --&gt;\n                &lt;data android:mimeType=\"*/*\" /&gt;\n        &lt;/intent&gt;\n    &lt;/queries&gt;\n\n\n    &lt;application\n        android:name=\"com.kevlar.showcase.App\"\n        android:icon=\"@mipmap/ic_launcher\"\n        android:label=\"@string/app_name\"\n        android:theme=\"@style/AppTheme\"&gt;\n\n        &lt;activity\n            android:name=\"com.kevlar.showcase.ui.activities.main.MainActivity\"\n            android:exported=\"true\"&gt;\n\n            &lt;intent-filter&gt;\n                &lt;action android:name=\"android.intent.action.MAIN\" /&gt;\n\n                &lt;category android:name=\"android.intent.category.LAUNCHER\" /&gt;\n            &lt;/intent-filter&gt;\n        &lt;/activity&gt;\n    &lt;/application&gt;\n&lt;/manifest&gt;\n</code></pre>"},{"location":"pages/modules/antipiracy/implementation/#query_all_packages-permission","title":"<code>QUERY_ALL_PACKAGES</code> Permission","text":"<p>This is a very particular permission, as it allows your app to be treated pre-api30 and receive the full, unfiltered app list. It is declared below:</p> AndroidManifest.xml<pre><code>    &lt;uses-permission\n        android:name=\"android.permission.QUERY_ALL_PACKAGES\"\n        tools:ignore=\"QueryAllPackagesPermission\" /&gt;\n</code></pre> <p>Google Play Store Admission</p> <p>Apps built using this permission may not be allowed on the play store, unless they belong in a specific category </p> <pre><code>&lt;uses-permission android:name=\"android.permission.QUERY_ALL_PACKAGES\"\n    tools:ignore=\"QueryAllPackagesPermission\" /&gt;\n</code></pre>"},{"location":"pages/modules/antipiracy/implementation/#initialization-attestations","title":"Initialization &amp; Attestations","text":"<p>You need to create a <code>KevlarAntipiracy</code> instance (which is the way you will be requesting attestations), along with your desired parameters (either global, local or in your repository layer, if you are using MVVM/MVC).</p> <p>Once you have that, you just go ahead and call <code>antipiracy.attestate()</code> in a coroutine and your system will be analyzed, according to the provided parameters.</p> <p><code>AntipiracyAttestation</code> will be returned from the call (it's a sealed class), containing the found software list, if any.</p> <p>Note that we will be initializing <code>KevlarAntipiracy</code> with custom scan settings, but you could leave it as default.</p>"},{"location":"pages/modules/antipiracy/implementation/#in-place","title":"In-Place","text":"<p>This is the most concise way to implement piracy checks.</p> InPlace.kt<pre><code>val antipiracy = KevlarAntipiracy {\n    scan {\n        // your scan configuration\n        pirate()\n        store()\n    }\n}\n\nCoroutineScope(Dispatchers.Default).launch {\n    // Attestation request\n    when (val attestation = antipiracy.attestate(context)) {\n        is AntipiracyAttestation.Blank -&gt; {\n            // Pending attestation, no information yet. \n            // Don't do anything.\n        }\n        is AntipiracyAttestation.Clear -&gt; {\n            // Good to go.\n        }\n        is AntipiracyAttestation.Failed -&gt; {\n            // Pirate software detected.\n        }\n    }\n}\n</code></pre> <p>This packs everything in one file. It is not excellent when writing a modern applications but it does its job.</p>"},{"location":"pages/modules/antipiracy/implementation/#viewmodel-repository-sharedflow-di-with-hilt","title":"ViewModel + Repository + SharedFlow + DI with Hilt","text":""},{"location":"pages/modules/antipiracy/implementation/#activity","title":"Activity:","text":"AntipiracyActivity.kt<pre><code>@AndroidEntryPoint\nclass AntipiracyActivity : AppCompatActivity() {\n\n    private val vm: ActivityViewModel by viewModels()\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n\n        lifecycleScope.launch {\n            lifecycle.repeatOnLifecycle(Lifecycle.State.STARTED) {\n                vm.attestation.collectLatest {\n                    when (it) {\n                        is AntipiracyAttestation.Blank -&gt; {\n                            // Pending attestation, no information yet.\n                            // Don't do anything.\n                        }\n                        is AntipiracyAttestation.Clear -&gt; {\n                            // Good to go.\n                        }\n                        is AntipiracyAttestation.Failed -&gt; {\n                            // Pirate software detected.\n                        }\n                    }\n                }\n            }\n        }\n\n        CoroutineScope(Dispatchers.Main).launch {\n            vm.requestAttestation()\n        }\n    }\n}\n</code></pre>"},{"location":"pages/modules/antipiracy/implementation/#view-model","title":"View model:","text":"ActivityViewModel.kt<pre><code>@HiltViewModel\nclass ActivityViewModel @Inject constructor(\n    private val securityRepository: AntipiracyRepository\n) : ViewModel() {\n\n    private val _attestationState = MutableStateFlow(KevlarAntipiracy.blankAttestation())\n\n    val attestation: SharedFlow&lt;AntipiracyAttestation&gt; = _attestationState.stateIn(\n        viewModelScope,\n        SharingStarted.Eagerly,\n        initialValue = KevlarAntipiracy.blankAttestation()\n    )\n\n    fun requestAttestation() {\n        viewModelScope.launch {\n            _attestationState.value = securityRepository.attestate()\n        }\n    }\n}\n</code></pre>"},{"location":"pages/modules/antipiracy/implementation/#repository","title":"Repository","text":"AntipiracyRepository.kt<pre><code>class AntipiracyRepository @Inject constructor(\n    @ApplicationContext val context: Context,\n    @IoDispatcher val externalDispatcher: CoroutineDispatcher\n) {\n    private val antipiracy = KevlarAntipiracy {\n        scan {\n            // your scan configuration DSL here\n            pirate()\n            store()\n        }\n    }\n\n    suspend fun attestate(): AntipiracyAttestation = withContext(externalDispatcher) {\n        antipiracy.attestate(context)\n    }\n}\n</code></pre>"},{"location":"pages/modules/antipiracy/privacy/","title":"Privacy &amp; Package Queries","text":"<p>The antipiracy module is designed to check user-wide security. As such, it is the layer that is closest to the user data and thus needs to take extra care to enforce user privacy requirements.</p>"},{"location":"pages/modules/antipiracy/privacy/#package-queries","title":"Package Queries","text":"<p>A crucial element in this process is retrieving the application list, in which all the checks  are subsequently run on.</p> <p>This is increasingly getting difficult. Since Android 11 (API 30) the full package list  is filtered by default, and there are more privacy-friendly (less intrusive) methods for querying apps. Those don't work as well with pirate app detection because usually pirate software actively  tries to hide its presence with camouflage techniques</p> <p>A nice technique is declaring the appropriate queries in the app's manifest, so that the list given to kevlar, although not complete, will contain all the packages referenced by the queries. And since kevlar searches for known pirate apps/stores (and thus packages), we can add these as packages we're interested in receiving, and we're set.</p> <p>It gets a little more complex for packages which actively try to hide themselves / randomize their  properties to avoid detections, but it can be done.</p> <p>You can find the guide on how to add that to the manifest in the implementation page.</p> <p>Unintentional Computational Speedup</p> <p>By limiting the amount of packages returned by the package manager, the battery of checks (which has to be ran for each package), will take less, and therefore further reduce the execution time for the attestation. So not bad news after all!</p>"},{"location":"pages/modules/antipiracy/privacy/#user-privacy-attitude","title":"User Privacy &amp; Attitude","text":"<p>Another delicate aspect of querying installed packages is the way you communicate to the user that you just scanned all the packages and found pirate software, and therefore will not let them proceed to the purchase they were about to happily crack.</p> <p>While obviously, you should not by any means be afraid to deny the purchase/transaction/service to a malevolent user, there are varying degrees of directness with which you can communicate your decision to the end user.</p> <p>Usually, they are not best pleased with the discovery, so a little bit of touch is advised.</p> <p>Some implementations go the other way and just do not work/act as broken, while in reality they did a much deeper check, found that the environment is unsafe, assumed that the currently running software is pirated, and refused to proceed. Usually, this works because the user knows it is doing something wrong and it expects that something may break or that some self-checking is in place.</p> <p>Protection &amp; Reviews</p> <p>I have implemented in all my commercial Android software some sort of piracy checks, and while I'd like to show you some store reviews, I will refrain from exposing your uninitialized eyes to the unfathomable pain I went through while reading them in the first place.</p> <p>Let's just say it usually goes down like this:</p> <ol> <li>User tries to crack your app with pirate software;</li> <li>Your app picks up the pirate software, and refuses to start the in-app transaction because the environment is unsecured;</li> <li>Said user suddenly becomes a mobile security expert and goes on the store to angrily review your app as garbage/spyware/malware/trojan/...</li> </ol>"},{"location":"pages/modules/antipiracy/reference/","title":"Reference","text":"<p>The complete rooting configuration is as follows.</p> Complete settings<pre><code>private val antipiracy = KevlarAntipiracy {\n    scan {\n        pirate()\n        store()\n        collateral()\n    }\n}\n</code></pre> <p>Once you require the attestation through <code>attestate(context)</code>, any software matching your settings will be reported.</p> <pre><code>withContext(externalDispatcher) {\n    val attestation = antipiracy.attestate(context)\n}\n</code></pre> <p>You can find all the details about what software is regarded as pirate in the database page.</p>"},{"location":"pages/modules/antipiracy/reference/#pirate-apps","title":"Pirate Apps","text":"<p>The <code>pirate()</code> function tells kevlar to scan the application list, and match it against the local dataset for pirate applications.</p> <p>If any package is deemed to be a pirate application, it is included in the attestation</p> <pre><code>private val antipiracy = KevlarAntipiracy {\n    scan {\n        pirate()\n        store()\n        collateral()\n    }\n}\n</code></pre>"},{"location":"pages/modules/antipiracy/reference/#pirate-stores","title":"Pirate Stores","text":"<p>The <code>store()</code> function tells kevlar to scan the application list, and match it against the local dataset for pirate stores.</p> <pre><code>private val antipiracy = KevlarAntipiracy {\n    scan {\n        pirate()\n        store()\n        collateral()\n    }\n}\n</code></pre>"},{"location":"pages/modules/antipiracy/reference/#collateral-detection-methods","title":"Collateral detection methods","text":"<p>The <code>collateral()</code> function enables kevlar to use more aggressive methods to perform the lookup of specific pirate software.</p> <pre><code>private val antipiracy = KevlarAntipiracy {\n    scan {\n        pirate()\n        store()\n        collateral()\n    }\n}\n</code></pre> <p>This is made a separate flag because those special methods have a non-zero false-positive probability,  and therefore are risky to use because you may (albeit extremely rarely) end up in situations where an unrelated software (usually russian) may be detected as pirate software. Since we want you to have full control over  your scan settings, we extrapolated this flag to make the switch explicit.</p> <p>More details in the detection page.</p>"},{"location":"pages/modules/antipiracy/tradeoffs/","title":"Tradeoffs","text":"<p>kevlar is not an antivirus. It is not designed to be on that end of the spectrum. It is an heuristic to quickly catch most of the junk installed on the device.</p> <p>As a general rule of thumb:</p> <ul> <li>If you want more precision, you need more time (There are advanced and stricter checks used in financial software: archive and directory scanning, extended signature checks, and everything done with professional security software, but doing that defeats the purpose).</li> <li>If you want less running time, you will have less precision.</li> </ul>"},{"location":"pages/modules/integrity/hardcoding/","title":"Hardcoded data","text":"<p>When an application is being tampered with, its code can change.  Its behavior can mutate. Its features may (and will) be radically different than what you have developed in production.</p> <p>This introduces all kinds of issues regarding the consistency of the code itself. The key to detection is being able to avoid some of those code changes on hardcoded data, and detecting inconsistencies</p> <p>Nintendo Antipiracy &amp; Consistency checks</p> <p>Some Nintendo games are known to have self-checking and inconsistency detection for antipiracy purposes.  They may, for instance, read from a non-existent memory slot [on purpose] as a form of check, and if the read operation is successful then it is likely that the program is being run in a pirate environment (tape, emulator, or custom hardware), as opposed to an original one, where the read operation would have failed.</p>"},{"location":"pages/modules/integrity/hardcoding/#package-name-change","title":"Package name change","text":"<p>A simple example would be an attack that aims at changing the package name of your app.</p> <p>They usually just change application metadata and packages and try to recompile them.</p> <p>If it is done well, they may try to also run a text search inside application strings to look for the package, just in case it was saved in a string variable, and change it too. </p> <p>If it is done extremely well (not implemented anywhere afaik), then they may also try to break some of the easy string obfuscation (base64 or other text encodings &amp; charsets) and produce a different string that de-obfuscates to what the changed package name is.</p> <p>About signature changes</p> <p>Whatever you sign is eternal. Signature verification is extremely important because nobody else can sign software with your signature (since you have your private key in the Keystore).</p> <p>Modifying even one bit inside your app requires the attacker to sign the application. And since they don't have access to your Keystore, they can only resign it with their key or a debug key. But the point is, it is not your one. As soon as you detect that your signature doesn't match the one on the package that's running, you know that something has gone wrong.</p>"},{"location":"pages/modules/integrity/hardcoding/#protection-through-obfuscation","title":"Protection through Obfuscation","text":"<p>As much as this may look like security through obscurity, it is a necessary technique employed to make sure that automatic attacks against your app's code do not also intercept your hardcoded data. </p> <p>This is because an automated attack may try to find any hardcoded metadata and replace it with the new value they are trying to change to. Creating a safe container for those truth values is vital for the checks so that they can compare the original hardcoded value with the runtime value, and match them.</p>"},{"location":"pages/modules/integrity/implementation/","title":"Implementation","text":"<p>Implementing <code>integrity</code> requires, on top of a <code>KevlarAntipiracy</code> and the attestation infrastructure, a bit of information about your application's metadata, which will be hardcoded inside it.</p> <p>Hardcoded data is necessary to provide kevlar a truth value (essentially, that should be the description of all the scenarios that the application is allowed to run in) to match the runtime values of your binary (which may have been tampered or altered by an attacker) against.</p> <p>That's because, if done well, we can detect almost every kind of attack/tampering attempt through checking various APK metadata, such as the package name, the signature, the installer and debug flags.</p> <p>The obfuscation is necessary because we need to conceal the truth values, since they will be looked for by the attacker (software or human), and make it as hard as possible to automatically find and patch them.</p> <p>A working example for the integrity module can be found in the github repository under the <code>:showcase</code> module.</p>"},{"location":"pages/modules/integrity/implementation/#dependency","title":"Dependency","text":"Gradle <pre><code>dependencies {\n    implementation \"io.github.kevlar-kt:integrity:1.1.1\"\n}\n</code></pre> Kotlin DSL <pre><code>dependencies {\n    implementation(\"io.github.kevlar-kt:integrity:1.1.1\")\n}\n</code></pre> Maven <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;io.github.kevlar-kt&lt;/groupId&gt;\n    &lt;artifactId&gt;integrity&lt;/artifactId&gt;\n    &lt;version&gt;1.1.1&lt;/version&gt;\n    &lt;type&gt;pom&lt;/type&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"pages/modules/integrity/implementation/#hardcoded-metadata","title":"Hardcoded metadata","text":""},{"location":"pages/modules/integrity/implementation/#understanding-which-metadata-you-need","title":"Understanding which metadata you need","text":"<p>The first step is choosing which checks to run, and thus which data to provide kevlar.</p> <p>The good news is that they all are stable metadata. This means that once you make the effort of searching the right strings and implementing everything, you are ideally good to go forever.</p> <p>Kevlar has 4 kinds of checks: a package name check, a signature check, an installer check and a debug check.</p> Check Type Required parameters Parameter type Package Name package name <code>String</code> Signature Check app signature <code>String</code> (base64-encoded) Installer Check N/A N/A Debug Check N/A N/A <p>The hardcoded metadata you need to find is the following:</p> <ul> <li>Your application package name: Will check that the running binary's package name matches the   hardcoded package name;</li> <li>Your application signature: Will check that the running binary's signature is the same as the   hardcoded signature.</li> </ul> <p>Additionally, you should consider enabling the other two kinds of checks:</p> <ul> <li>Debug checks: Is enabled, kevlar autonomously checks for debug flags and bits in your binary;</li> <li>Installer checks: If enabled, kevlar will report any application which has not been installed   through an allowed installer (by default it only supports the Play Store, but you can add custom   stores if you distribute your software elsewhere).</li> </ul> <p>Once you choose which kind of checks you want to run, you get the required metadata</p> hardcoded_metadata.kt<pre><code>// Holds the package name\nprivate val packageNameData = HardcodedPackageName(\n    packageName = \"com.kevlar.showcase\"\n)\n\n// Holds the signature\nprivate val signatureData = HardcodedBase64EncodedSignature(\n    base64EncodedSignature = \"J+nqXLfuIO8B2AmhkMYHGE4jDyw=\"\n)\n\n// Combines all the metadata and configuration\nprivate val integrity = KevlarIntegrity {\n    checks {\n        packageName {\n            hardcodedPackageName(packageNameData)\n        }\n\n        signature {\n            hardcodedSignatures(signatureData)\n        }\n\n        installer()\n        debug()\n    }\n}\n\n// Runs the checks on the current executing app\nintegrity.attestate(context)\n</code></pre> <p>Do not</p> <p>Maybe, just maybe, you may be tempted to so something like this:</p> VERY_BAD_hardcoded_metadata.kt<pre><code>private val notAtAllHardcodedMetadata = HardcodedMetadata(\n    packageName = context.getPackageName(),\n    signature = getRuntimeSignature()\n)\n</code></pre> <p>The sole purpose of <code>HardcodedMetadata</code> is hardcoding truth values inside your app, which don't depend on the context or application, which may have been tampered with. This snippet single handedly kills the whole library (because kevlar will check that the (supposedly) hardcoded package name, in this case <code>context.getPackageName()</code>, matches the runtime package name, which is always true since it is gathered via <code>context.getPackageName()</code> too) and is like shooting yourself in the foot with a cannon. Don't. </p>"},{"location":"pages/modules/integrity/implementation/#finding-metadata","title":"Finding metadata","text":"<p>Finding the package name is easy, since you are the one choosing it for your application.</p> <p>For the signature, it's not so straightforward to extract because it depends on your keystore. You have two different ways to get your keystore signature. In the examples we will find the debug signature, but you need to find the signature of the keystore you use to sign your application when publishing on google play.</p>"},{"location":"pages/modules/integrity/implementation/#direct-application-extraction","title":"Direct application extraction","text":"<p>The most practical way to read your keystore it is to put the following line of code in your app, to then sign the application with the key you are interested in acquiring the signature string of, and run it.</p> <pre><code>// This returns the signature of the current running application.\nval signature: String = KevlarIntegrity.obtainCurrentAppSignature(context)\n</code></pre> <p>This will output the current app signature.  That's the reference string you need to give to kevlar (which will extract the runtime signature of your app and match it against that string).</p> <p>Android debug signature</p> <p>Every android application is signed with some key.  When an application is signed as \"debug\", it simply means that it is signed with a special key, which is known to be the debug key.</p> <p>Signature extraction &amp; Google Play App Signing API</p> <p>If you are using Google Play App Signing, the key you sign your application with is not the one your app is distributed with (See the official docs regarding the matter, and a relevant issue in kevlar).</p> <p>In this case the easiest way to get your actual signature would be to upload a dummy version of your app (which logs the runtime signature) through google play store, let the backend process and sign it, download it (through the archive manager on the play console), install &amp; run it locally on an emulator/device, and save the runtime signature. Once you have done this (quite tedious) procedure, you have your signature and can pass it to kevlar.</p>"},{"location":"pages/modules/integrity/implementation/#android-studio-extraction","title":"Android studio extraction","text":"<p>Running <code>./gradlew signingReport</code> will spit out all the details for all the different keystores in your project.</p> <p>The signature we are interested in is the SHA-1 entry. In this case, <code>27:E9:EA:5C:B7:EE:20:EF:01:D8:09:A1:90:C6:07:18:4E:23:0F:2C</code>.</p> <pre><code>&gt; Task :showcase:signingReport\nVariant: debug\nConfig: debug\nStore: /Users/cioccarellia/.android/debug.keystore\nAlias: AndroidDebugKey\nMD5: 1B:AF:39:46:4E:13:83:F3:45:E9:0A:5A:53:64:9C:CB\nSHA1: 27:E9:EA:5C:B7:EE:20:EF:01:D8:09:A1:90:C6:07:18:4E:23:0F:2C\nSHA-256: 36:C8:C0:A1:8A:DD:6D:0E:34:F9:6E:7E:98:DC:1F:89:08:BC:CD:2E:EF:88:ED:45:DF:79:85:D2:39:BD:E1:54\nValid until: Tuesday, June 25, 2052\n----------\nVariant: release\nConfig: null\nStore: null\nAlias: null\n----------\n</code></pre> <p>We then have to convert it in a string form (like that we have the raw hex bytes, we want a base64 encoding of the binary signature). In this case the conversion (you can use online tools to do this) yields <code>J+nqXLfuIO8B2AmhkMYHGE4jDyw=</code>.</p> <p>Play Signing</p> <p>Since we don't have access to the keystore file if we use Play Signing, this method is not viable in that case, and you have to resort to uploading a dummy version of the app, download its play-signed version through the releases page, and extract the signature from that APK file.</p>"},{"location":"pages/modules/integrity/implementation/#obfuscating-metadata","title":"Obfuscating metadata","text":"<p>The second step (optional but recommended) is obfuscating the metadata you just gathered, so that it is saved in an obfuscated form (in your bytecode, so that automatic tools / unskilled attackers can't easily find it), but passed to kevlar deobfuscated (so that we have the original truth values at run time).</p> <p>This means that we ship with out app the obfuscated data and the way to convert that obfuscated data back to plaintext to feed kevlar.</p> <p>There are a few different ways to do it, all of them are fully implemented in the <code>:showcase</code> module:</p>"},{"location":"pages/modules/integrity/implementation/#no-obfuscation-not-recommended","title":"No obfuscation (not recommended)","text":"<p>In this case you just save the values as they are, and pass them in <code>HardcodedMetadata</code></p> unobfuscated_hardcoded_metadata.kt<pre><code>private const val packageName = HardcodedPackageName(\"com.kevlar.showcase\")\nprivate const val signature = HardcodedBase64EncodedSignature(\"J+nqXLfuIO8B2AmhkMYHGE4jDyw=\")\n</code></pre> Bytecode <p>The produced kotlin bytecode clearly exposes the raw values:</p> <pre><code>L1\n ALOAD 0\n NEW com/kevlar/integrity/model/HardcodedMetadata\n DUP\nL2\n LDC \"com.kevlar.showcase\"\nL3\n LDC \"J+nqXLfuIO8B2AmhkMYHGE4jDyw=\"\nL4\n INVOKESPECIAL com/kevlar/integrity/model/HardcodedMetadata.&lt;init&gt; (Ljava/lang/String;Ljava/lang/String;)V\n PUTFIELD com/kevlar/showcase/data/repo/IntegrityRepository.hardcodedMetadata : Lcom/kevlar/integrity/model/HardcodedMetadata;\n</code></pre>"},{"location":"pages/modules/integrity/implementation/#base64-obfuscation","title":"Base64 obfuscation","text":"<p>You store the package name and signature values as Base64-encoded byte arrays, and they go through the <code>Base64.decode()</code> function when creating <code>HardcodedMetadata</code>.</p> base64_obfuscated_hardcoded_metadata.kt<pre><code>private val packageName = \"\"\"Y29tLmtldmxhci5zaG93Y2FzZQ==\"\"\".toByteArray()\nprivate val signature = \"\"\"SitucVhMZnVJTzhCMkFtaGtNWUhHRTRqRHl3PQ==\"\"\".toByteArray()\n\n\nprivate val base64ObfuscatedHardcodedPackageName = HardcodedPackageName(\n    packageName = Base64.decode(base64PackageName, Base64.DEFAULT).toString(Charsets.UTF_8)\n)\n\nprivate val base64ObfuscatedHardcodedSignature = HardcodedBase64EncodedSignature(\n    Base64.decode(base64Signature, Base64.DEFAULT).toString(Charsets.UTF_8)\n)\n</code></pre> <p>Where <code>Y29tLmtldmxhci5zaG93Y2FzZQ==</code> is the base64 encoding of <code>com.kevlar.showcase</code>, and <code>SitucVhMZnVJTzhCMkFtaGtNWUhHRTRqRHl3PQ==</code> of <code>J+nqXLfuIO8B2AmhkMYHGE4jDyw=</code> (the signature).</p> <p>You can look them up online, grab them from your app or use <code>openssl base64</code> in the terminal.</p> <p>Base64 flags &amp; charset</p> <p>The flag field and charset don't necessarily need to be <code>Base64.DEFAULT</code> and <code>UTF_8</code>. Even though they are the most popular, you may choose something else if you prefer, as long as you preserve consistency.</p> Bytecode <p>Here the metadata is hidden and not targetable with basic find-and-replace techniques</p> <pre><code>L6\n ALOAD 0\n LDC \"Y29tLmtldmxhci5zaG93Y2FzZQ==\"\n ASTORE 3\n GETSTATIC kotlin/text/Charsets.UTF_8 : Ljava/nio/charset/Charset;\n ASTORE 4\nL7\n ALOAD 3\nL8\n ALOAD 4\n INVOKEVIRTUAL java/lang/String.getBytes (Ljava/nio/charset/Charset;)[B\n DUP\n LDC \"(this as java.lang.String).getBytes(charset)\"\n INVOKESTATIC kotlin/jvm/internal/Intrinsics.checkNotNullExpressionValue (Ljava/lang/Object;Ljava/lang/String;)V\nL9\n PUTFIELD com/kevlar/showcase/data/repo/IntegrityRepository.packageName : [B\nL10\n ALOAD 0\n LDC \"SitucVhMZnVJTzhCMkFtaGtNWUhHRTRqRHl3PQ==\"\n ASTORE 3\n GETSTATIC kotlin/text/Charsets.UTF_8 : Ljava/nio/charset/Charset;\n ASTORE 4\nL11\n ALOAD 3\nL12\n ALOAD 4\n INVOKEVIRTUAL java/lang/String.getBytes (Ljava/nio/charset/Charset;)[B\n DUP\n LDC \"(this as java.lang.String).getBytes(charset)\"\n INVOKESTATIC kotlin/jvm/internal/Intrinsics.checkNotNullExpressionValue (Ljava/lang/Object;Ljava/lang/String;)V\nL13\n PUTFIELD com/kevlar/showcase/data/repo/IntegrityRepository.signature : [B\nL14\n ALOAD 0\n NEW com/kevlar/integrity/model/HardcodedMetadata\n DUP\nL15\n ALOAD 0\n GETFIELD com/kevlar/showcase/data/repo/IntegrityRepository.packageName : [B\n ICONST_0\n INVOKESTATIC android/util/Base64.decode ([BI)[B\n DUP\n LDC \"Base64.decode(packageName, Base64.DEFAULT)\"\n INVOKESTATIC kotlin/jvm/internal/Intrinsics.checkNotNullExpressionValue (Ljava/lang/Object;Ljava/lang/String;)V\n ASTORE 3\n GETSTATIC kotlin/text/Charsets.UTF_8 : Ljava/nio/charset/Charset;\n ASTORE 4\nL16\n NEW java/lang/String\n DUP\n ALOAD 3\n ALOAD 4\n INVOKESPECIAL java/lang/String.&lt;init&gt; ([BLjava/nio/charset/Charset;)V\nL17\nL18\n ALOAD 0\n GETFIELD com/kevlar/showcase/data/repo/IntegrityRepository.signature : [B\n ICONST_0\n INVOKESTATIC android/util/Base64.decode ([BI)[B\n DUP\n LDC \"Base64.decode(signature, Base64.DEFAULT)\"\n INVOKESTATIC kotlin/jvm/internal/Intrinsics.checkNotNullExpressionValue (Ljava/lang/Object;Ljava/lang/String;)V\n ASTORE 3\n GETSTATIC kotlin/text/Charsets.UTF_8 : Ljava/nio/charset/Charset;\n ASTORE 4\nL19\n NEW java/lang/String\n DUP\n ALOAD 3\n ALOAD 4\n INVOKESPECIAL java/lang/String.&lt;init&gt; ([BLjava/nio/charset/Charset;)V\nL20\nL21\n INVOKESPECIAL com/kevlar/integrity/model/HardcodedMetadata.&lt;init&gt; (Ljava/lang/String;Ljava/lang/String;)V\n PUTFIELD com/kevlar/showcase/data/repo/IntegrityRepository.base64ObfuscatedHardcodedMetadata : Lcom/kevlar/integrity/model/HardcodedMetadata;\n</code></pre>"},{"location":"pages/modules/integrity/implementation/#encryption-base64","title":"Encryption (+base64)","text":"<p>A better alternative is to encrypt the hardcoded metadata, store them in an encrypted form, and send them through a decryption function when creating <code>HardcodedMetadata</code>.</p> encrypted_hardcoded_metadata.kt<pre><code>// Our arbitrary 256-bit encryption key\nprivate val aesKey256 = \"\"\"4t7w!z%C*F-JaNcRfUjXn2r5u8x/A?Ds\"\"\"\n\n// This is \"com.kevlar.showcase\", encrypted using AES256 with the previous key\nprivate val encryptedPackageName = \"\"\"s3wf/AOYtr9BEMVFrweeLnkmerryUykMA8O77S5tMlI=\"\"\".toByteArray()\n\n// This is \"J+nqXLfuIO8B2AmhkMYHGE4jDyw=\", encrypted using AES256 with the previous key\nprivate val encryptedSignature = \"\"\"tqMJquO3D+EKx1rx4R7/qzmsuEgpp1bKwxXe9AeB/WU=\"\"\".toByteArray()\n\n\nprivate val aes256EncryptedHardcodedPackageName = HardcodedPackageName(\n    packageName = EncryptionUtil.decrypt(\n        encryptedPackageName,\n        EncryptionUtil.generateKey(aesKey256)\n    )\n)\n\nprivate val aes256EncryptedHardcodedSignatures = HardcodedBase64EncodedSignature(\n    EncryptionUtil.decrypt(encryptedSignature, EncryptionUtil.generateKey(aesKey256))\n)\n</code></pre> <p>Where <code>7KAa2CFkhPQOUouDu32KZJLqOzGFbTTnJA3rGxMlAg4=</code> is the encrypted value of <code>com.kevlar.showcase</code>, and <code>+ylMx63kwFRmXKHQU0cbzyb8MJ1iiGW1g8+MjDRcS/o=</code> of <code>J+nqXLfuIO8B2AmhkMYHGE4jDyw=</code>.</p> <p>This ensures that there is no possibility that an automatic attack picks up the string as a package name or signature, and trivial string substitutions or encodings like base64 won't give any information away (the ciphertext is encoded in base64).</p> <p>AES128 or AES256 is recommended as the encryption algorithm (it's a little overkill but it does the job).</p> <p>The ciphertext may also be stored as a byte array.</p> Encryption utility <p>This tiny class (from the showcase module in the repository) is a basic AES encryption/decryption utility.</p> EncryptionUtil.kt<pre><code>import android.util.Base64\nimport javax.crypto.Cipher\nimport javax.crypto.SecretKey\nimport javax.crypto.spec.SecretKeySpec\n\nobject EncryptionUtil {\n    private const val algorithm = \"AES\"\n    private const val transformation = \"AES/ECB/PKCS5Padding\"\n\n    fun generateKey(key: String): SecretKey = SecretKeySpec(key.toByteArray(), algorithm)\n\n    fun encrypt(text: ByteArray, secret: SecretKey): String {\n        val cipher: Cipher = Cipher.getInstance(transformation).apply {\n            init(Cipher.ENCRYPT_MODE, secret)\n        }\n\n        return Base64.encodeToString(cipher.doFinal(text), Base64.NO_WRAP) ?: \"\"\n    }\n\n    fun decrypt(ciphertext: ByteArray, secret: SecretKey): String {\n        val cipher: Cipher = Cipher.getInstance(transformation).apply {\n            init(Cipher.DECRYPT_MODE, secret)\n        }\n\n        return String(cipher.doFinal(Base64.decode(ciphertext, Base64.NO_WRAP)), Charsets.UTF_8)\n    }\n}\n</code></pre> Bytecode <p>Here detecting and reconstructing the original package name automatically is basically impossible</p> <pre><code>L22\n ALOAD 0\n LDC \"4t7w!z%C*F-JaNcRfUjXn2r5u8x/A?Ds\"\n PUTFIELD com/kevlar/showcase/data/repo/IntegrityRepository.key256 : Ljava/lang/String;\nL23\n ALOAD 0\n LDC \"s3wf/AOYtr9BEMVFrweeLnkmerryUykMA8O77S5tMlI=\"\n ASTORE 3\n GETSTATIC kotlin/text/Charsets.UTF_8 : Ljava/nio/charset/Charset;\n ASTORE 4\nL24\n ALOAD 3\nL25\n ALOAD 4\n INVOKEVIRTUAL java/lang/String.getBytes (Ljava/nio/charset/Charset;)[B\n DUP\n LDC \"(this as java.lang.String).getBytes(charset)\"\n INVOKESTATIC kotlin/jvm/internal/Intrinsics.checkNotNullExpressionValue (Ljava/lang/Object;Ljava/lang/String;)V\nL26\n PUTFIELD com/kevlar/showcase/data/repo/IntegrityRepository.encryptedPackageName : [B\nL27\n ALOAD 0\n LDC \"tqMJquO3D+EKx1rx4R7/qzmsuEgpp1bKwxXe9AeB/WU=\"\n ASTORE 3\n GETSTATIC kotlin/text/Charsets.UTF_8 : Ljava/nio/charset/Charset;\n ASTORE 4\nL28\n ALOAD 3\nL29\n ALOAD 4\n INVOKEVIRTUAL java/lang/String.getBytes (Ljava/nio/charset/Charset;)[B\n DUP\n LDC \"(this as java.lang.String).getBytes(charset)\"\n INVOKESTATIC kotlin/jvm/internal/Intrinsics.checkNotNullExpressionValue (Ljava/lang/Object;Ljava/lang/String;)V\nL30\n PUTFIELD com/kevlar/showcase/data/repo/IntegrityRepository.encryptedSignature : [B\nL31\n ALOAD 0\n NEW com/kevlar/integrity/model/HardcodedMetadata\n DUP\nL32\n GETSTATIC com/kevlar/showcase/util/EncryptionUtil.INSTANCE : Lcom/kevlar/showcase/util/EncryptionUtil;\n ALOAD 0\n GETFIELD com/kevlar/showcase/data/repo/IntegrityRepository.encryptedPackageName : [B\n GETSTATIC com/kevlar/showcase/util/EncryptionUtil.INSTANCE : Lcom/kevlar/showcase/util/EncryptionUtil;\n ALOAD 0\n GETFIELD com/kevlar/showcase/data/repo/IntegrityRepository.key256 : Ljava/lang/String;\n INVOKEVIRTUAL com/kevlar/showcase/util/EncryptionUtil.generateKey (Ljava/lang/String;)Ljavax/crypto/SecretKey;\n INVOKEVIRTUAL com/kevlar/showcase/util/EncryptionUtil.decrypt ([BLjavax/crypto/SecretKey;)Ljava/lang/String;\nL33\n GETSTATIC com/kevlar/showcase/util/EncryptionUtil.INSTANCE : Lcom/kevlar/showcase/util/EncryptionUtil;\n ALOAD 0\n GETFIELD com/kevlar/showcase/data/repo/IntegrityRepository.encryptedSignature : [B\n GETSTATIC com/kevlar/showcase/util/EncryptionUtil.INSTANCE : Lcom/kevlar/showcase/util/EncryptionUtil;\n ALOAD 0\n GETFIELD com/kevlar/showcase/data/repo/IntegrityRepository.key256 : Ljava/lang/String;\n INVOKEVIRTUAL com/kevlar/showcase/util/EncryptionUtil.generateKey (Ljava/lang/String;)Ljavax/crypto/SecretKey;\n INVOKEVIRTUAL com/kevlar/showcase/util/EncryptionUtil.decrypt ([BLjavax/crypto/SecretKey;)Ljava/lang/String;\nL34\n INVOKESPECIAL com/kevlar/integrity/model/HardcodedMetadata.&lt;init&gt; (Ljava/lang/String;Ljava/lang/String;)V\n PUTFIELD com/kevlar/showcase/data/repo/IntegrityRepository.aes256EncryptedHardcodedMetadata : Lcom/kevlar/integrity/model/HardcodedMetadata;\n</code></pre>"},{"location":"pages/modules/integrity/implementation/#hashing","title":"Hashing","text":"<p>This hasn't been developed yet, but it may be possible to let kevlar know only the hash of your hardcoded data, and let it match directly on the runtime signatures and package names hashes. This would require multiple options of composite hash functions to be secure enough. It is not implemented.</p>"},{"location":"pages/modules/integrity/implementation/#initialization-attestations","title":"Initialization &amp; Attestations","text":"<p>You need to create a <code>KevlarIntegrity</code> instance (which is the way you will be requesting attestations), along with your desired parameters (either global, local or in your repository layer, if you are using MVVM/MVC).</p> <p>Once you have that, you just go ahead and call <code>integrity.attestate()</code> in a coroutine and your application running metadata will be checked, according to the provided parameters.</p> <p><code>IntegrityAttestation</code> will be returned from the call (it's a sealed class), containing the checks which failed, if any.</p> <p>Note that we will be initializing <code>KevlarIntegrity</code> with custom scan settings, but you could leave it as default.</p>"},{"location":"pages/modules/integrity/implementation/#in-place","title":"In-Place","text":"<p>This is the most concise (and complete) way to implement this package.</p> InPlace.kt<pre><code>/**\n * Base64 obfuscated package name and signature\n * */\n// Original value is \"com.kevlar.showcase\", the package name hardcoded value\nprivate val base64EncodedPackageName = \"\"\"Y29tLmtldmxhci5zaG93Y2FzZQ==\"\"\".toByteArray()\n\nprivate val base64ObfuscatedHardcodedPackageName = HardcodedPackageName(\n    packageName = Base64.decode(base64EncodedPackageName, Base64.DEFAULT).toString(Charsets.UTF_8)\n)\n\n\n\n// Original value is \"J+nqXLfuIO8B2AmhkMYHGE4jDyw=\", the signature hardcoded value\nprivate val base64EncodedSignature = \"\"\"SitucVhMZnVJTzhCMkFtaGtNWUhHRTRqRHl3PQ==\"\"\".toByteArray()\n\nprivate val base64ObfuscatedHardcodedSignatures = HardcodedBase64EncodedSignature(\n    Base64.decode(base64EncodedSignature, Base64.DEFAULT).toString(Charsets.UTF_8)\n)\n\n\n/**\n * Integrity package\n * */\nprivate val integrity = KevlarIntegrity {\n    checks {\n        packageName {\n            hardcodedPackageName(base64ObfuscatedHardcodedPackageName)\n        }\n\n        signature {\n            hardcodedSignatures(base64ObfuscatedHardcodedSignatures)\n        }\n\n        installer()\n        debug()\n    }\n}\n\n\n\n\n/**\n * Assestation request &amp; callback\n * +/\nCoroutineScope(Dispatchers.Default).launch {\n    // Attestation request\n    when (val attestation = integrity.attestate(context)) {\n        is IntegrityAttestation.Blank -&gt; {\n            // Pending attestation, no information yet. \n            // Don't do anything.\n        }\n        is IntegrityAttestation.Clear -&gt; {\n            // Good to go.\n        }\n        is IntegrityAttestation.Failed -&gt; {\n            // One or more checks have failed.\n        }\n    }\n}\n</code></pre> <p>This packs everything in one file. It is not excellent when writing a modern applications but it does its job.</p>"},{"location":"pages/modules/integrity/implementation/#viewmodel-repository-sharedflow-di-with-hilt","title":"ViewModel + Repository + SharedFlow + DI with Hilt","text":""},{"location":"pages/modules/integrity/implementation/#activity","title":"Activity:","text":"IntegrityActivity.kt<pre><code>@AndroidEntryPoint\nclass IntegrityActivity : AppCompatActivity() {\n\n    private val vm: ActivityViewModel by viewModels()\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n\n        lifecycleScope.launch {\n            lifecycle.repeatOnLifecycle(Lifecycle.State.STARTED) {\n                vm.attestation.collectLatest {\n                    when (it) {\n                        is IntegrityAttestation.Blank -&gt; {\n                            // Pending attestation, no information yet.\n                            // Don't do anything.\n                        }\n                        is IntegrityAttestation.Clear -&gt; {\n                            // Good to go.\n                        }\n                        is IntegrityAttestation.Failed -&gt; {\n                            // Pirate software detected.\n                        }\n                    }\n                }\n            }\n        }\n\n        CoroutineScope(Dispatchers.Main).launch {\n            vm.requestAttestation()\n        }\n    }\n}\n</code></pre>"},{"location":"pages/modules/integrity/implementation/#view-model","title":"View model:","text":"ActivityViewModel.kt<pre><code>@HiltViewModel\nclass ActivityViewModel @Inject constructor(\n    private val integrityRepository: IntegrityRepository\n) : ViewModel() {\n    private val _attestation = MutableStateFlow(KevlarIntegrity.blankAttestation())\n\n    internal val attestation: SharedFlow&lt;IntegrityAttestation&gt; = _attestation.stateIn(\n        viewModelScope,\n        SharingStarted.Eagerly,\n        initialValue = KevlarIntegrity.blankAttestation()\n    )\n\n    fun requestAttestation() {\n        viewModelScope.launch {\n            _attestation.value = integrityRepository.attestate()\n        }\n    }\n}\n</code></pre>"},{"location":"pages/modules/integrity/implementation/#repository","title":"Repository","text":"IntegrityRepository.kt<pre><code>class IntegrityRepository @Inject constructor(\n    @ApplicationContext val context: Context,\n    @IoDispatcher val externalDispatcher: CoroutineDispatcher\n) {\n    /**\n     * Base64 obfuscated package name\n     * */\n    private val base64PackageName = \"\"\"Y29tLmtldmxhci5zaG93Y2FzZQ==\"\"\".toByteArray()\n    private val base64Signature = \"\"\"SitucVhMZnVJTzhCMkFtaGtNWUhHRTRqRHl3PQ==\"\"\".toByteArray()\n\n\n    private val base64ObfuscatedHardcodedPackageName = HardcodedPackageName(\n        packageName = Base64.decode(base64PackageName, Base64.DEFAULT).toString(Charsets.UTF_8)\n    )\n\n    private val base64ObfuscatedHardcodedSignatures = HardcodedBase64EncodedSignature(\n        Base64.decode(base64Signature, Base64.DEFAULT).toString(Charsets.UTF_8)\n    )\n\n\n    /**\n     * Integrity package\n     * */\n    private val integrity = KevlarIntegrity {\n        checks {\n            packageName {\n                hardcodedPackageName(base64ObfuscatedHardcodedPackageName)\n            }\n\n            signature {\n                hardcodedSignatures(base64ObfuscatedHardcodedSignatures)\n            }\n\n            installer()\n            debug()\n        }\n    }\n\n    suspend fun attestate(): IntegrityAttestation = withContext(externalDispatcher) {\n        integrity.attestate(context)\n    }\n}\n</code></pre>"},{"location":"pages/modules/integrity/integrity/","title":"Integrity","text":"<pre><code>graph LR\n  I[Inizialization] -.Settings..-&gt; K{KevlarIntegrity};\n  DB([Hardcoded &amp; Obfuscated Metadata]) === K\n  AR1[Attestation Requests] --&gt; K\n  K --&gt; |Clear| P[Passed];\n  K --&gt; |Failed| NP[Not Passed];\n  P --&gt; A[IntegrityAssestation]\n  NP --&gt; A</code></pre> <p>The integrity package contains tools for the detection of tampering attempts against your app.</p> <p>It requires a bit of effort to implement (you need to find, code and obfuscate your app metadata, all the instructions are in implementation), but once you have it runs quickly and works extremely well.</p> <p>It is capable of detecting:</p> <ul> <li>Signature mismatches (the running app's signature and the hardcoded signature are different)</li> <li>Package name mismatches (the running app's package name and the hardcoded package name are different)</li> <li>Debuggable flag (the running app is debuggable, which should never happen for production apps)</li> <li>Disallowed Installers (the running app has been installed through a disallowed package installer)</li> </ul> <p>Purpose of the <code>integrity</code> package</p> <p>You want to use this package if you need to give your app a layer of protection against tampering attacks (see anatomy for more details). Enabling just a few checks and implementing basic obfuscation will make your app harder to crack.</p> <p>Warning</p> <p>This package is the best defense against automatic and/or unskilled attacks.  If implemented well, it will kill off most of them</p> <p>To implement this, you initialize <code>KevlarIntegrity</code> and provide your desired settings (which influence what is to be checked and what not). Then you can submit attestation requests (which will be executed according to your settings).</p>"},{"location":"pages/modules/integrity/integrity/#attestation-process-overview","title":"Attestation process overview","text":"<p>When you require an attestation (through <code>integrity.attestate(context)</code>), kevlar executes the following operations:</p> <ol> <li>Depending on what integrity checks you selected, the appropriate battery of tests for those targets is initialized and run;</li> <li>The results are collected, processed, filtered, and returned.</li> </ol> <p>There is only one type of attestation that can be produced.</p> <p>The attestation is returned in <code>IntegrityAttestation</code> (it is a sealed class), which depending on the detection status can be of three types:</p> <ul> <li><code>Blank</code>: This is a non-processed status. It should not be interpreted, as it does not carry any meaning about the attestation result. It is not to be interpreted as <code>Clear</code>;</li> <li><code>Clear</code>: The attestation has passed. There is nothing to report. This means that no system modification/status has triggered the detection from the battery of tests that have been executed, in compliance with the given check parameters;</li> <li><code>Failed</code>: The attestation has not passed. Integrity or tampering issues have been detected. You can check which check has failed (which inconsistency has been found between the hardcoded and runtime values) in the attestation result.</li> </ul> <p>Warning</p> <p><code>Blank</code> is completely different from <code>Clear</code> (or <code>Failed</code>). It means that the software is initialized but that nothing has been done yet. Do not mix them up.</p>"},{"location":"pages/modules/integrity/integrity/#configuring-kevlarintegrity","title":"Configuring <code>KevlarIntegrity</code>","text":"<p>The integrity module requires attentive and detailed configuration (since kevlar needs the \"real\" data that will be compared at against the runtime values when your app executes).  You can find details on the process of configuring and retrieving the necessary data in the implementation page.</p> <p>Thus there are no default configuration: you have to manually specify each item through the DSL.</p> Manual configuration (simplified)<pre><code>private val integrity = KevlarIntegrity {\n    checks {\n        packageName() {\n            // Allowed package name\n            hardcodedPackageName(\"com.kevlar.showcase\")\n        }\n        signature() {\n            // Allowed signature\n            hardcodedSignatures(\"J+nqXLfuIO8B2AmhkMYHGE4jDyw=\")\n        }\n        debug()\n        installer()\n    }\n}\n</code></pre> <p>You can find more information about each individual item in the reference page.</p> <p>The settings are additive. If you leave a blank DSL, nothing will be detected, because no checks will be run, because the settings are empty.</p> Empty<pre><code>private val integrity = KevlarIntegrity {\n    checks {}\n}\n</code></pre>"},{"location":"pages/modules/integrity/integrity/#use-cases","title":"Use cases","text":"<p>This is a pretty typical scenario for any application where it is critical to preserve self-integrity and run unmodified code.</p>"},{"location":"pages/modules/integrity/reference/","title":"Reference","text":"<p>The complete integrity configuration is as follows.</p> Complete settings<pre><code>private val integrity = KevlarIntegrity {\n    checks {\n        packageName() {\n            // Allowed package name\n            hardcodedPackageName(\"com.kevlar.showcase\")\n        }\n        signature() {\n            // Allowed signature\n            hardcodedSignatures(\"J+nqXLfuIO8B2AmhkMYHGE4jDyw=\")\n        }\n\n        debug()\n        installer()\n    }\n}\n</code></pre> <p>Once you require the attestation through <code>attestate(context)</code>, any integrity mismatch that you requested  will be included in the attestation.</p> <pre><code>withContext(externalDispatcher) {\n    val attestation = integrity.attestate(context)\n}\n</code></pre>"},{"location":"pages/modules/integrity/reference/#package-name-check","title":"Package name check","text":"<p>The <code>packageName()</code> function tells kevlar to enable the integrity checks for the application package name.</p> <p>This is a parametric setting, since kevlar needs to know what is the \"right\" application package name is. Once kevlar has all the required data it is able to differentiate between genuine and tampered binaries.</p> <pre><code>private val integrity = KevlarIntegrity {\n    checks {\n        packageName() {\n            // Allowed package name\n            hardcodedPackageName(\"com.kevlar.showcase\")\n        }\n        signature() {\n            // Allowed signature\n            hardcodedSignatures(\"J+nqXLfuIO8B2AmhkMYHGE4jDyw=\")\n        }\n\n        debug()\n        installer()\n    }\n}\n</code></pre> <p>You can find instruction on where to find the right parameters in implementation. In this case you simply have to pass in the package name of your app, so kevlar knows what is the right package.</p>"},{"location":"pages/modules/integrity/reference/#signature-check","title":"Signature check","text":"<p>The <code>signature()</code> function tells kevlar to enable the integrity checks for the application signature.</p> <p>This is a parametric setting, since kevlar needs to know what is the \"right\" application signature is. Once kevlar has all the required data it is able to differentiate between genuine and tampered binaries.</p> <pre><code>private val integrity = KevlarIntegrity {\n    checks {\n        packageName() {\n            // Allowed package name\n            hardcodedPackageName(\"com.kevlar.showcase\")\n        }\n        signature() {\n            // Allowed signature\n            hardcodedSignatures(\"J+nqXLfuIO8B2AmhkMYHGE4jDyw=\")\n        }\n\n        debug()\n        installer()\n    }\n}\n</code></pre> <p>You can find instruction on where to find the right parameters in implementation.</p>"},{"location":"pages/modules/integrity/reference/#debug-check","title":"Debug check","text":"<p>The <code>debug()</code> function tells kevlar to enable integrity debug checks.</p> <pre><code>private val integrity = KevlarIntegrity {\n    checks {\n        packageName() {\n            // Allowed package name\n            hardcodedPackageName(\"com.kevlar.showcase\")\n        }\n        signature() {\n            // Allowed signature\n            hardcodedSignatures(\"J+nqXLfuIO8B2AmhkMYHGE4jDyw=\")\n        }\n\n        debug()\n        installer()\n    }\n}\n</code></pre> <p>If debug flags are found on your application it will be reported.</p>"},{"location":"pages/modules/integrity/reference/#installer-check","title":"Installer check","text":"<p>The <code>installer()</code> function tells kevlar to enable installer checks.</p> <p>Since android R, google introduced APIs to check the original installer of a certain package. With this check, you can instruct kevlar to analyze that installer (if available) and detect whether it is allowed or not by your security policy.</p> <p>In this case, the only allowed installer package is the Google Play Store, but you can always add more through the <code>allowInstaller</code> function.</p> <pre><code>private val integrity = KevlarIntegrity {\n    checks {\n        packageName() {\n            // Allowed package name\n            hardcodedPackageName(\"com.kevlar.showcase\")\n        }\n        signature() {\n            // Allowed signature\n            hardcodedSignatures(\"J+nqXLfuIO8B2AmhkMYHGE4jDyw=\")\n        }\n\n        debug()\n        installer() {\n            allowInstaller(\"com.sec.android.app.samsungapps\")\n        }\n    }\n}\n</code></pre>"},{"location":"pages/modules/rooting/implementation/","title":"Implementation","text":"<p>A working example for the rooting module can be found in the github repository under the <code>:showcase</code> module.</p>"},{"location":"pages/modules/rooting/implementation/#dependency","title":"Dependency","text":"Gradle <pre><code>dependencies {\n    implementation \"io.github.kevlar-kt:rooting:1.1.1\"\n}\n</code></pre> Kotlin DSL <pre><code>dependencies {\n    implementation(\"io.github.kevlar-kt:rooting:1.1.1\")\n}\n</code></pre> Maven <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;io.github.kevlar-kt&lt;/groupId&gt;\n    &lt;artifactId&gt;rooting&lt;/artifactId&gt;\n    &lt;version&gt;1.1.1&lt;/version&gt;\n    &lt;type&gt;pom&lt;/type&gt;\n&lt;/dependency&gt;\n</code></pre> <p>The rooting module uses libsu to execute shell commands. You may need to include it in your app's dependencies like so:</p> libsu dependency <pre><code>dependencies {\n    def libsuVersion = \"5.2.0\"\n    implementation \"com.github.topjohnwu.libsu:core:${libsuVersion}\"\n}\n</code></pre>"},{"location":"pages/modules/rooting/implementation/#initialization-attestations","title":"Initialization &amp; Attestations","text":"<p>You need to create a <code>KevlarRooting</code> instance (which is the way you will be requesting attestations), along with your desired parameters (either global, local or in your repository layer, if you are using MVVM/MVC).</p> <p>The <code>rooting</code> package has 2 attestations: <code>TargetRootingAttestation</code> and <code>StatusRootingAttestation</code>. Depending on what your security requirements impose, you may need to run one or both checks.</p> <p>You go ahead and request whichever attestation(s) you need. The will produce two different sealed classes (since the results will be different in case of failure, the attestations will contain different data).</p> <p>We go ahead and create a working single-attestation example (for system modifications aka targets). For two attestations refer to the sample code in the <code>:showcase</code> module of the github repository.</p>"},{"location":"pages/modules/rooting/implementation/#configuration","title":"Configuration","text":"<p>As we said, the kinds of checks you can run are divided in two different categories, <code>targets</code> and <code>status</code>. The first is to check for eventual system modification, the former to check for eventual in-system status.</p> <p>The following complete configuration runs every check that kevlar disposes.</p> <p>In details:</p> <ul> <li><code>flagPermissive()</code>, if enabled, will report <code>DetectableSystemStatus.SELINUX</code> also if selinux status is set to permissive status (which is a stricter criteria), while by default it will only trip if selinux is disabled;</li> <li><code>allowExplicitRootCheck()</code>, if enabled, will use more aggressive checks to determine if any of the required targets is installed, including explicitly trying to acquire root access.</li> </ul> <pre><code>private val rooting = KevlarRooting {\n    targets {\n        root()\n        magisk()\n        busybox()\n        xposed()\n    }\n\n    allowExplicitRootCheck()\n\n    status {\n        testKeys()\n        emulator()\n        selinux {\n            flagPermissive()\n        }\n    }\n}\n</code></pre>"},{"location":"pages/modules/rooting/implementation/#in-place","title":"In-Place","text":"<p>This is the most concise way to implement rooting.</p> InPlace.kt<pre><code>val rooting = KevlarRooting {\n    targets {\n        root()\n        busybox()\n    }\n}\n\n\nCoroutineScope(Dispatchers.Default).launch {\n    // Attestation request\n    when (val attestation = rooting.attestateTargets(context)) {\n        is TargetRootingAttestation.Blank -&gt; {\n            // Pending attestation, no information yet. \n            // Don't do anything.\n        }\n        is TargetRootingAttestation.Clear -&gt; {\n            // Good to go.\n        }\n        is TargetRootingAttestation.Failed -&gt; {\n            // System modifications detected.\n        }\n    }\n}\n</code></pre>"},{"location":"pages/modules/rooting/implementation/#viewmodel-repository-sharedflow-di-with-hilt","title":"ViewModel + Repository + SharedFlow + DI with Hilt","text":""},{"location":"pages/modules/rooting/implementation/#activity","title":"Activity:","text":"RootingActivity.kt<pre><code>@AndroidEntryPoint\nclass RootingActivity : AppCompatActivity() {\n\n    private val vm: ActivityViewModel by viewModels()\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n\n        lifecycleScope.launch {\n            lifecycle.repeatOnLifecycle(Lifecycle.State.STARTED) {\n                vm.taregtsAttestation.collectLatest {\n                    when (it) {\n                        is TargetRootingAttestation.Blank -&gt; {\n                            // Pending attestation, no information yet.\n                            // Don't do anything.\n                        }\n                        is TargetRootingAttestation.Clear -&gt; {\n                            // Good to go.\n                        }\n                        is TargetRootingAttestation.Failed -&gt; {\n                            // Pirate software detected.\n                        }\n                    }\n                }\n            }\n        }\n\n        CoroutineScope(Dispatchers.Main).launch {\n            vm.requestTargetsAttestation()\n        }\n    }\n}\n</code></pre>"},{"location":"pages/modules/rooting/implementation/#view-model","title":"View model:","text":"ActivityViewModel.kt<pre><code>@HiltViewModel\nclass ActivityViewModel @Inject constructor(\n    private val securityRepository: RootingRepository\n) : ViewModel() {\n\n    private val _targetAttestationState = MutableStateFlow(KevlarRooting.blankTargetAttestation())\n\n    val targetAttestation: SharedFlow&lt;TargetRootingAttestation&gt; = _rootAttestationState.stateIn(\n        viewModelScope,\n        SharingStarted.Eagerly,\n        initialValue = KevlarRooting.blankTargetAttestation()\n    )\n\n    fun requestTargetsAttestation() {\n        viewModelScope.launch {\n            _rootAttestationState.value = rootingRepository.attestateRoot()\n        }\n    }\n}\n</code></pre>"},{"location":"pages/modules/rooting/implementation/#repository","title":"Repository","text":"RootingRepository.kt<pre><code>class RootingRepository @Inject constructor(\n    @ApplicationContext val context: Context,\n    @IoDispatcher val externalDispatcher: CoroutineDispatcher\n) {\n    private val rooting = KevlarRooting {\n        targets {\n            root()\n            busybox()\n        }\n    }\n\n    suspend fun attestateRoot(): TargetRootingAttestation = withContext(externalDispatcher) {\n        rooting.attestateTargets(context)\n    }\n}\n</code></pre>"},{"location":"pages/modules/rooting/internals/","title":"Internals","text":"<p>Detecting system targets and statuses is easy and difficult at the same time. There are conditions which are really simple and only require a quick binary check to determine.  There are other kind of features which are harder to identify and classify reliably, given how different they get across the spectrum of versions of android, versions of the feature and settings of the feature.</p>"},{"location":"pages/modules/rooting/internals/#binary-dumping","title":"Binary dumping","text":"<p>For a lot of features we can check if the associated binary executable is present. If it is, then we consider that the feature is present as well. This check can be ran at different permission levels with different results.</p>"},{"location":"pages/modules/rooting/internals/#custom-checking","title":"Custom checking","text":"<p>Xposed framework requires a specific check on a system file to determine whether it is active or not.</p>"},{"location":"pages/modules/rooting/internals/#notes","title":"Notes","text":"<p>The <code>rooting</code> module relies on libsu for shell command execution.  This may be a debatable choice, but it is one of the only well-written libraries and it works both efficiently and reliably. The alternative would have been implementing a custom shell execution mechanism, which is not hard to do, but it is hard to do well.</p>"},{"location":"pages/modules/rooting/reference/","title":"Reference","text":"<p>The complete rooting configuration is as follows.</p> Complete Rooting settings<pre><code>private val rooting = KevlarRooting {\n    targets {\n        root()\n        magisk()\n        busybox()\n        xposed()\n    }\n\n    status {\n        testKeys()\n        emulator()\n        selinux {\n            flagPermissive()\n        }\n    }\n\n    allowExplicitRootCheck()\n}\n</code></pre> <p>Warning</p> <p>Bear in mind, this kind of configuration is exhaustive and should be used just in a few cases where you really need to detect all of those conditions. Only including what your application's security environment requires is a key step in properly configuring the library.</p> <p>Unlike other Kevlar modules, here you can actually require two different types of attestation: you have <code>attestateTargets</code> and <code>attestateRooting</code>. Once you require the attestation through any of those two methods, any discrepancies between your expected configuration (w.r.t. the invoked attestation type) and the actual device status will be reported back to you.</p> <pre><code>withContext(externalDispatcher) {\n    val targetAttestation = rooting.attestateTargets(context)\n    val statusAttestation = rooting.attestateStatus()\n}\n</code></pre>"},{"location":"pages/modules/rooting/rooting/","title":"Rooting","text":"<pre><code>graph LR\n  I[Inizialization] -.Settings..-&gt; K{KevlarRooting};\n  DB([Android OS]) === K\n  AR1[Target Attestation Requests] --&gt; K\n  AR2[Status Attestation Requests] --&gt; K\n  K --&gt; |Clear| P[Passed];\n  K --&gt; |Failed| NP[Not Passed];\n  P --&gt; A1[TargetAssestation]\n  NP --&gt; A1\n  P --&gt; A2[StatusAttestation]\n  NP --&gt; A2</code></pre> <p>The rooting package contains tools for the detection of system modifications that may be active on the device running your app.</p> <p>Once configured with settings, the package can quickly run different batteries of tests on the operative system (through shell commands) to check if the target modifications are present on the device.</p> <p>It produces two different kinds of attestations: one searching for system modification and one for system conditions.</p> <p>It is capable of detecting the following system modifications (through the <code>targets</code> attestation)</p> <ul> <li>Root access;</li> <li>Magisk installations (not hidden);</li> <li>Busybox binaries;</li> <li>Toybox binaries;</li> <li>Xposed framework.</li> </ul> <p>And the following system conditions (through the <code>status</code> attestation)</p> <ul> <li>Emulator execution;</li> <li>Test keys;</li> <li>SELinux status.</li> </ul> <p>Depending on what you need to check, you may choose one or run both.</p> <p>Purpose of the <code>rooting</code> package</p> <p>You may want to use this package if you care about the system-wide security status, or if you consider that your application running on rooted/modified devices is a security risk.</p> <p>Notation</p> <p>In the rooting package, the words \"target\" and \"status\" are used loosely, but they actually have a special meaning. <code>Targets</code> means system modification. Something that may be installed (and detectable) over the operating system. It is a kind of add-on, a custom software component. <code>Status</code> means a system condition. Something that is itself part of the operating system out of the box, and whose status we want to check.</p> <p>To implement this, you initialize <code>KevlarRooting</code> and provide your desired settings (which influence what is to be checked and what not). Then you can submit attestation requests of whichever kind you prefer (which will be executed according to your settings).</p>"},{"location":"pages/modules/rooting/rooting/#attestation-process-overview","title":"Attestation process overview","text":"<p>This package can produce two different kinds of attestations: a <code>TargetAssestation</code> and a <code>StatusAttestation</code>.</p> <p>When you require an attestation, kevlar performs the following operations:</p> <ul> <li> <p>for the targets attestation (through <code>rooting.attestateTargets(context)</code>):</p> <ol> <li>Depending on what system modification you selected, the appropriate battery of tests for that system modification is initialized and run;</li> <li>The results are collected, processed, filtered, and returned.</li> </ol> </li> <li> <p>for the status attestation (through <code>rooting.attestateStatus()</code>):</p> <ol> <li>Depending on what system condition you selected, the appropriate check for that system status flag is initialized and ran;</li> <li>The results are collected, processed, filtered, and returned.</li> </ol> </li> </ul> <p>The attestation is returned either in <code>TargetRootingAttestation</code> or <code>StatusRootingAttestation</code> (both are sealed classes), which depending on the detection status can be of three types (with different fields):</p> <ul> <li><code>Blank</code>: This is a non-processed status. It should not be interpreted, as it does not carry any meaning about the attestation result. It is not to be interpreted as <code>Clear</code>;</li> <li><code>Clear</code>: The attestation has passed. There is nothing to report. This means that no system modification/status has triggered the detection from the battery of tests that have been executed, in compliance with the given scan parameters;</li> <li><code>Failed</code>: The attestation has not passed. A target/status has been detected. You can read which one has tripped the detection in the attestation result.</li> </ul> <p>Warning</p> <p><code>Blank</code> is completely different from <code>Clear</code> (or <code>Failed</code>). It means that the software is initialized but that nothing has been done yet. Do not mix them up.</p>"},{"location":"pages/modules/rooting/rooting/#configuring-kevlarrooting","title":"Configuring <code>KevlarRooting</code>","text":"<p>Configuring the rooting module requires a bit of android technical knowledge, since you have to be aware of which items you are enabling.</p> <p>You may choose to configure the rooting module manually (using the dedicated DSL, more flexibility), or just grabbing one of the default configurations (which are the most commonly used and don't need DSL configuration)</p> Manual DSL Configuration<pre><code>private val rooting = KevlarRooting {\n    targets {\n        root()\n        magisk()\n        busybox()\n    }\n\n    status {\n        emulator()\n        selinux {\n            flagPermissive()\n        }\n    }\n\n    allowExplicitRootCheck()\n}\n</code></pre> Default Configuration<pre><code>private val rooting = KevlarRooting.Defaults.Standard()\n</code></pre> <p>You can find more information about each individual item in the reference page.</p> <p>The settings are additive. If you leave a blank DSL, nothing will be detected, because no checks will be run, because the settings are empty.</p> Empty<pre><code>private val rooting = KevlarRooting {\n    targets {}\n    status {}\n}\n</code></pre> Default<pre><code>private val rooting = KevlarRooting()\n</code></pre>"},{"location":"pages/modules/rooting/rooting/#use-cases","title":"Use cases","text":"<p>This is a pretty typical scenario for any banking/financial application, game, or software managing sensitive resources (files, records, data)</p>"},{"location":"pages/overview/anatomy_of_attacks/","title":"Anatomy of an attack against an Android app","text":"<p>This is a general informal introductory text detailing the most well-known and used attack techniques against Android apps.</p> <p>We will start with the most basic and gradually build up to the most skilled ones.  Attack techniques are presented in order of time taken to employ (weaponize) them successfully against an unguarded application.</p> <p>While being different in shape and form, all the attacks follow the same basic principle: you have a target application that we want to attack (with a target in mind. Usually bypassing certain mechanisms, overriding rules, or adding/removing features), which is decompiled, then analyzed; its bytecode is modified according to the target of the attack (a payload is inserted, safety checks are removed, code is altered or replaced), then it all gets recompiled, repackaged and possibly resigned into an apk file which is installed and run.</p> <p>Popular tools for this are apktool on desktop and ApkEditor on mobile.</p> <p>Warning</p> <p>This page tends to be a little subjective because there is not a science studying those things and I am not an expert in this field, so take everything with a grain of salt.</p>"},{"location":"pages/overview/anatomy_of_attacks/#0-automatic-patching","title":"0: Automatic patching","text":"<p>This is by far the most common since (once the engine is ready) it is done completely automatically, without any human intervention or brainpower.</p> <p>There are various pirate apps able to perform this to some extent (most notably Lucky Patcher).  They all more or less all use a string-matching engine to perform a (very sophisticated) pattern \"find-and-replace\" over your application bytecode.</p> <p>This is done to achieve what the target of the attack is: it may be removing advertising from your app, changing signature verification, disabling or enabling some features, inhibiting security mechanisms, or purchasing protection. The target determines the pattern used to do the dirty work. Then the app is rebuilt and it's done.</p> <p>It is the lowest form of attack since the software itself does not know what it is doing exactly but follows a general rule set. But this does not render it any less dangerous: if your software is unprepared, you will fall for this.</p> <p>Against this level of attack you can employ all kevlar's arsenal with the <code>antipiracy</code> and <code>integrity</code> packages.  Kevlar has more or less been built and designed to fight this kind of attack, by performing safety checks over your package metadata and giving you runtime warnings for the presence of malicious software which is interfering or directing your app.</p> <p>The nice thing (for us developers) is that the automation of the attack is very hard to do, even on a basic level, and putting up barriers for this is comparatively quick.</p>"},{"location":"pages/overview/anatomy_of_attacks/#1-unskilled-custom-attacks","title":"1: Unskilled custom attacks","text":"<p>This tends to be a less likely kind of attack because an actual human brain is looking at your decompiled bytecode and trying to figure out what needs to be done to achieve its goal.</p> <p>When I say unskilled I mean done by amateurs without in-depth knowledge of the techniques involved.</p> <p>They will essentially be manually searching through your bytecode and looking for code pieces that they recognize and want to remove/edit/expand. This is usually done by searching a determinate resource, which is referenced somewhere in the code, finding that code, and trying to change its logic.</p> <p>Bytecode note</p> <p>Bytecode is the raw language that the JVM executes.  In Android, everything shifts from JVM to ART but it's the same thing.</p> <p>There are reconstruction utilities, which will try to take the bytecode and un-compile it to grab the original source code. Most likely that is what an attacker might want to be looking at.</p> <p>Obfuscation</p> <p>A machine does not care whether your code is obfuscated. A human brain does. You should always heavily shrink, optimize and obfuscate your production code (i.e. using ProGuard on release builds) to make it harder for attackers to make sense of it.</p>"},{"location":"pages/overview/anatomy_of_attacks/#2-root-access-enabled-attacks","title":"2: Root access enabled attacks","text":"<p>When a device is rooted, there are a whole lot of new variables to take into account when looking at security, since the operating system itself is compromised and will obey the user commands.</p> <p>It's not like you can do a lot if you are running on that system, but what you can do is preemptively disable some application features to protect them from modification, if applicable and necessary according to your security standards.</p> <p>That's what a lot of games or bank software do since they are targeted by custom attacks that can, with the help of root access, alter the application behavior without having to recompile it (on the fly). Either they shut down completely or they inhibit come functionality. Casing point every Supercell game.</p> <p>Data editing</p> <p>An easy way to crack many (not well secured) applications is by editing the files (XML SharedPreferences or SQLite databases) on which they store data. I've seen countless <code>\"is_pro\"</code> strings inside SharedPreferences or XML/JSON settings where you can enable paid features without the app checking it, and it only takes a few bytes flips to have complete access to anything you want.</p> <p>That specific attack can be made harder by encrypting and obfuscating your application preference strings.</p>"},{"location":"pages/overview/anatomy_of_attacks/#3-professional-custom-attack","title":"3: Professional custom attack","text":"<p>There is very little to say here: if someone knows what he/she is doing, they are going to strip away every bit of self-checking and security controls you put in place, and they will implement whatever target they have.</p> <p>While obfuscation helps, security through obscurity should not even be an option, and other techniques will make it harder to decipher what your code does, eventually, a determined mind will find a way to do what it wants to, and there is nothing you can do about it. After all, if you can modify your code to write software that adheres to the attack targets, so can they.</p> <p>Cracked software distribution</p> <p>Every commercial app I wrote that surpassed about 100k downloads (TurboUnfollow and Androoster) has been custom patched and redistributed on the internet. This happens regularly and, while being sad, is a reminder that perfect security protection does not exist. </p> <p>This happens because you do not have control over the device your user is running your app on. It stops being your control when the bytes are transferred and installed as a package on the device, then they are binary data open for modifications and hacks. The only efficient way to mitigate this is by regulating what you have control over. Server-side access and APIs, data validation, in-house or professional security checks, and so on, will limit the control your app has over its working and puts it in your secure hands.</p>"},{"location":"pages/overview/anatomy_of_attacks/#extra-concepts","title":"Extra concepts","text":""},{"location":"pages/overview/anatomy_of_attacks/#conditional-consistency","title":"Conditional Consistency","text":"<p>It is a little bit meta to talk about your application code being modified, either by recompilation or root attacks, since you can not know how it will be changed. This process can introduce all sorts of discrepancies and inconsistencies in the newly created software. </p> <p>Coding software with conditional consistency is a practice where you insert security checks that can tell when the software is itself not genuine or modified. And while ALL those checks can theoretically be stripped away or disabled, this makes it harder to find them all and avoid detection.</p> <p>This is a bit overkill for android apps, but more advanced software uses those concepts to add extra nets of protection.</p>"},{"location":"pages/overview/attitude/","title":"Attitude","text":"<p>Kevlar may be used in some instances to gather information and eventually act upon them in ways that can be considered immoral or unjust. Namely, denying service (or parts of service) to some users or systems is a controversial decision.</p> <p>Kevlar is only a tool, and as such has no behaviour or attitude embedded within it.</p> <p>Developers using this library or implementing similar behaviours should choose carefully what to do after the data has been gathered.</p> <p>There is a broad spectrum of opinions regarding this topic.  On one end, people will want full freedom and access over the device they bought and use daily, and they are right. On the other end, developers do not want their software to be pirated, hacked, cracked, bypassed, abused as this has negative consequences all around the app, and they are right. </p> <p>Personally I think it depends on what kind of detection you implement: If I try to crack a software and said software doesn't let me I'd feel angry but I know I'm doing something wrong, which would damage the developers.  On the other hand, apps denying service because I have a custom ROM or a magisk rooted phone when I had no intention of doing anything really would make me angry.</p> <p>But you shouldn't really care about what my personal views are regarding the matter, you should do what is best for your software.</p>"},{"location":"pages/overview/choosing/","title":"Choosing packages","text":"<p>Kevlar's flexible infrastructure allows for very granular and efficient configuration.</p> <p>it is divided in 3 packages, each targeting a specific scope (system-wise security, user-wise security and app-wise security), and within each package you have fully customizable attestation checks. </p> <p>This is done to help you reach your desired security level and only bundle in your app what you need.</p>"},{"location":"pages/overview/dependencies_integration/","title":"Dependencies and Integration","text":""},{"location":"pages/overview/dependencies_integration/#publishing","title":"Publishing","text":"<p>All the dependencies are published on MavenCentral. Make sure to have it included in your <code>reporitories</code> block in the top level <code>build.gradle</code> file.</p> <pre><code>repositories {\n    mavenCentral()\n}\n</code></pre>"},{"location":"pages/overview/dependencies_integration/#project-requirements","title":"Project Requirements","text":"<ul> <li>Java 8+ is required;     <pre><code>compileOptions {\n    sourceCompatibility JavaVersion.VERSION_1_8\n    targetCompatibility JavaVersion.VERSION_1_8\n}\n</code></pre></li> <li><code>minSdk</code> 19+ is required.</li> </ul>"},{"location":"pages/overview/dependencies_integration/#antipiracy","title":"Antipiracy","text":"Gradle <pre><code>dependencies {\n    implementation \"io.github.kevlar-kt:antipiracy:1.1.1\"\n}\n</code></pre> Kotlin DSL <pre><code>dependencies {\n    implementation(\"io.github.kevlar-kt:antipiracy:1.1.1\")\n}\n</code></pre> Maven <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;io.github.kevlar-kt&lt;/groupId&gt;\n    &lt;artifactId&gt;antipiracy&lt;/artifactId&gt;\n    &lt;version&gt;1.1.1&lt;/version&gt;\n    &lt;type&gt;pom&lt;/type&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"pages/overview/dependencies_integration/#rooting","title":"Rooting","text":"Gradle <pre><code>dependencies {\n    implementation \"io.github.kevlar-kt:rooting:1.1.1\"\n}\n</code></pre> Kotlin DSL <pre><code>dependencies {\n    implementation(\"io.github.kevlar-kt:rooting:1.1.1\")\n}\n</code></pre> Maven <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;io.github.kevlar-kt&lt;/groupId&gt;\n    &lt;artifactId&gt;rooting&lt;/artifactId&gt;\n    &lt;version&gt;1.1.1&lt;/version&gt;\n    &lt;type&gt;pom&lt;/type&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"pages/overview/dependencies_integration/#integrity","title":"Integrity","text":"Gradle <pre><code>dependencies {\n    implementation \"io.github.kevlar-kt:integrity:1.1.1\"\n}\n</code></pre> Kotlin DSL <pre><code>dependencies {\n    implementation(\"io.github.kevlar-kt:integrity:1.1.1\")\n}\n</code></pre> Maven <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;io.github.kevlar-kt&lt;/groupId&gt;\n    &lt;artifactId&gt;integrity&lt;/artifactId&gt;\n    &lt;version&gt;1.1.1&lt;/version&gt;\n    &lt;type&gt;pom&lt;/type&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"pages/overview/material/","title":"Technical Material","text":""},{"location":"pages/overview/material/#prevention-material-checking-tamper-detection","title":"Prevention material, checking &amp; tamper detection","text":"<ul> <li>https://www.airpair.com/android/posts/adding-tampering-detection-to-your-android-app</li> <li>https://en.wikipedia.org/wiki/Security_through_obscurity;</li> <li>https://darvincitech.wordpress.com/2020/03/01/yet-another-tamper-detection-in-android/;</li> <li>https://medium.com/avi-parshan-studios/protecting-your-android-app-against-reverse-engineering-and-tampering-a727768b2e9e;</li> <li>https://medium.com/@mplacona/tampering-detection-in-android-d213998ecc4f</li> <li>https://developer.android.com/google/play/integrity</li> <li>https://developer.android.com/training/safetynet/index.html;</li> <li>https://www.indusface.com/learning/how-to-implement-root-detection-in-android-applications/;</li> <li>https://stackoverflow.com/questions/33850864/how-to-verify-purchase-for-android-app-in-server-side-google-play-in-app-billin.</li> </ul>"},{"location":"pages/overview/material/#server-side-checks","title":"Server-Side checks","text":"<ul> <li>https://developer.android.com/training/safetynet;</li> <li>https://medium.com/@lahirumaramba/protecting-your-own-backend-services-with-firebase-app-check-1daaef229f32.</li> </ul>"},{"location":"pages/overview/material/#attack-vectors","title":"Attack vectors","text":"<ul> <li>https://mobile-security.gitbook.io/mobile-security-testing-guide/android-testing-guide/0x05c-reverse-engineering-and-tampering.</li> </ul>"},{"location":"pages/overview/material/#code","title":"Code","text":"<ul> <li>https://gist.github.com/scottyab/b849701972d57cf9562e;</li> <li>https://github.com/mukeshsolanki/Android-Tamper-Detector;</li> <li>https://stackoverflow.com/questions/50126775/detecting-code-tampering-in-apk;</li> <li>https://stackoverflow.com/questions/13445598/lucky-patcher-how-can-i-protect-from-it.</li> </ul>"},{"location":"pages/overview/philosophy/","title":"Philosophy","text":""},{"location":"pages/overview/philosophy/#what-does-it-do","title":"What does it do?","text":"<p>It warns your application when a specific security requirement is not met by the system, userspace, or app.</p> <p>Each kevlar package shares a common structure: they all produce an attestation regarding (an aspect of) the security state of the Android device running your app. The idea behind it is being able to quickly capture every meaningful security information regarding a certain field, with a certain accuracy.</p> <p>These modules provide an array of detection methods that can be used to ensure the app is running in its proper intended environment</p> <p>Note</p> <p>A general rule of thumb is to include only what you need, and nothing more.  There is little to no point in using antipiracy protection if you do not have sensitive in-app material and/or transactions you want to protect, same with rooting or integrity.</p>"},{"location":"pages/overview/philosophy/#does-it-always-work","title":"Does it always work?","text":"<p>No. It does most of the time, but there is no guarantee of a 100% success rate.</p> <p>What kevlar provides is an accurate heuristic, which is relatively cheap to run and provides a valuable assessment within an acceptable margin of error.</p> <p>If you require a higher success rate, you will need much more sophisticated and ad-hoc levels of protection.  Kevlar catches what can be caught in a reasonable amount of time, space, and lines of code.  In a similar fashion as the pareto distribution, to slightly improve the detection rate you will need much more complicated software, much more time, or much more space.</p> <p>And for the record, any software trying to claim that it achieves 100% detection is factually wrong (there is a theorem in computability and decidability theory stating that you can not do that).</p>"},{"location":"pages/overview/philosophy/#naming-decisions","title":"Naming decisions","text":"<p>Kevlar is a material used in bulletproof vests.  And besides starting with a k (which at this point appears to be an implicit requirement for any cool kotlin library), it perfectly embodies its philosophy.</p> <p>A soldier in the field is a target for the enemy force. Soldiers shoot bullets at each other and who is hit die. Wearing a bulletproof vest is a way of reducing the chance of you dying.  It makes practical sense: it is a light material, not difficult to carry around, and it provides life-saving protection.</p> <p>Kevlar is lightweight body armor for your app, to check and shield against incoming hostile attacks.</p> <p>If you are being targeted with high precision sniper fire, a javelin anti-tank launcher, or a Royal Naval vessel in the immediate vicinity launches a missile strike on your location, even if you are James Bond there is little left to do.</p> <p>If your app is reverse engineered, the security bits stripped away and then recompiled (more details in Anatomy of an Attack), you are going to be vulnerable, and there is nothing you can do about it. </p> <p>But while being imperfect, it manages to be efficient and deflect the majority of automated and non-specialized patches and attacks, which is the majority of what you will (hopefully) be exposed to.</p> <p>Another similarity is about what you want to protect.  People don't usually wear a bulletproof vest at home [redacted U.S. joke]. It doesn't make much sense, since the attack is not likely.  The same thing goes with putting kevlar on a calculator app.  You can. It does not make much sense if it does not have valuable commercial features or APIs (On WolframAlpha it does).</p> <p>Success rates</p> <p>Given the success rate of this library against patches versus the success rate of kevlar vests against bullets, this could have easily been called full body armor, but that didn't sound as cool.</p>"},{"location":"pages/overview/philosophy/#security-through-obscurity","title":"Security Through Obscurity","text":"<p>Kevlar does not rely on security through obscurity. Its source code, logic, and dataset is public. </p> <p>Since the purpose of kevlar is to be a generic barrier to defeat automated and unskilled attacks,  going to the extent of obfuscating code that, if ever reverse engineered, would just be stripped away, seems like a fruitless idea.</p> <p>It would be necessary to introduce such mechanisms only if hostile software would try to automatically target specific kevlar components.  While I doubt this would ever happen, introducing basic internal safety checks or compile-time randomized obfuscation would surely make that kind of detection unfeasible.</p>"},{"location":"pages/overview/philosophy/#accuracy-and-precision","title":"Accuracy and Precision","text":"<p>It is fairly accurate (since there are just a few checks to run to check the security status, we are pretty confident that most of the time we will get the information right), and has excellent precision (since checks are deterministic and predictable, given an initial condition, the result will always be the same, accurate or not)</p> <p>(See accuracy vs precision)</p>"},{"location":"pages/overview/philosophy/#history","title":"History","text":"<p>This project has been alive since 2017 (by the former name billing-protector) to counteract automatic attacks against android applications (AAAAA). The original project was mainly aimed at protecting apps from Lucky Patcher, an infamous patch tool used to modify (recompile with automated code replacement and modification, more details in security/attacks) apps to bypass IAP (In-app purchases), and essentially crack them. It has evolved in a more general and flexible </p>"}]}