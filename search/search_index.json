{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Kevlar \u00b6 Abstract \u00b6 Kevlar is a security toolkit (library) for Android apps. It is divided in 3 packages ( antipiracy , rooting and integrity ), each containing specific tooling and components. Its purpose is to be an auditing tool, used to inspect the security environment on Android devices. A security environment is the security state of a device, which can be probed with the different packages kevlar provides. Each package focuses on a specific security environment area: antipiracy detects the presence of pirate software installed on the device (user-wise security); rooting detects the presence of root access, custom binaries, and abnormal OS status (system-wise security); integrity detects certain types of tampering attempts your app may have been targeted with (app-wise security). Kevlar is intended to be used any time it is deemed necessary to determine whether the device your app is running on can be regarded as secure, according to your policies and security requirements. Security Environment \u00b6 The security environment is the status of the device. This is subdivided into system-wise security (system modifications, rooting, custom binaries, custom ROMs, emulator, SELinux), user-wise security (pirate stores and pirate apps), and app-wise security (tampering, recompiling, changed signature & metadata) Flexibility \u00b6 Kevlar does not automatically detect a \"standard\" unsafe environment and gives a 0/1 answer. The kind of environment that is acceptable for your app to run in can be configured in each package individually. You may be indifferent to some things (e.g. root detection) and very sensitive about others (e.g. app tampering & piracy detection). You can customize the set of checks the library executes in each package. Once you define your constraints, kevlar modules will operate accordingly. If you don't explicitly instruct kevlar to check for a feature, then that feature will not be reported, regardless of its presence (or absence) on the device. Design \u00b6 Each kevlar package contains custom implementations for what it has to scan for, but they all share the same overall structure, to make it easy to work with. Once you learn how to use a package, then you can transfer that knowledge to the other ones. graph LR I[Inizialization] -.Settings..-> K{Kevlar}; AREQ[Attestation Requests] --> K K --> |Clear| P[Passed]; K --> |Failed| NP[Not Passed]; P --> ARES[Attestation Result] NP --> ARES The founding idea is a flow of attestations. You initialize the package passing to it your settings (what you want to check for). Then you can go ahead and start requesting attestations. An attestation can either be Clear (passed) or Failed (non passed), according to your detection settings. There may be one or more types of attestation you can request, and you can choose what you want by requesting different ones, to enforce granular control and run efficiently. Under the hood, each package will call its implementations and run those checks against the operating system/current app, but you'll eventually get an Attestation back, so your only job is to check whether it is clear or not. This makes security declarative: you express your constraints and requirements once while configuring kevlar, which will then take care of - when asked - producing a report (attestation) for your specific configuration, telling you what was found. And finally you can analyze this report and act accordingly, repeating the process as many times as needed. Use Cases \u00b6 Common use cases for security environment checks are applications managing sensitive resources, such as in-app purchases and subscriptions, valuable server-side resources or APIs, financial transactions, and anything that has a value that gets managed through your app/client. Ideally, you should request an attestation whenever your client wants to verify the status of the security environment before proceeding with the high-value action. Kevlar is a sort of guard statement for those actions, which should decrease the probability of an attacker successfully breaking your application's high-value transaction. Accuracy \u00b6 This tool is meant to be an approximate form of environment analysis and estimation. It covers a large number of attack vectors and does a good job at it. This does not mean that it is unbreakable. You can find more details in philosophy , but essentially it is a level 0 protection that can be removed by manually reverse engineering your app. This doesn't render it useless, it is very efficient in doing what it is designed to do : protecting against automated and unskilled attacks, which will most certainly be the vast majority of what your app will ever be put through. Additions & Alternatives \u00b6 Kevlar resembles what may look like an in-house protection system. It is open source, flexible and rich of features. For stricter scenarios where higher fidelity and accuracy are required, you should be using something more specific (and radically different). Play Integrity & SafetyNet from Google; AppCheck from Firebase; ProGuard and DexGuard from GuardSquare. License \u00b6 This project is licensed under the Apache License, Version 2.0. Please refer to the LICENSE.md file inside the Github repository for the full text.","title":"Overview"},{"location":"#welcome-to-kevlar","text":"","title":"Welcome to Kevlar"},{"location":"#abstract","text":"Kevlar is a security toolkit (library) for Android apps. It is divided in 3 packages ( antipiracy , rooting and integrity ), each containing specific tooling and components. Its purpose is to be an auditing tool, used to inspect the security environment on Android devices. A security environment is the security state of a device, which can be probed with the different packages kevlar provides. Each package focuses on a specific security environment area: antipiracy detects the presence of pirate software installed on the device (user-wise security); rooting detects the presence of root access, custom binaries, and abnormal OS status (system-wise security); integrity detects certain types of tampering attempts your app may have been targeted with (app-wise security). Kevlar is intended to be used any time it is deemed necessary to determine whether the device your app is running on can be regarded as secure, according to your policies and security requirements.","title":"Abstract"},{"location":"#security-environment","text":"The security environment is the status of the device. This is subdivided into system-wise security (system modifications, rooting, custom binaries, custom ROMs, emulator, SELinux), user-wise security (pirate stores and pirate apps), and app-wise security (tampering, recompiling, changed signature & metadata)","title":"Security Environment"},{"location":"#flexibility","text":"Kevlar does not automatically detect a \"standard\" unsafe environment and gives a 0/1 answer. The kind of environment that is acceptable for your app to run in can be configured in each package individually. You may be indifferent to some things (e.g. root detection) and very sensitive about others (e.g. app tampering & piracy detection). You can customize the set of checks the library executes in each package. Once you define your constraints, kevlar modules will operate accordingly. If you don't explicitly instruct kevlar to check for a feature, then that feature will not be reported, regardless of its presence (or absence) on the device.","title":"Flexibility"},{"location":"#design","text":"Each kevlar package contains custom implementations for what it has to scan for, but they all share the same overall structure, to make it easy to work with. Once you learn how to use a package, then you can transfer that knowledge to the other ones. graph LR I[Inizialization] -.Settings..-> K{Kevlar}; AREQ[Attestation Requests] --> K K --> |Clear| P[Passed]; K --> |Failed| NP[Not Passed]; P --> ARES[Attestation Result] NP --> ARES The founding idea is a flow of attestations. You initialize the package passing to it your settings (what you want to check for). Then you can go ahead and start requesting attestations. An attestation can either be Clear (passed) or Failed (non passed), according to your detection settings. There may be one or more types of attestation you can request, and you can choose what you want by requesting different ones, to enforce granular control and run efficiently. Under the hood, each package will call its implementations and run those checks against the operating system/current app, but you'll eventually get an Attestation back, so your only job is to check whether it is clear or not. This makes security declarative: you express your constraints and requirements once while configuring kevlar, which will then take care of - when asked - producing a report (attestation) for your specific configuration, telling you what was found. And finally you can analyze this report and act accordingly, repeating the process as many times as needed.","title":"Design"},{"location":"#use-cases","text":"Common use cases for security environment checks are applications managing sensitive resources, such as in-app purchases and subscriptions, valuable server-side resources or APIs, financial transactions, and anything that has a value that gets managed through your app/client. Ideally, you should request an attestation whenever your client wants to verify the status of the security environment before proceeding with the high-value action. Kevlar is a sort of guard statement for those actions, which should decrease the probability of an attacker successfully breaking your application's high-value transaction.","title":"Use Cases"},{"location":"#accuracy","text":"This tool is meant to be an approximate form of environment analysis and estimation. It covers a large number of attack vectors and does a good job at it. This does not mean that it is unbreakable. You can find more details in philosophy , but essentially it is a level 0 protection that can be removed by manually reverse engineering your app. This doesn't render it useless, it is very efficient in doing what it is designed to do : protecting against automated and unskilled attacks, which will most certainly be the vast majority of what your app will ever be put through.","title":"Accuracy"},{"location":"#additions-alternatives","text":"Kevlar resembles what may look like an in-house protection system. It is open source, flexible and rich of features. For stricter scenarios where higher fidelity and accuracy are required, you should be using something more specific (and radically different). Play Integrity & SafetyNet from Google; AppCheck from Firebase; ProGuard and DexGuard from GuardSquare.","title":"Additions &amp; Alternatives"},{"location":"#license","text":"This project is licensed under the Apache License, Version 2.0. Please refer to the LICENSE.md file inside the Github repository for the full text.","title":"License"},{"location":"pages/modules/antipiracy/antipiracy/","text":"Antipiracy \u00b6 graph LR I[Inizialization] -.Settings..-> K{KevlarAntipiracy}; DB[(Dataset)] === K AREQ[Attestation Requests] --> K K --> |Clear| P[Passed]; K --> |Failed| NP[Not Passed]; P --> ARES[AntipiracyAttestation] NP --> ARES The antipiracy package contains tools for the detection of different categories of pirate software that may be installed and running on target devices. At its core, this package runs a battery of tests against all the installed applications to check for potential active pirate software, which depending on your policies may be a security environment issue. It then compiles the results into an attestation (it can either be uninitialized, clear, or failed) which is returned to your app, where you can check what has been found and act accordingly. Purpose of the antipiracy package You may want to use this package if you consider that executing your app alongside pirate software which may be interfering/bypassing your code/protections is a security environment issue. Tampering and System protection The antipiracy package by itself does not do any kind of signature/tampering check (for that, refer to integrity package) or system wide verification ( rooting ). It just tells you whether software that may be trying/have already interfered/bypassed your protection mechanisms is installed or not. To implement this, you initialize KevlarAntipiracy and provide your desired settings (which influence what is to be detected and what not). Then you can submit attestation requests (which will be executed according to your settings). Each attestation request will cause Kevlar to grab the package list, run the appropriate checks and return an attestation. The settings you provide influence what will be included in the attestation. Empty & default settings The settings on antipiracy are additive. If you leave a blank DSL, nothing will be detected, because no checks will be run, because the settings are empty. If you do not pass a DSL at all, the default settings will be used (they only scan for pirate apps, not stores nor collateral). Custom private val antipiracy = KevlarAntipiracy { scan { pirate () store () collateral () } } Empty private val antipiracy = KevlarAntipiracy { scan { } } Default private val antipiracy = KevlarAntipiracy () Attestation process overview \u00b6 When you require an attestation (through antipiracy.attestate(context) ), kevlar executes the following operations: The installed package list is queried from the PackageManager . Make sure to have the right permissions to do that, since from Android 11 you need to add queries in your app's manifest, see the implement page; The test battery is initialized (to match your scan parameters) and ran on all packages, against the precompiled dataset onboard the library; The results are collected, processed, filtered, and returned in an AntipiracyAttestation . There is only one type of attestation that can be produced. The attestation is returned in AntipiracyAttestation (sealed class), which depending on the detection status can be of three types: Blank : This is a non-processed status. It should not be interpreted, as it does not carry any meaning about the attestation result. It is not to be interpreted as Clear ; Clear : The attestation has passed. There is nothing to report. This means that no installed software has triggered the detection from the battery of tests that have been executed, in compliance with the given scan parameters; Failed : The attestation has not passed. Pirated software has been detected. You can read which software has tripped the detection in the attestation result. The action you were about to do may be compromised, and you should not proceed. Warning Blank is completely different from Clear (or Failed ). It means that the software is initialized but that nothing has been done yet. Do not mix them up. Performance \u00b6 Package detection and testing make use of coroutines to run scan operations in parallel for each package, to minimize the time taken to run through all packages. Most of the checks consist of some type of string analysis (characters & regex matching and abstract alphabet inference, more details in detection ), which have pretty decent running times while being precise and reliable tools. Scan settings are taken into account intelligently to analyze and run the battery of tests over all packages in one single pass, regardless of how many checks are to be performed, and to execute the single package battery test in parallel. Timing The full attestation process takes from start to finish \u2248 75-200ms for my devices and emulators (assuming the full app list is returned, which it won't for Android 11+ [which is actually good news for performance, since the time taken for computing the whole attestation is linearly proportional to the number of applications returned by PackageManager ]). It is mainly influenced by the processing power of the device, the number of apps installed, and your scan configuration. It is decently fast, given that it will be run in the background before business-critical transactions (e.g. when the user clicks \"purchase\", we first check that the device is clean and then actually contact Google Play to initiate the transaction).","title":"Overview"},{"location":"pages/modules/antipiracy/antipiracy/#antipiracy","text":"graph LR I[Inizialization] -.Settings..-> K{KevlarAntipiracy}; DB[(Dataset)] === K AREQ[Attestation Requests] --> K K --> |Clear| P[Passed]; K --> |Failed| NP[Not Passed]; P --> ARES[AntipiracyAttestation] NP --> ARES The antipiracy package contains tools for the detection of different categories of pirate software that may be installed and running on target devices. At its core, this package runs a battery of tests against all the installed applications to check for potential active pirate software, which depending on your policies may be a security environment issue. It then compiles the results into an attestation (it can either be uninitialized, clear, or failed) which is returned to your app, where you can check what has been found and act accordingly. Purpose of the antipiracy package You may want to use this package if you consider that executing your app alongside pirate software which may be interfering/bypassing your code/protections is a security environment issue. Tampering and System protection The antipiracy package by itself does not do any kind of signature/tampering check (for that, refer to integrity package) or system wide verification ( rooting ). It just tells you whether software that may be trying/have already interfered/bypassed your protection mechanisms is installed or not. To implement this, you initialize KevlarAntipiracy and provide your desired settings (which influence what is to be detected and what not). Then you can submit attestation requests (which will be executed according to your settings). Each attestation request will cause Kevlar to grab the package list, run the appropriate checks and return an attestation. The settings you provide influence what will be included in the attestation. Empty & default settings The settings on antipiracy are additive. If you leave a blank DSL, nothing will be detected, because no checks will be run, because the settings are empty. If you do not pass a DSL at all, the default settings will be used (they only scan for pirate apps, not stores nor collateral). Custom private val antipiracy = KevlarAntipiracy { scan { pirate () store () collateral () } } Empty private val antipiracy = KevlarAntipiracy { scan { } } Default private val antipiracy = KevlarAntipiracy ()","title":"Antipiracy"},{"location":"pages/modules/antipiracy/antipiracy/#attestation-process-overview","text":"When you require an attestation (through antipiracy.attestate(context) ), kevlar executes the following operations: The installed package list is queried from the PackageManager . Make sure to have the right permissions to do that, since from Android 11 you need to add queries in your app's manifest, see the implement page; The test battery is initialized (to match your scan parameters) and ran on all packages, against the precompiled dataset onboard the library; The results are collected, processed, filtered, and returned in an AntipiracyAttestation . There is only one type of attestation that can be produced. The attestation is returned in AntipiracyAttestation (sealed class), which depending on the detection status can be of three types: Blank : This is a non-processed status. It should not be interpreted, as it does not carry any meaning about the attestation result. It is not to be interpreted as Clear ; Clear : The attestation has passed. There is nothing to report. This means that no installed software has triggered the detection from the battery of tests that have been executed, in compliance with the given scan parameters; Failed : The attestation has not passed. Pirated software has been detected. You can read which software has tripped the detection in the attestation result. The action you were about to do may be compromised, and you should not proceed. Warning Blank is completely different from Clear (or Failed ). It means that the software is initialized but that nothing has been done yet. Do not mix them up.","title":"Attestation process overview"},{"location":"pages/modules/antipiracy/antipiracy/#performance","text":"Package detection and testing make use of coroutines to run scan operations in parallel for each package, to minimize the time taken to run through all packages. Most of the checks consist of some type of string analysis (characters & regex matching and abstract alphabet inference, more details in detection ), which have pretty decent running times while being precise and reliable tools. Scan settings are taken into account intelligently to analyze and run the battery of tests over all packages in one single pass, regardless of how many checks are to be performed, and to execute the single package battery test in parallel. Timing The full attestation process takes from start to finish \u2248 75-200ms for my devices and emulators (assuming the full app list is returned, which it won't for Android 11+ [which is actually good news for performance, since the time taken for computing the whole attestation is linearly proportional to the number of applications returned by PackageManager ]). It is mainly influenced by the processing power of the device, the number of apps installed, and your scan configuration. It is decently fast, given that it will be run in the background before business-critical transactions (e.g. when the user clicks \"purchase\", we first check that the device is clean and then actually contact Google Play to initiate the transaction).","title":"Performance"},{"location":"pages/modules/antipiracy/database/","text":"Database \u00b6 Kevlar comes pre-packaged with definitions for the most common pirate software. A brief summary is reported in the following table: Software is the common name of the given pirate software; Internal Code is what kevlar uses to reference and report a specific software; Type defines whether the given software is a pirate store or pirate app; Most Common Package gives a probable package name for out in the wild pirate software. Usually pirate software have multiple (often numerous) package names, which are not reported in the table (but are obviously implemented in the library); Range defines which battery of tests is available against a given package. H is heuristic detection (package metadata string matching), A is alphabetical analysis and C are collateral tests. Software Internal Code Type Most Common Package Range Action Launcher Patcher ACTION_LAUNCHER_PATCHER App zone.jasi2169.uretpatcher H AC Market AC_MARKET Store ac.market.store H AGK App Killer AGK App com.aag.killer H All In One Downloader AIOD Store com.allinone.free H App Cake APP_CAKE Store com.appcake H App Sara APP_SARA App com.appsara.app H Aptoide APTOIDE Store cm.aptoide.pt H Black Mart BLACK_MART Store org.blackmart.market H Content Guard Disabler CGD App com.oneminusone.disablecontentguard H Creeplays Patcher CREEPLAYS_PATCHER App org.creeplays.hack H Cree Hack CREE_HACK App apps.zhasik007.hack H Freedom FREEDOM App jase.freedom H Game Hacker GAME_HACKER App org.sbtools.gamehack H Game Killer Cheats GAME_KILLER App com.killerapp.gamekiller H Get Apk GET_APK Store com.repodroid.app H Get Jar GET_JAR Store com.getjar.reward H Happymod HAPPYMOD Store happygames.io H Leo Playcards LEO_PLAYCARDS App com.leo.playcard H Lucky Patcher LUCKY_PATCHER App good luck H , A , C Mobilism MOBILISM Store org.mobilism.android H Mobogenie MOB_GENIE Store com.mobogenie H 1Mobile ONE_MOBILE Store me.onemobile.android H Slide Me SLIDE_ME Store com.slideme.sam.manager H Uret Patcher URET_PATCHER App zone.jasi2169.uretpatcher H XModGames XMG App com.xmodgame H Z Market Z_MARKET Store com.zmapp H","title":"Database"},{"location":"pages/modules/antipiracy/database/#database","text":"Kevlar comes pre-packaged with definitions for the most common pirate software. A brief summary is reported in the following table: Software is the common name of the given pirate software; Internal Code is what kevlar uses to reference and report a specific software; Type defines whether the given software is a pirate store or pirate app; Most Common Package gives a probable package name for out in the wild pirate software. Usually pirate software have multiple (often numerous) package names, which are not reported in the table (but are obviously implemented in the library); Range defines which battery of tests is available against a given package. H is heuristic detection (package metadata string matching), A is alphabetical analysis and C are collateral tests. Software Internal Code Type Most Common Package Range Action Launcher Patcher ACTION_LAUNCHER_PATCHER App zone.jasi2169.uretpatcher H AC Market AC_MARKET Store ac.market.store H AGK App Killer AGK App com.aag.killer H All In One Downloader AIOD Store com.allinone.free H App Cake APP_CAKE Store com.appcake H App Sara APP_SARA App com.appsara.app H Aptoide APTOIDE Store cm.aptoide.pt H Black Mart BLACK_MART Store org.blackmart.market H Content Guard Disabler CGD App com.oneminusone.disablecontentguard H Creeplays Patcher CREEPLAYS_PATCHER App org.creeplays.hack H Cree Hack CREE_HACK App apps.zhasik007.hack H Freedom FREEDOM App jase.freedom H Game Hacker GAME_HACKER App org.sbtools.gamehack H Game Killer Cheats GAME_KILLER App com.killerapp.gamekiller H Get Apk GET_APK Store com.repodroid.app H Get Jar GET_JAR Store com.getjar.reward H Happymod HAPPYMOD Store happygames.io H Leo Playcards LEO_PLAYCARDS App com.leo.playcard H Lucky Patcher LUCKY_PATCHER App good luck H , A , C Mobilism MOBILISM Store org.mobilism.android H Mobogenie MOB_GENIE Store com.mobogenie H 1Mobile ONE_MOBILE Store me.onemobile.android H Slide Me SLIDE_ME Store com.slideme.sam.manager H Uret Patcher URET_PATCHER App zone.jasi2169.uretpatcher H XModGames XMG App com.xmodgame H Z Market Z_MARKET Store com.zmapp H","title":"Database"},{"location":"pages/modules/antipiracy/detection/","text":"Detection Techniques \u00b6 This page details the detection techniques (aka tricks) employed in Kevlar Antipiracy. It should be stated that all checks are run against the local dataset (what kevlar thinks are pirate apps & stores, a summary of that is in database ), which is hardcoded in the library and therefore in your shipped software. Obfuscation complexity Writing good self-obfuscating software is hard. There are a few ways, but essentially you need an installer package that carries the payload and an algorithm to insert the actual software in a randomized stub. If you do it well enough, there is no way to easily characterize your package and becomes more difficult (if not borderline unfeasible) to detect automatically. MagiskHide did this exceptionally well, to the point that it is almost useless to try to achieve fast detection. It can be done switching to more aggressive detection techniques, which kinda defeats the purpose of kevlar. String matching \u00b6 This is the most basic yet efficient scanning tool. Running a basic string match against some package parameters does miracles for detection, since most non-super-sneaky pirate software has a fixed package name, a fixed app label, a fixed class name, or all three. If kevlar catches even one of those, then the software is detected and will be reported in the attestation. It doesn't even need to be a full string match really, most of the time you need a partial (containment) match to detect something. This is very useful (and implemented) against prefix/postfix switching. Regex matching \u00b6 Same as above, but with regex. You can have more elaborate patterns or filters, since some packages distribute the same builds under different package names, thinking they are doing something clever. Abstract Alphabet Inference \u00b6 This is the most advanced bit in package detection. Some packages will swap characters with something very similar (usually in the label name), but not equal (and usually belonging to obscure charsets), so that they break classic string matching and make regex a hell to work with (the character's binary encoding is different, even if it looks the same to your eyes). And since this process is usually randomized, you can not know in advance which of the characters will be swapped and which will be real, so you have to take that into account. The solution is fast abstract matching, where we describe on a high level which string (word) we are looking for, and then kevlar will automatically run the check on every package translating the high-level description to known sneaky characters (1 abstract character maps to many sneaky characters). This can be checked strictly (full match), partially (contains), or probabilistically (given a minimum percentage of matches) For FSA people, this is like having multiple arcs from one state to the next, with all the sneaky characters as transitions. Word acceptance is equivalent to detection. Sneaky characters The usual roll includes characters from Latin fullwidth, Cyrillic, Greek, a lot of weird uncategorized characters, and like 20 variations of the symbols / , _ and - . You can go check out the full list at AsciiVariations.kt . I'd advise doing so on an empty stomach. These characters can be extracted from the installer package of said self-camouflaging pirate software. Collateral tools \u00b6 Some techniques may have non-zero false positive rates, and they are disabled by default. Kevlar's objective is to achieve accurate detection, with a non-zero false-negative rate, but a zero false-positive rate. You can think of it as the judgement in a court trial : the defendant (package) is presumed to be innocent until proven guilty. And without using collateral techniques, we know we won't wrongly classify a normal package as a pirate one. Enabling collateral tools is a form of aggressive detection, and it should be used in scenarios where you are willing to accept some (little) risk to get stronger detection against self-obfuscating, for the price of non-zero false positives. The detection works because we know how some specific software tries to obfuscate/randomize its stub. We can therefore match for the distribution of those values in all installed packages, and if one matches then it may be what we are looking for. It may also be something else. By default we assume it is innocuous, but enabling these checks will treat these matches as hits, and will be included in the attestation. Collateral example in package name randomization The easiest example to illustrate this technique is with Lucky Patcher . Its installer generates a randomized stub, inserts the payload (the actual pirate software), and installs it. While the stub's package name has random bits, it is not completely random. It always starts with \"ru.\", followed by 8 random characters, followed by a \".\", followed by another 9 random characters. And we can form a pattern-detection test detecting these fixed occourrences. Here's a FSM: stateDiagram-v2 direction LR [*] --> ru. ru. --> 8? 8? --> . . --> 9? 9? --> . . --> [*] Using this technique will successfully detect lucky patcher's stub if installed, along with any other software whose package name happens to match the given specification","title":"Detection"},{"location":"pages/modules/antipiracy/detection/#detection-techniques","text":"This page details the detection techniques (aka tricks) employed in Kevlar Antipiracy. It should be stated that all checks are run against the local dataset (what kevlar thinks are pirate apps & stores, a summary of that is in database ), which is hardcoded in the library and therefore in your shipped software. Obfuscation complexity Writing good self-obfuscating software is hard. There are a few ways, but essentially you need an installer package that carries the payload and an algorithm to insert the actual software in a randomized stub. If you do it well enough, there is no way to easily characterize your package and becomes more difficult (if not borderline unfeasible) to detect automatically. MagiskHide did this exceptionally well, to the point that it is almost useless to try to achieve fast detection. It can be done switching to more aggressive detection techniques, which kinda defeats the purpose of kevlar.","title":"Detection Techniques"},{"location":"pages/modules/antipiracy/detection/#string-matching","text":"This is the most basic yet efficient scanning tool. Running a basic string match against some package parameters does miracles for detection, since most non-super-sneaky pirate software has a fixed package name, a fixed app label, a fixed class name, or all three. If kevlar catches even one of those, then the software is detected and will be reported in the attestation. It doesn't even need to be a full string match really, most of the time you need a partial (containment) match to detect something. This is very useful (and implemented) against prefix/postfix switching.","title":"String matching"},{"location":"pages/modules/antipiracy/detection/#regex-matching","text":"Same as above, but with regex. You can have more elaborate patterns or filters, since some packages distribute the same builds under different package names, thinking they are doing something clever.","title":"Regex matching"},{"location":"pages/modules/antipiracy/detection/#abstract-alphabet-inference","text":"This is the most advanced bit in package detection. Some packages will swap characters with something very similar (usually in the label name), but not equal (and usually belonging to obscure charsets), so that they break classic string matching and make regex a hell to work with (the character's binary encoding is different, even if it looks the same to your eyes). And since this process is usually randomized, you can not know in advance which of the characters will be swapped and which will be real, so you have to take that into account. The solution is fast abstract matching, where we describe on a high level which string (word) we are looking for, and then kevlar will automatically run the check on every package translating the high-level description to known sneaky characters (1 abstract character maps to many sneaky characters). This can be checked strictly (full match), partially (contains), or probabilistically (given a minimum percentage of matches) For FSA people, this is like having multiple arcs from one state to the next, with all the sneaky characters as transitions. Word acceptance is equivalent to detection. Sneaky characters The usual roll includes characters from Latin fullwidth, Cyrillic, Greek, a lot of weird uncategorized characters, and like 20 variations of the symbols / , _ and - . You can go check out the full list at AsciiVariations.kt . I'd advise doing so on an empty stomach. These characters can be extracted from the installer package of said self-camouflaging pirate software.","title":"Abstract Alphabet Inference"},{"location":"pages/modules/antipiracy/detection/#collateral-tools","text":"Some techniques may have non-zero false positive rates, and they are disabled by default. Kevlar's objective is to achieve accurate detection, with a non-zero false-negative rate, but a zero false-positive rate. You can think of it as the judgement in a court trial : the defendant (package) is presumed to be innocent until proven guilty. And without using collateral techniques, we know we won't wrongly classify a normal package as a pirate one. Enabling collateral tools is a form of aggressive detection, and it should be used in scenarios where you are willing to accept some (little) risk to get stronger detection against self-obfuscating, for the price of non-zero false positives. The detection works because we know how some specific software tries to obfuscate/randomize its stub. We can therefore match for the distribution of those values in all installed packages, and if one matches then it may be what we are looking for. It may also be something else. By default we assume it is innocuous, but enabling these checks will treat these matches as hits, and will be included in the attestation. Collateral example in package name randomization The easiest example to illustrate this technique is with Lucky Patcher . Its installer generates a randomized stub, inserts the payload (the actual pirate software), and installs it. While the stub's package name has random bits, it is not completely random. It always starts with \"ru.\", followed by 8 random characters, followed by a \".\", followed by another 9 random characters. And we can form a pattern-detection test detecting these fixed occourrences. Here's a FSM: stateDiagram-v2 direction LR [*] --> ru. ru. --> 8? 8? --> . . --> 9? 9? --> . . --> [*] Using this technique will successfully detect lucky patcher's stub if installed, along with any other software whose package name happens to match the given specification","title":"Collateral tools"},{"location":"pages/modules/antipiracy/implementation/","text":"Implementation \u00b6 A working example for the antipiracy module can be found in the github repository under the :showcase module. Dependency \u00b6 Gradle dependencies { implementation \"io.github.kevlar-kt:antipiracy:1.1.1\" } Kotlin DSL dependencies { implementation ( \"io.github.kevlar-kt:antipiracy:1.1.1\" ) } Maven <dependency> <groupId> io.github.kevlar-kt </groupId> <artifactId> antipiracy </artifactId> <version> 1.1.1 </version> <type> pom </type> </dependency> Permissions \u00b6 Kevlar's antipiracy module works essentially by running heuristics and filters on the list of installed packages, against a local dataset, matching and reporting the results as they are found. Since Android 11 (API 30), there have been some changes regarding the behaviour of PackageManager (and the visibility of installed packages). Specifically, if you query all the installed packages (just like kevlar does, via PackageManager#getInstalledApplications ), only a specified subset of installed apps are visible by default, and they are packages that may interact with your app. This, in turn, would break the attestation process, because malicious software may not be returned in said package list, and won't therefore be detected. There are a few workarounds for this: either listing in the app's manifest a few query entries that will enable PackageManager to return the packages that kevlar's engine may detect, or adding a special permission to your app's manifest (with a few drawbacks) You can more about this in privacy . Kevlar Manifest Queries \u00b6 The following queries will enable Kevlar to read, among the other app-related packages, all the packages which it will be looking for. This fixes the problem, as you can have a working antipiracy system, without adding the QUERY_ALL_PACKAGES permission Include the queries statement in your manifest like so: AndroidManifest.xml (single line) <?xml version=\"1.0\" encoding=\"utf-8\"?> <manifest xmlns:android= \"http://schemas.android.com/apk/res/android\" xmlns:tools= \"http://schemas.android.com/tools\" > <queries> <package android:name= \"uret.jasi2169.patcher\" /> <package android:name= \"zone.jasi2169.uretpatcher\" /> <package android:name= \"org.creeplays.hack\" /> <package android:name= \"apps.zhasik007.hack\" /> <package android:name= \"com.leo.playcard\" /> <package android:name= \"com.appsara.app\" /> <package android:name= \"com.xmodgame\" /> <package android:name= \"org.sbtools.gamehack\" /> <package android:name= \"com.zune.gamekiller\" /> <package android:name= \"com.killerapp.gamekiller\" /> <package android:name= \"cn.lm.sq\" /> <package android:name= \"com.aag.killer\" /> <package android:name= \"com.github.oneminusone.disablecontentguard\" /> <package android:name= \"com.oneminusone.disablecontentguard\" /> <package android:name= \"madkite.freedom\" /> <package android:name= \"jase.freedom\" /> <package android:name= \"cc.jase.freedom\" /> <package android:name= \"cc.madkite.freedom\" /> <package android:name= \"cc.cz.madkite.freedom\" /> <package android:name= \"com.devadvance.rootcloak\" /> <package android:name= \"com.devadvance.rootcloakplus\" /> <package android:name= \"com.formyhm.hideroot\" /> <package android:name= \"com.formyhm.hiderootpremium\" /> <package android:name= \"com.amphoras.hidemyroot\" /> <package android:name= \"com.amphoras.hidemyrootadfree\" /> <package android:name= \"com.zachspong.temprootremovejb\" /> <package android:name= \"cm.aptoide.pt\" /> <package android:name= \"com.happymod.apk\" /> <package android:name= \"happygames.io\" /> <package android:name= \"org.blackmart.market\" /> <package android:name= \"com.blackmartalpha\" /> <package android:name= \"com.mobogenie\" /> <package android:name= \"me.onemobile.android\" /> <package android:name= \"com.repodroid.app\" /> <package android:name= \"com.getjar.reward\" /> <package android:name= \"com.slideme.sam.manager\" /> <package android:name= \"ac.market.store\" /> <package android:name= \"net.appcake\" /> <package android:name= \"com.appcake\" /> <package android:name= \"com.zmapp\" /> <package android:name= \"org.mobilism.android\" /> <package android:name= \"com.allinone.free\" /> <package android:name= \"com.chelpus.lackypatch\" /> <package android:name= \"com.dimonvideo.luckypatcher\" /> <package android:name= \"com.forpda.lp\" /> <package android:name= \"com.android.vendinc\" /> <package android:name= \"com.android.vending.licensing.ILicensingService\" /> <package android:name= \"com.android.vending.billing.InAppBillingService.LOCK\" /> <intent> <action android:name= \"android.intent.action.SEND_MULTIPLE\" /> <data android:mimeType= \"*/*\" /> </intent> </queries> <application android:name= \"com.kevlar.showcase.App\" android:icon= \"@mipmap/ic_launcher\" android:label= \"@string/app_name\" android:theme= \"@style/AppTheme\" > <activity android:name= \"com.kevlar.showcase.ui.activities.main.MainActivity\" android:exported= \"true\" > <intent-filter> <action android:name= \"android.intent.action.MAIN\" /> <category android:name= \"android.intent.category.LAUNCHER\" /> </intent-filter> </activity> </application> </manifest> Multi-line AndroidManifest.xml <?xml version=\"1.0\" encoding=\"utf-8\"?> <manifest xmlns:android= \"http://schemas.android.com/apk/res/android\" xmlns:tools= \"http://schemas.android.com/tools\" > <queries> <package android:name= \"uret.jasi2169.patcher\" /> <package android:name= \"zone.jasi2169.uretpatcher\" /> <package android:name= \"org.creeplays.hack\" /> <package android:name= \"apps.zhasik007.hack\" /> <package android:name= \"com.leo.playcard\" /> <package android:name= \"com.appsara.app\" /> <package android:name= \"com.xmodgame\" /> <package android:name= \"org.sbtools.gamehack\" /> <package android:name= \"com.zune.gamekiller\" /> <package android:name= \"com.killerapp.gamekiller\" /> <package android:name= \"cn.lm.sq\" /> <package android:name= \"com.aag.killer\" /> <package android:name= \"com.github.oneminusone.disablecontentguard\" /> <package android:name= \"com.oneminusone.disablecontentguard\" /> <package android:name= \"madkite.freedom\" /> <package android:name= \"jase.freedom\" /> <package android:name= \"cc.jase.freedom\" /> <package android:name= \"cc.madkite.freedom\" /> <package android:name= \"cc.cz.madkite.freedom\" /> <package android:name= \"com.devadvance.rootcloak\" /> <package android:name= \"com.devadvance.rootcloakplus\" /> <package android:name= \"com.formyhm.hideroot\" /> <package android:name= \"com.formyhm.hiderootpremium\" /> <package android:name= \"com.amphoras.hidemyroot\" /> <package android:name= \"com.amphoras.hidemyrootadfree\" /> <package android:name= \"com.zachspong.temprootremovejb\" /> <package android:name= \"cm.aptoide.pt\" /> <package android:name= \"com.happymod.apk\" /> <package android:name= \"happygames.io\" /> <package android:name= \"org.blackmart.market\" /> <package android:name= \"com.blackmartalpha\" /> <package android:name= \"com.mobogenie\" /> <package android:name= \"me.onemobile.android\" /> <package android:name= \"com.repodroid.app\" /> <package android:name= \"com.getjar.reward\" /> <package android:name= \"com.slideme.sam.manager\" /> <package android:name= \"ac.market.store\" /> <package android:name= \"net.appcake\" /> <package android:name= \"com.appcake\" /> <package android:name= \"com.zmapp\" /> <package android:name= \"org.mobilism.android\" /> <package android:name= \"com.allinone.free\" /> <package android:name= \"com.chelpus.lackypatch\" /> <package android:name= \"com.dimonvideo.luckypatcher\" /> <package android:name= \"com.forpda.lp\" /> <package android:name= \"com.android.vendinc\" /> <package android:name= \"com.android.vending.licensing.ILicensingService\" /> <package android:name= \"com.android.vending.billing.InAppBillingService.LOCK\" /> <intent> <action android:name= \"android.intent.action.SEND_MULTIPLE\" /> <!-- <category android:name=\"android.intent.category.DEFAULT\" /> --> <data android:mimeType= \"*/*\" /> </intent> </queries> <application android:name= \"com.kevlar.showcase.App\" android:icon= \"@mipmap/ic_launcher\" android:label= \"@string/app_name\" android:theme= \"@style/AppTheme\" > <activity android:name= \"com.kevlar.showcase.ui.activities.main.MainActivity\" android:exported= \"true\" > <intent-filter> <action android:name= \"android.intent.action.MAIN\" /> <category android:name= \"android.intent.category.LAUNCHER\" /> </intent-filter> </activity> </application> </manifest> QUERY_ALL_PACKAGES Permission \u00b6 This is a very particular permission, as it allows your app to be treated pre-api30 and receive the full, unfiltered app list. It is declared below: AndroidManifest.xml <uses-permission android:name= \"android.permission.QUERY_ALL_PACKAGES\" tools:ignore= \"QueryAllPackagesPermission\" /> Google Play Store Admission Apps built using this permission may not be allowed on the play store, unless they belong in a specific category <uses-permission android:name= \"android.permission.QUERY_ALL_PACKAGES\" tools:ignore= \"QueryAllPackagesPermission\" /> Initialization & Attestations \u00b6 You need to create a KevlarAntipiracy instance (which is the way you will be requesting attestations), along with your desired parameters (either global, local or in your repository layer, if you are using MVVM/MVC). Once you have that, you just go ahead and call antipiracy.attestate() in a coroutine and your system will be analyzed, according to the provided parameters. AntipiracyAttestation will be returned from the call (it's a sealed class), containing the found software list, if any. Note that we will be initializing KevlarAntipiracy with custom scan settings, but you could leave it as default. In-Place \u00b6 This is the most concise way to implement piracy checks. InPlace.kt val antipiracy = KevlarAntipiracy { scan { // your scan configuration pirate () store () } } CoroutineScope ( Dispatchers . Default ). launch { // Attestation request when ( val attestation = antipiracy . attestate ( context )) { is AntipiracyAttestation . Blank -> { // Pending attestation, no information yet. // Don't do anything. } is AntipiracyAttestation . Clear -> { // Good to go. } is AntipiracyAttestation . Failed -> { // Pirate software detected. } } } This packs everything in one file. It is not excellent when writing a modern applications but it does its job. ViewModel + Repository + SharedFlow + DI with Hilt \u00b6 Activity: \u00b6 AntipiracyActivity.kt @AndroidEntryPoint class AntipiracyActivity : AppCompatActivity () { private val vm : ActivityViewModel by viewModels () override fun onCreate ( savedInstanceState : Bundle?) { super . onCreate ( savedInstanceState ) lifecycleScope . launch { lifecycle . repeatOnLifecycle ( Lifecycle . State . STARTED ) { vm . attestation . collectLatest { when ( it ) { is AntipiracyAttestation . Blank -> { // Pending attestation, no information yet. // Don't do anything. } is AntipiracyAttestation . Clear -> { // Good to go. } is AntipiracyAttestation . Failed -> { // Pirate software detected. } } } } } CoroutineScope ( Dispatchers . Main ). launch { vm . requestAttestation () } } } View model: \u00b6 ActivityViewModel.kt @HiltViewModel class ActivityViewModel @Inject constructor ( private val securityRepository : AntipiracyRepository ) : ViewModel () { private val _attestationState = MutableStateFlow ( KevlarAntipiracy . blankAttestation ()) val attestation : SharedFlow < AntipiracyAttestation > = _attestationState . stateIn ( viewModelScope , SharingStarted . Eagerly , initialValue = KevlarAntipiracy . blankAttestation () ) fun requestAttestation () { viewModelScope . launch { _attestationState . value = securityRepository . attestate () } } } Repository \u00b6 AntipiracyRepository.kt class AntipiracyRepository @Inject constructor ( @ApplicationContext val context : Context , @IoDispatcher val externalDispatcher : CoroutineDispatcher ) { private val antipiracy = KevlarAntipiracy { scan { // your scan configuration DSL here pirate () store () } } suspend fun attestate (): AntipiracyAttestation = withContext ( externalDispatcher ) { antipiracy . attestate ( context ) } }","title":"Implementation"},{"location":"pages/modules/antipiracy/implementation/#implementation","text":"A working example for the antipiracy module can be found in the github repository under the :showcase module.","title":"Implementation"},{"location":"pages/modules/antipiracy/implementation/#dependency","text":"Gradle dependencies { implementation \"io.github.kevlar-kt:antipiracy:1.1.1\" } Kotlin DSL dependencies { implementation ( \"io.github.kevlar-kt:antipiracy:1.1.1\" ) } Maven <dependency> <groupId> io.github.kevlar-kt </groupId> <artifactId> antipiracy </artifactId> <version> 1.1.1 </version> <type> pom </type> </dependency>","title":"Dependency"},{"location":"pages/modules/antipiracy/implementation/#permissions","text":"Kevlar's antipiracy module works essentially by running heuristics and filters on the list of installed packages, against a local dataset, matching and reporting the results as they are found. Since Android 11 (API 30), there have been some changes regarding the behaviour of PackageManager (and the visibility of installed packages). Specifically, if you query all the installed packages (just like kevlar does, via PackageManager#getInstalledApplications ), only a specified subset of installed apps are visible by default, and they are packages that may interact with your app. This, in turn, would break the attestation process, because malicious software may not be returned in said package list, and won't therefore be detected. There are a few workarounds for this: either listing in the app's manifest a few query entries that will enable PackageManager to return the packages that kevlar's engine may detect, or adding a special permission to your app's manifest (with a few drawbacks) You can more about this in privacy .","title":"Permissions"},{"location":"pages/modules/antipiracy/implementation/#kevlar-manifest-queries","text":"The following queries will enable Kevlar to read, among the other app-related packages, all the packages which it will be looking for. This fixes the problem, as you can have a working antipiracy system, without adding the QUERY_ALL_PACKAGES permission Include the queries statement in your manifest like so: AndroidManifest.xml (single line) <?xml version=\"1.0\" encoding=\"utf-8\"?> <manifest xmlns:android= \"http://schemas.android.com/apk/res/android\" xmlns:tools= \"http://schemas.android.com/tools\" > <queries> <package android:name= \"uret.jasi2169.patcher\" /> <package android:name= \"zone.jasi2169.uretpatcher\" /> <package android:name= \"org.creeplays.hack\" /> <package android:name= \"apps.zhasik007.hack\" /> <package android:name= \"com.leo.playcard\" /> <package android:name= \"com.appsara.app\" /> <package android:name= \"com.xmodgame\" /> <package android:name= \"org.sbtools.gamehack\" /> <package android:name= \"com.zune.gamekiller\" /> <package android:name= \"com.killerapp.gamekiller\" /> <package android:name= \"cn.lm.sq\" /> <package android:name= \"com.aag.killer\" /> <package android:name= \"com.github.oneminusone.disablecontentguard\" /> <package android:name= \"com.oneminusone.disablecontentguard\" /> <package android:name= \"madkite.freedom\" /> <package android:name= \"jase.freedom\" /> <package android:name= \"cc.jase.freedom\" /> <package android:name= \"cc.madkite.freedom\" /> <package android:name= \"cc.cz.madkite.freedom\" /> <package android:name= \"com.devadvance.rootcloak\" /> <package android:name= \"com.devadvance.rootcloakplus\" /> <package android:name= \"com.formyhm.hideroot\" /> <package android:name= \"com.formyhm.hiderootpremium\" /> <package android:name= \"com.amphoras.hidemyroot\" /> <package android:name= \"com.amphoras.hidemyrootadfree\" /> <package android:name= \"com.zachspong.temprootremovejb\" /> <package android:name= \"cm.aptoide.pt\" /> <package android:name= \"com.happymod.apk\" /> <package android:name= \"happygames.io\" /> <package android:name= \"org.blackmart.market\" /> <package android:name= \"com.blackmartalpha\" /> <package android:name= \"com.mobogenie\" /> <package android:name= \"me.onemobile.android\" /> <package android:name= \"com.repodroid.app\" /> <package android:name= \"com.getjar.reward\" /> <package android:name= \"com.slideme.sam.manager\" /> <package android:name= \"ac.market.store\" /> <package android:name= \"net.appcake\" /> <package android:name= \"com.appcake\" /> <package android:name= \"com.zmapp\" /> <package android:name= \"org.mobilism.android\" /> <package android:name= \"com.allinone.free\" /> <package android:name= \"com.chelpus.lackypatch\" /> <package android:name= \"com.dimonvideo.luckypatcher\" /> <package android:name= \"com.forpda.lp\" /> <package android:name= \"com.android.vendinc\" /> <package android:name= \"com.android.vending.licensing.ILicensingService\" /> <package android:name= \"com.android.vending.billing.InAppBillingService.LOCK\" /> <intent> <action android:name= \"android.intent.action.SEND_MULTIPLE\" /> <data android:mimeType= \"*/*\" /> </intent> </queries> <application android:name= \"com.kevlar.showcase.App\" android:icon= \"@mipmap/ic_launcher\" android:label= \"@string/app_name\" android:theme= \"@style/AppTheme\" > <activity android:name= \"com.kevlar.showcase.ui.activities.main.MainActivity\" android:exported= \"true\" > <intent-filter> <action android:name= \"android.intent.action.MAIN\" /> <category android:name= \"android.intent.category.LAUNCHER\" /> </intent-filter> </activity> </application> </manifest> Multi-line AndroidManifest.xml <?xml version=\"1.0\" encoding=\"utf-8\"?> <manifest xmlns:android= \"http://schemas.android.com/apk/res/android\" xmlns:tools= \"http://schemas.android.com/tools\" > <queries> <package android:name= \"uret.jasi2169.patcher\" /> <package android:name= \"zone.jasi2169.uretpatcher\" /> <package android:name= \"org.creeplays.hack\" /> <package android:name= \"apps.zhasik007.hack\" /> <package android:name= \"com.leo.playcard\" /> <package android:name= \"com.appsara.app\" /> <package android:name= \"com.xmodgame\" /> <package android:name= \"org.sbtools.gamehack\" /> <package android:name= \"com.zune.gamekiller\" /> <package android:name= \"com.killerapp.gamekiller\" /> <package android:name= \"cn.lm.sq\" /> <package android:name= \"com.aag.killer\" /> <package android:name= \"com.github.oneminusone.disablecontentguard\" /> <package android:name= \"com.oneminusone.disablecontentguard\" /> <package android:name= \"madkite.freedom\" /> <package android:name= \"jase.freedom\" /> <package android:name= \"cc.jase.freedom\" /> <package android:name= \"cc.madkite.freedom\" /> <package android:name= \"cc.cz.madkite.freedom\" /> <package android:name= \"com.devadvance.rootcloak\" /> <package android:name= \"com.devadvance.rootcloakplus\" /> <package android:name= \"com.formyhm.hideroot\" /> <package android:name= \"com.formyhm.hiderootpremium\" /> <package android:name= \"com.amphoras.hidemyroot\" /> <package android:name= \"com.amphoras.hidemyrootadfree\" /> <package android:name= \"com.zachspong.temprootremovejb\" /> <package android:name= \"cm.aptoide.pt\" /> <package android:name= \"com.happymod.apk\" /> <package android:name= \"happygames.io\" /> <package android:name= \"org.blackmart.market\" /> <package android:name= \"com.blackmartalpha\" /> <package android:name= \"com.mobogenie\" /> <package android:name= \"me.onemobile.android\" /> <package android:name= \"com.repodroid.app\" /> <package android:name= \"com.getjar.reward\" /> <package android:name= \"com.slideme.sam.manager\" /> <package android:name= \"ac.market.store\" /> <package android:name= \"net.appcake\" /> <package android:name= \"com.appcake\" /> <package android:name= \"com.zmapp\" /> <package android:name= \"org.mobilism.android\" /> <package android:name= \"com.allinone.free\" /> <package android:name= \"com.chelpus.lackypatch\" /> <package android:name= \"com.dimonvideo.luckypatcher\" /> <package android:name= \"com.forpda.lp\" /> <package android:name= \"com.android.vendinc\" /> <package android:name= \"com.android.vending.licensing.ILicensingService\" /> <package android:name= \"com.android.vending.billing.InAppBillingService.LOCK\" /> <intent> <action android:name= \"android.intent.action.SEND_MULTIPLE\" /> <!-- <category android:name=\"android.intent.category.DEFAULT\" /> --> <data android:mimeType= \"*/*\" /> </intent> </queries> <application android:name= \"com.kevlar.showcase.App\" android:icon= \"@mipmap/ic_launcher\" android:label= \"@string/app_name\" android:theme= \"@style/AppTheme\" > <activity android:name= \"com.kevlar.showcase.ui.activities.main.MainActivity\" android:exported= \"true\" > <intent-filter> <action android:name= \"android.intent.action.MAIN\" /> <category android:name= \"android.intent.category.LAUNCHER\" /> </intent-filter> </activity> </application> </manifest>","title":"Kevlar Manifest Queries"},{"location":"pages/modules/antipiracy/implementation/#query_all_packages-permission","text":"This is a very particular permission, as it allows your app to be treated pre-api30 and receive the full, unfiltered app list. It is declared below: AndroidManifest.xml <uses-permission android:name= \"android.permission.QUERY_ALL_PACKAGES\" tools:ignore= \"QueryAllPackagesPermission\" /> Google Play Store Admission Apps built using this permission may not be allowed on the play store, unless they belong in a specific category <uses-permission android:name= \"android.permission.QUERY_ALL_PACKAGES\" tools:ignore= \"QueryAllPackagesPermission\" />","title":"QUERY_ALL_PACKAGES Permission"},{"location":"pages/modules/antipiracy/implementation/#initialization-attestations","text":"You need to create a KevlarAntipiracy instance (which is the way you will be requesting attestations), along with your desired parameters (either global, local or in your repository layer, if you are using MVVM/MVC). Once you have that, you just go ahead and call antipiracy.attestate() in a coroutine and your system will be analyzed, according to the provided parameters. AntipiracyAttestation will be returned from the call (it's a sealed class), containing the found software list, if any. Note that we will be initializing KevlarAntipiracy with custom scan settings, but you could leave it as default.","title":"Initialization &amp; Attestations"},{"location":"pages/modules/antipiracy/implementation/#in-place","text":"This is the most concise way to implement piracy checks. InPlace.kt val antipiracy = KevlarAntipiracy { scan { // your scan configuration pirate () store () } } CoroutineScope ( Dispatchers . Default ). launch { // Attestation request when ( val attestation = antipiracy . attestate ( context )) { is AntipiracyAttestation . Blank -> { // Pending attestation, no information yet. // Don't do anything. } is AntipiracyAttestation . Clear -> { // Good to go. } is AntipiracyAttestation . Failed -> { // Pirate software detected. } } } This packs everything in one file. It is not excellent when writing a modern applications but it does its job.","title":"In-Place"},{"location":"pages/modules/antipiracy/implementation/#viewmodel-repository-sharedflow-di-with-hilt","text":"","title":"ViewModel + Repository + SharedFlow + DI with Hilt"},{"location":"pages/modules/antipiracy/implementation/#activity","text":"AntipiracyActivity.kt @AndroidEntryPoint class AntipiracyActivity : AppCompatActivity () { private val vm : ActivityViewModel by viewModels () override fun onCreate ( savedInstanceState : Bundle?) { super . onCreate ( savedInstanceState ) lifecycleScope . launch { lifecycle . repeatOnLifecycle ( Lifecycle . State . STARTED ) { vm . attestation . collectLatest { when ( it ) { is AntipiracyAttestation . Blank -> { // Pending attestation, no information yet. // Don't do anything. } is AntipiracyAttestation . Clear -> { // Good to go. } is AntipiracyAttestation . Failed -> { // Pirate software detected. } } } } } CoroutineScope ( Dispatchers . Main ). launch { vm . requestAttestation () } } }","title":"Activity:"},{"location":"pages/modules/antipiracy/implementation/#view-model","text":"ActivityViewModel.kt @HiltViewModel class ActivityViewModel @Inject constructor ( private val securityRepository : AntipiracyRepository ) : ViewModel () { private val _attestationState = MutableStateFlow ( KevlarAntipiracy . blankAttestation ()) val attestation : SharedFlow < AntipiracyAttestation > = _attestationState . stateIn ( viewModelScope , SharingStarted . Eagerly , initialValue = KevlarAntipiracy . blankAttestation () ) fun requestAttestation () { viewModelScope . launch { _attestationState . value = securityRepository . attestate () } } }","title":"View model:"},{"location":"pages/modules/antipiracy/implementation/#repository","text":"AntipiracyRepository.kt class AntipiracyRepository @Inject constructor ( @ApplicationContext val context : Context , @IoDispatcher val externalDispatcher : CoroutineDispatcher ) { private val antipiracy = KevlarAntipiracy { scan { // your scan configuration DSL here pirate () store () } } suspend fun attestate (): AntipiracyAttestation = withContext ( externalDispatcher ) { antipiracy . attestate ( context ) } }","title":"Repository"},{"location":"pages/modules/antipiracy/privacy/","text":"Privacy & Package Queries \u00b6 The antipiracy module is designed to check user-wide security. As such, it is the layer that is closest to the user data and thus needs to take extra care to enforce user privacy requirements. Package Queries \u00b6 A crucial element in this process is retrieving the application list, in which all the checks are subsequently run on. This is increasingly getting difficult. Since Android 11 (API 30) the full package list is filtered by default , and there are more privacy-friendly (less intrusive) methods for querying apps. Those don't work as well with pirate app detection because usually pirate software actively tries to hide its presence with camouflage techniques A nice technique is declaring the appropriate queries in the app's manifest, so that the list given to kevlar, although not complete, will contain all the packages referenced by the queries. And since kevlar searches for known pirate apps/stores (and thus packages), we can add these as packages we're interested in receiving, and we're set. It gets a little more complex for packages which actively try to hide themselves / randomize their properties to avoid detections, but it can be done. You can find the guide on how to add that to the manifest in the implementation page. Unintentional Computational Speedup By limiting the amount of packages returned by the package manager, the battery of checks (which has to be ran for each package), will take less, and therefore further reduce the execution time for the attestation. So not bad news after all! User Privacy & Attitude \u00b6 Another delicate aspect of querying installed packages is the way you communicate to the user that you just scanned all the packages and found pirate software, and therefore will not let them proceed to the purchase they were about to happily crack. While obviously, you should not by any means be afraid to deny the purchase/transaction/service to a malevolent user, there are varying degrees of directness with which you can communicate your decision to the end user. Usually, they are not best pleased with the discovery, so a little bit of touch is advised. Some implementations go the other way and just do not work/act as broken, while in reality they did a much deeper check, found that the environment is unsafe, assumed that the currently running software is pirated, and refused to proceed. Usually, this works because the user knows it is doing something wrong and it expects that something may break or that some self-checking is in place. Protection & Reviews I have implemented in all my commercial Android software some sort of piracy checks, and while I'd like to show you some store reviews, I will refrain from exposing your uninitialized eyes to the unfathomable pain I went through while reading them in the first place. Let's just say it usually goes down like this: User tries to crack your app with pirate software; Your app picks up the pirate software, and refuses to start the in-app transaction because the environment is unsecured; Said user suddenly becomes a mobile security expert and goes on the store to angrily review your app as garbage/spyware/malware/trojan/...","title":"Privacy & Permissions"},{"location":"pages/modules/antipiracy/privacy/#privacy-package-queries","text":"The antipiracy module is designed to check user-wide security. As such, it is the layer that is closest to the user data and thus needs to take extra care to enforce user privacy requirements.","title":"Privacy &amp; Package Queries"},{"location":"pages/modules/antipiracy/privacy/#package-queries","text":"A crucial element in this process is retrieving the application list, in which all the checks are subsequently run on. This is increasingly getting difficult. Since Android 11 (API 30) the full package list is filtered by default , and there are more privacy-friendly (less intrusive) methods for querying apps. Those don't work as well with pirate app detection because usually pirate software actively tries to hide its presence with camouflage techniques A nice technique is declaring the appropriate queries in the app's manifest, so that the list given to kevlar, although not complete, will contain all the packages referenced by the queries. And since kevlar searches for known pirate apps/stores (and thus packages), we can add these as packages we're interested in receiving, and we're set. It gets a little more complex for packages which actively try to hide themselves / randomize their properties to avoid detections, but it can be done. You can find the guide on how to add that to the manifest in the implementation page. Unintentional Computational Speedup By limiting the amount of packages returned by the package manager, the battery of checks (which has to be ran for each package), will take less, and therefore further reduce the execution time for the attestation. So not bad news after all!","title":"Package Queries"},{"location":"pages/modules/antipiracy/privacy/#user-privacy-attitude","text":"Another delicate aspect of querying installed packages is the way you communicate to the user that you just scanned all the packages and found pirate software, and therefore will not let them proceed to the purchase they were about to happily crack. While obviously, you should not by any means be afraid to deny the purchase/transaction/service to a malevolent user, there are varying degrees of directness with which you can communicate your decision to the end user. Usually, they are not best pleased with the discovery, so a little bit of touch is advised. Some implementations go the other way and just do not work/act as broken, while in reality they did a much deeper check, found that the environment is unsafe, assumed that the currently running software is pirated, and refused to proceed. Usually, this works because the user knows it is doing something wrong and it expects that something may break or that some self-checking is in place. Protection & Reviews I have implemented in all my commercial Android software some sort of piracy checks, and while I'd like to show you some store reviews, I will refrain from exposing your uninitialized eyes to the unfathomable pain I went through while reading them in the first place. Let's just say it usually goes down like this: User tries to crack your app with pirate software; Your app picks up the pirate software, and refuses to start the in-app transaction because the environment is unsecured; Said user suddenly becomes a mobile security expert and goes on the store to angrily review your app as garbage/spyware/malware/trojan/...","title":"User Privacy &amp; Attitude"},{"location":"pages/modules/antipiracy/reference/","text":"Reference \u00b6 The complete rooting configuration is as follows. Complete settings private val antipiracy = KevlarAntipiracy { scan { pirate () store () collateral () } } Once you require the attestation through attestate(context) , any software matching your settings will be reported. withContext ( externalDispatcher ) { val attestation = antipiracy . attestate ( context ) } You can find all the details about what software is regarded as pirate in the database page. Pirate Apps \u00b6 The pirate() function tells kevlar to scan the application list, and match it against the local dataset for pirate applications. If any package is deemed to be a pirate application, it is included in the attestation private val antipiracy = KevlarAntipiracy { scan { pirate () store () collateral () } } Pirate Stores \u00b6 The store() function tells kevlar to scan the application list, and match it against the local dataset for pirate stores. private val antipiracy = KevlarAntipiracy { scan { pirate () store () collateral () } } Collateral detection methods \u00b6 The collateral() function enables kevlar to use more aggressive methods to perform the lookup of specific pirate software. private val antipiracy = KevlarAntipiracy { scan { pirate () store () collateral () } } This is made a separate flag because those special methods have a non-zero false-positive probability, and therefore are risky to use because you may (albeit extremely rarely) end up in situations where an unrelated software (usually russian) may be detected as pirate software. Since we want you to have full control over your scan settings, we extrapolated this flag to make the switch explicit. More details in the detection page.","title":"Reference"},{"location":"pages/modules/antipiracy/reference/#reference","text":"The complete rooting configuration is as follows. Complete settings private val antipiracy = KevlarAntipiracy { scan { pirate () store () collateral () } } Once you require the attestation through attestate(context) , any software matching your settings will be reported. withContext ( externalDispatcher ) { val attestation = antipiracy . attestate ( context ) } You can find all the details about what software is regarded as pirate in the database page.","title":"Reference"},{"location":"pages/modules/antipiracy/reference/#pirate-apps","text":"The pirate() function tells kevlar to scan the application list, and match it against the local dataset for pirate applications. If any package is deemed to be a pirate application, it is included in the attestation private val antipiracy = KevlarAntipiracy { scan { pirate () store () collateral () } }","title":"Pirate Apps"},{"location":"pages/modules/antipiracy/reference/#pirate-stores","text":"The store() function tells kevlar to scan the application list, and match it against the local dataset for pirate stores. private val antipiracy = KevlarAntipiracy { scan { pirate () store () collateral () } }","title":"Pirate Stores"},{"location":"pages/modules/antipiracy/reference/#collateral-detection-methods","text":"The collateral() function enables kevlar to use more aggressive methods to perform the lookup of specific pirate software. private val antipiracy = KevlarAntipiracy { scan { pirate () store () collateral () } } This is made a separate flag because those special methods have a non-zero false-positive probability, and therefore are risky to use because you may (albeit extremely rarely) end up in situations where an unrelated software (usually russian) may be detected as pirate software. Since we want you to have full control over your scan settings, we extrapolated this flag to make the switch explicit. More details in the detection page.","title":"Collateral detection methods"},{"location":"pages/modules/antipiracy/tradeoffs/","text":"Tradeoffs \u00b6 kevlar is not an antivirus. It is not designed to be on that end of the spectrum. It is an heuristic to quickly catch most of the junk installed on the device. As a general rule of thumb: If you want more precision, you need more time (There are advanced and stricter checks used in financial software: archive and directory scanning, extended signature checks, and everything done with professional security software, but doing that defeats the purpose ). If you want less running time, you will have less precision.","title":"Tradeoffs"},{"location":"pages/modules/antipiracy/tradeoffs/#tradeoffs","text":"kevlar is not an antivirus. It is not designed to be on that end of the spectrum. It is an heuristic to quickly catch most of the junk installed on the device. As a general rule of thumb: If you want more precision, you need more time (There are advanced and stricter checks used in financial software: archive and directory scanning, extended signature checks, and everything done with professional security software, but doing that defeats the purpose ). If you want less running time, you will have less precision.","title":"Tradeoffs"},{"location":"pages/modules/integrity/hardcoding/","text":"Hardcoded data \u00b6 When an application is being tampered with, its code can change. Its behavior can mutate. Its features may (and will) be radically different than what you have developed in production. This introduces all kinds of issues regarding the consistency of the code itself. The key to detection is being able to avoid some of those code changes on hardcoded data, and detecting inconsistencies Nintendo Antipiracy & Consistency checks Some Nintendo games are known to have self-checking and inconsistency detection for antipiracy purposes. They may, for instance, read from a non-existent memory slot [on purpose] as a form of check, and if the read operation is successful then it is likely that the program is being run in a pirate environment (tape, emulator, or custom hardware), as opposed to an original one, where the read operation would have failed. Package name change \u00b6 A simple example would be an attack that aims at changing the package name of your app. They usually just change application metadata and packages and try to recompile them. If it is done well, they may try to also run a text search inside application strings to look for the package, just in case it was saved in a string variable, and change it too. If it is done extremely well (not implemented anywhere afaik), then they may also try to break some of the easy string obfuscation (base64 or other text encodings & charsets) and produce a different string that de-obfuscates to what the changed package name is. About signature changes Whatever you sign is eternal. Signature verification is extremely important because nobody else can sign software with your signature (since you have your private key in the Keystore). Modifying even one bit inside your app requires the attacker to sign the application. And since they don't have access to your Keystore, they can only resign it with their key or a debug key. But the point is, it is not your one. As soon as you detect that your signature doesn't match the one on the package that's running, you know that something has gone wrong. Protection through Obfuscation \u00b6 As much as this may look like security through obscurity, it is a necessary technique employed to make sure that automatic attacks against your app's code do not also intercept your hardcoded data. This is because an automated attack may try to find any hardcoded metadata and replace it with the new value they are trying to change to. Creating a safe container for those truth values is vital for the checks so that they can compare the original hardcoded value with the runtime value, and match them.","title":"Hardcoding"},{"location":"pages/modules/integrity/hardcoding/#hardcoded-data","text":"When an application is being tampered with, its code can change. Its behavior can mutate. Its features may (and will) be radically different than what you have developed in production. This introduces all kinds of issues regarding the consistency of the code itself. The key to detection is being able to avoid some of those code changes on hardcoded data, and detecting inconsistencies Nintendo Antipiracy & Consistency checks Some Nintendo games are known to have self-checking and inconsistency detection for antipiracy purposes. They may, for instance, read from a non-existent memory slot [on purpose] as a form of check, and if the read operation is successful then it is likely that the program is being run in a pirate environment (tape, emulator, or custom hardware), as opposed to an original one, where the read operation would have failed.","title":"Hardcoded data"},{"location":"pages/modules/integrity/hardcoding/#package-name-change","text":"A simple example would be an attack that aims at changing the package name of your app. They usually just change application metadata and packages and try to recompile them. If it is done well, they may try to also run a text search inside application strings to look for the package, just in case it was saved in a string variable, and change it too. If it is done extremely well (not implemented anywhere afaik), then they may also try to break some of the easy string obfuscation (base64 or other text encodings & charsets) and produce a different string that de-obfuscates to what the changed package name is. About signature changes Whatever you sign is eternal. Signature verification is extremely important because nobody else can sign software with your signature (since you have your private key in the Keystore). Modifying even one bit inside your app requires the attacker to sign the application. And since they don't have access to your Keystore, they can only resign it with their key or a debug key. But the point is, it is not your one. As soon as you detect that your signature doesn't match the one on the package that's running, you know that something has gone wrong.","title":"Package name change"},{"location":"pages/modules/integrity/hardcoding/#protection-through-obfuscation","text":"As much as this may look like security through obscurity, it is a necessary technique employed to make sure that automatic attacks against your app's code do not also intercept your hardcoded data. This is because an automated attack may try to find any hardcoded metadata and replace it with the new value they are trying to change to. Creating a safe container for those truth values is vital for the checks so that they can compare the original hardcoded value with the runtime value, and match them.","title":"Protection through Obfuscation"},{"location":"pages/modules/integrity/implementation/","text":"Implementation \u00b6 Implementing integrity requires, on top of a KevlarAntipiracy and the attestation infrastructure, a bit of information about your application's metadata, which will be hardcoded inside it. Hardcoded data is necessary to provide kevlar a truth value (essentially, that should be the description of all the scenarios that the application is allowed to run in) to match the runtime values of your binary (which may have been tampered or altered by an attacker) against. That's because, if done well, we can detect almost every kind of attack/tampering attempt through checking various APK metadata, such as the package name, the signature, the installer and debug flags. The obfuscation is necessary because we need to conceal the truth values, since they will be looked for by the attacker (software or human), and make it as hard as possible to automatically find and patch them. A working example for the integrity module can be found in the github repository under the :showcase module. Dependency \u00b6 Gradle dependencies { implementation \"io.github.kevlar-kt:integrity:1.1.1\" } Kotlin DSL dependencies { implementation ( \"io.github.kevlar-kt:integrity:1.1.1\" ) } Maven <dependency> <groupId> io.github.kevlar-kt </groupId> <artifactId> integrity </artifactId> <version> 1.1.1 </version> <type> pom </type> </dependency> Hardcoded metadata \u00b6 Understanding which metadata you need \u00b6 The first step is choosing which checks to run, and thus which data to provide kevlar. The good news is that they all are stable metadata. This means that once you make the effort of searching the right strings and implementing everything, you are ideally good to go forever. Kevlar has 4 kinds of checks: a package name check, a signature check, an installer check and a debug check. Check Type Required parameters Parameter type Package Name package name String Signature Check app signature String (base64-encoded) Installer Check N/A N/A Debug Check N/A N/A The hardcoded metadata you need to find is the following: Your application package name : Will check that the running binary's package name matches the hardcoded package name; Your application signature : Will check that the running binary's signature is the same as the hardcoded signature. Additionally, you should consider enabling the other two kinds of checks: Debug checks : Is enabled, kevlar autonomously checks for debug flags and bits in your binary; Installer checks : If enabled, kevlar will report any application which has not been installed through an allowed installer (by default it only supports the Play Store, but you can add custom stores if you distribute your software elsewhere). Once you choose which kind of checks you want to run, you get the required metadata hardcoded_metadata.kt // Holds the package name private val packageNameData = HardcodedPackageName ( packageName = \"com.kevlar.showcase\" ) // Holds the signature private val signatureData = HardcodedBase64EncodedSignature ( base64EncodedSignature = \"J+nqXLfuIO8B2AmhkMYHGE4jDyw=\" ) // Combines all the metadata and configuration private val integrity = KevlarIntegrity { checks { packageName { hardcodedPackageName ( packageNameData ) } signature { hardcodedSignatures ( signatureData ) } installer () debug () } } // Runs the checks on the current executing app integrity . attestate ( context ) Do not Maybe, just maybe, you may be tempted to so something like this: VERY_BAD_hardcoded_metadata.kt private val notAtAllHardcodedMetadata = HardcodedMetadata ( packageName = context . getPackageName (), signature = getRuntimeSignature () ) The sole purpose of HardcodedMetadata is hardcoding truth values inside your app, which don't depend on the context or application, which may have been tampered with . This snippet single handedly kills the whole library (because kevlar will check that the (supposedly) hardcoded package name, in this case context.getPackageName() , matches the runtime package name, which is always true since it is gathered via context.getPackageName() too) and is like shooting yourself in the foot with a cannon. Don't. Finding metadata \u00b6 Finding the package name is easy, since you are the one choosing it for your application. For the signature, it's not so straightforward to extract because it depends on your keystore. You have two different ways to get your keystore signature. In the examples we will find the debug signature, but you need to find the signature of the keystore you use to sign your application when publishing on google play. Direct application extraction \u00b6 The most practical way to read your keystore it is to put the following line of code in your app, to then sign the application with the key you are interested in acquiring the signature string of, and run it. // This returns the signature of the current running application. val signature : String = KevlarIntegrity . obtainCurrentAppSignature ( context ) This will output the current app signature. That's the reference string you need to give to kevlar (which will extract the runtime signature of your app and match it against that string). Android debug signature Every android application is signed with some key. When an application is signed as \"debug\", it simply means that it is signed with a special key, which is known to be the debug key. Signature extraction & Google Play App Signing API If you are using Google Play App Signing, the key you sign your application with is not the one your app is distributed with (See the official docs regarding the matter, and a relevant issue in kevlar). In this case the easiest way to get your actual signature would be to upload a dummy version of your app (which logs the runtime signature) through google play store, let the backend process and sign it, download it (through the archive manager on the play console), install & run it locally on an emulator/device, and save the runtime signature. Once you have done this (quite tedious) procedure, you have your signature and can pass it to kevlar. Android studio extraction \u00b6 Running ./gradlew signingReport will spit out all the details for all the different keystores in your project. The signature we are interested in is the SHA-1 entry. In this case, 27:E9:EA:5C:B7:EE:20:EF:01:D8:09:A1:90:C6:07:18:4E:23:0F:2C . > Task :showcase:signingReport Variant: debug Config: debug Store: /Users/cioccarellia/.android/debug.keystore Alias: AndroidDebugKey MD5: 1B:AF:39:46:4E:13:83:F3:45:E9:0A:5A:53:64:9C:CB SHA1: 27:E9:EA:5C:B7:EE:20:EF:01:D8:09:A1:90:C6:07:18:4E:23:0F:2C SHA-256: 36:C8:C0:A1:8A:DD:6D:0E:34:F9:6E:7E:98:DC:1F:89:08:BC:CD:2E:EF:88:ED:45:DF:79:85:D2:39:BD:E1:54 Valid until: Tuesday, June 25, 2052 ---------- Variant: release Config: null Store: null Alias: null ---------- We then have to convert it in a string form (like that we have the raw hex bytes, we want a base64 encoding of the binary signature). In this case the conversion (you can use online tools to do this) yields J+nqXLfuIO8B2AmhkMYHGE4jDyw= . Play Signing Since we don't have access to the keystore file if we use Play Signing, this method is not viable in that case, and you have to resort to uploading a dummy version of the app, download its play-signed version through the releases page, and extract the signature from that APK file. Obfuscating metadata \u00b6 The second step (optional but recommended) is obfuscating the metadata you just gathered, so that it is saved in an obfuscated form (in your bytecode, so that automatic tools / unskilled attackers can't easily find it), but passed to kevlar deobfuscated (so that we have the original truth values at run time). This means that we ship with out app the obfuscated data and the way to convert that obfuscated data back to plaintext to feed kevlar. There are a few different ways to do it, all of them are fully implemented in the :showcase module: No obfuscation (not recommended) \u00b6 In this case you just save the values as they are, and pass them in HardcodedMetadata unobfuscated_hardcoded_metadata.kt private const val packageName = HardcodedPackageName ( \"com.kevlar.showcase\" ) private const val signature = HardcodedBase64EncodedSignature ( \"J+nqXLfuIO8B2AmhkMYHGE4jDyw=\" ) Bytecode The produced kotlin bytecode clearly exposes the raw values: 1 2 3 4 5 6 7 8 9 10 11 L1 ALOAD 0 NEW com/kevlar/integrity/model/HardcodedMetadata DUP L2 LDC \"com.kevlar.showcase\" L3 LDC \"J+nqXLfuIO8B2AmhkMYHGE4jDyw=\" L4 INVOKESPECIAL com/kevlar/integrity/model/HardcodedMetadata.<init> (Ljava/lang/String;Ljava/lang/String;)V PUTFIELD com/kevlar/showcase/data/repo/IntegrityRepository.hardcodedMetadata : Lcom/kevlar/integrity/model/HardcodedMetadata; Base64 obfuscation \u00b6 You store the package name and signature values as Base64-encoded byte arrays, and they go through the Base64.decode() function when creating HardcodedMetadata . base64_obfuscated_hardcoded_metadata.kt private val packageName = \"\"\"Y29tLmtldmxhci5zaG93Y2FzZQ==\"\"\" . toByteArray () private val signature = \"\"\"SitucVhMZnVJTzhCMkFtaGtNWUhHRTRqRHl3PQ==\"\"\" . toByteArray () private val base64ObfuscatedHardcodedPackageName = HardcodedPackageName ( packageName = Base64 . decode ( base64PackageName , Base64 . DEFAULT ). toString ( Charsets . UTF_8 ) ) private val base64ObfuscatedHardcodedSignature = HardcodedBase64EncodedSignature ( Base64 . decode ( base64Signature , Base64 . DEFAULT ). toString ( Charsets . UTF_8 ) ) Where Y29tLmtldmxhci5zaG93Y2FzZQ== is the base64 encoding of com.kevlar.showcase , and SitucVhMZnVJTzhCMkFtaGtNWUhHRTRqRHl3PQ== of J+nqXLfuIO8B2AmhkMYHGE4jDyw= (the signature). You can look them up online , grab them from your app or use openssl base64 in the terminal. Base64 flags & charset The flag field and charset don't necessarily need to be Base64.DEFAULT and UTF_8 . Even though they are the most popular, you may choose something else if you prefer, as long as you preserve consistency. Bytecode Here the metadata is hidden and not targetable with basic find-and-replace techniques 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 L6 ALOAD 0 LDC \"Y29tLmtldmxhci5zaG93Y2FzZQ==\" ASTORE 3 GETSTATIC kotlin/text/Charsets.UTF_8 : Ljava/nio/charset/Charset; ASTORE 4 L7 ALOAD 3 L8 ALOAD 4 INVOKEVIRTUAL java/lang/String.getBytes (Ljava/nio/charset/Charset;)[B DUP LDC \"(this as java.lang.String).getBytes(charset)\" INVOKESTATIC kotlin/jvm/internal/Intrinsics.checkNotNullExpressionValue (Ljava/lang/Object;Ljava/lang/String;)V L9 PUTFIELD com/kevlar/showcase/data/repo/IntegrityRepository.packageName : [B L10 ALOAD 0 LDC \"SitucVhMZnVJTzhCMkFtaGtNWUhHRTRqRHl3PQ==\" ASTORE 3 GETSTATIC kotlin/text/Charsets.UTF_8 : Ljava/nio/charset/Charset; ASTORE 4 L11 ALOAD 3 L12 ALOAD 4 INVOKEVIRTUAL java/lang/String.getBytes (Ljava/nio/charset/Charset;)[B DUP LDC \"(this as java.lang.String).getBytes(charset)\" INVOKESTATIC kotlin/jvm/internal/Intrinsics.checkNotNullExpressionValue (Ljava/lang/Object;Ljava/lang/String;)V L13 PUTFIELD com/kevlar/showcase/data/repo/IntegrityRepository.signature : [B L14 ALOAD 0 NEW com/kevlar/integrity/model/HardcodedMetadata DUP L15 ALOAD 0 GETFIELD com/kevlar/showcase/data/repo/IntegrityRepository.packageName : [B ICONST_0 INVOKESTATIC android/util/Base64.decode ([BI)[B DUP LDC \"Base64.decode(packageName, Base64.DEFAULT)\" INVOKESTATIC kotlin/jvm/internal/Intrinsics.checkNotNullExpressionValue (Ljava/lang/Object;Ljava/lang/String;)V ASTORE 3 GETSTATIC kotlin/text/Charsets.UTF_8 : Ljava/nio/charset/Charset; ASTORE 4 L16 NEW java/lang/String DUP ALOAD 3 ALOAD 4 INVOKESPECIAL java/lang/String.<init> ([BLjava/nio/charset/Charset;)V L17 L18 ALOAD 0 GETFIELD com/kevlar/showcase/data/repo/IntegrityRepository.signature : [B ICONST_0 INVOKESTATIC android/util/Base64.decode ([BI)[B DUP LDC \"Base64.decode(signature, Base64.DEFAULT)\" INVOKESTATIC kotlin/jvm/internal/Intrinsics.checkNotNullExpressionValue (Ljava/lang/Object;Ljava/lang/String;)V ASTORE 3 GETSTATIC kotlin/text/Charsets.UTF_8 : Ljava/nio/charset/Charset; ASTORE 4 L19 NEW java/lang/String DUP ALOAD 3 ALOAD 4 INVOKESPECIAL java/lang/String.<init> ([BLjava/nio/charset/Charset;)V L20 L21 INVOKESPECIAL com/kevlar/integrity/model/HardcodedMetadata.<init> (Ljava/lang/String;Ljava/lang/String;)V PUTFIELD com/kevlar/showcase/data/repo/IntegrityRepository.base64ObfuscatedHardcodedMetadata : Lcom/kevlar/integrity/model/HardcodedMetadata; Encryption (+base64) \u00b6 A better alternative is to encrypt the hardcoded metadata, store them in an encrypted form, and send them through a decryption function when creating HardcodedMetadata . encrypted_hardcoded_metadata.kt // Our arbitrary 256-bit encryption key private val aesKey256 = \"\"\"4t7w!z%C*F-JaNcRfUjXn2r5u8x/A?Ds\"\"\" // This is \"com.kevlar.showcase\", encrypted using AES256 with the previous key private val encryptedPackageName = \"\"\"s3wf/AOYtr9BEMVFrweeLnkmerryUykMA8O77S5tMlI=\"\"\" . toByteArray () // This is \"J+nqXLfuIO8B2AmhkMYHGE4jDyw=\", encrypted using AES256 with the previous key private val encryptedSignature = \"\"\"tqMJquO3D+EKx1rx4R7/qzmsuEgpp1bKwxXe9AeB/WU=\"\"\" . toByteArray () private val aes256EncryptedHardcodedPackageName = HardcodedPackageName ( packageName = EncryptionUtil . decrypt ( encryptedPackageName , EncryptionUtil . generateKey ( aesKey256 ) ) ) private val aes256EncryptedHardcodedSignatures = HardcodedBase64EncodedSignature ( EncryptionUtil . decrypt ( encryptedSignature , EncryptionUtil . generateKey ( aesKey256 )) ) Where 7KAa2CFkhPQOUouDu32KZJLqOzGFbTTnJA3rGxMlAg4= is the encrypted value of com.kevlar.showcase , and +ylMx63kwFRmXKHQU0cbzyb8MJ1iiGW1g8+MjDRcS/o= of J+nqXLfuIO8B2AmhkMYHGE4jDyw= . This ensures that there is no possibility that an automatic attack picks up the string as a package name or signature, and trivial string substitutions or encodings like base64 won't give any information away (the ciphertext is encoded in base64). AES128 or AES256 is recommended as the encryption algorithm (it's a little overkill but it does the job). The ciphertext may also be stored as a byte array. Encryption utility This tiny class (from the showcase module in the repository) is a basic AES encryption/decryption utility. EncryptionUtil.kt import android.util.Base64 import javax.crypto.Cipher import javax.crypto.SecretKey import javax.crypto.spec.SecretKeySpec object EncryptionUtil { private const val algorithm = \"AES\" private const val transformation = \"AES/ECB/PKCS5Padding\" fun generateKey ( key : String ): SecretKey = SecretKeySpec ( key . toByteArray (), algorithm ) fun encrypt ( text : ByteArray , secret : SecretKey ): String { val cipher : Cipher = Cipher . getInstance ( transformation ). apply { init ( Cipher . ENCRYPT_MODE , secret ) } return Base64 . encodeToString ( cipher . doFinal ( text ), Base64 . NO_WRAP ) ?: \"\" } fun decrypt ( ciphertext : ByteArray , secret : SecretKey ): String { val cipher : Cipher = Cipher . getInstance ( transformation ). apply { init ( Cipher . DECRYPT_MODE , secret ) } return String ( cipher . doFinal ( Base64 . decode ( ciphertext , Base64 . NO_WRAP )), Charsets . UTF_8 ) } } Bytecode Here detecting and reconstructing the original package name automatically is basically impossible 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 L22 ALOAD 0 LDC \"4t7w!z%C*F-JaNcRfUjXn2r5u8x/A?Ds\" PUTFIELD com/kevlar/showcase/data/repo/IntegrityRepository.key256 : Ljava/lang/String; L23 ALOAD 0 LDC \"s3wf/AOYtr9BEMVFrweeLnkmerryUykMA8O77S5tMlI=\" ASTORE 3 GETSTATIC kotlin/text/Charsets.UTF_8 : Ljava/nio/charset/Charset; ASTORE 4 L24 ALOAD 3 L25 ALOAD 4 INVOKEVIRTUAL java/lang/String.getBytes (Ljava/nio/charset/Charset;)[B DUP LDC \"(this as java.lang.String).getBytes(charset)\" INVOKESTATIC kotlin/jvm/internal/Intrinsics.checkNotNullExpressionValue (Ljava/lang/Object;Ljava/lang/String;)V L26 PUTFIELD com/kevlar/showcase/data/repo/IntegrityRepository.encryptedPackageName : [B L27 ALOAD 0 LDC \"tqMJquO3D+EKx1rx4R7/qzmsuEgpp1bKwxXe9AeB/WU=\" ASTORE 3 GETSTATIC kotlin/text/Charsets.UTF_8 : Ljava/nio/charset/Charset; ASTORE 4 L28 ALOAD 3 L29 ALOAD 4 INVOKEVIRTUAL java/lang/String.getBytes (Ljava/nio/charset/Charset;)[B DUP LDC \"(this as java.lang.String).getBytes(charset)\" INVOKESTATIC kotlin/jvm/internal/Intrinsics.checkNotNullExpressionValue (Ljava/lang/Object;Ljava/lang/String;)V L30 PUTFIELD com/kevlar/showcase/data/repo/IntegrityRepository.encryptedSignature : [B L31 ALOAD 0 NEW com/kevlar/integrity/model/HardcodedMetadata DUP L32 GETSTATIC com/kevlar/showcase/util/EncryptionUtil.INSTANCE : Lcom/kevlar/showcase/util/EncryptionUtil; ALOAD 0 GETFIELD com/kevlar/showcase/data/repo/IntegrityRepository.encryptedPackageName : [B GETSTATIC com/kevlar/showcase/util/EncryptionUtil.INSTANCE : Lcom/kevlar/showcase/util/EncryptionUtil; ALOAD 0 GETFIELD com/kevlar/showcase/data/repo/IntegrityRepository.key256 : Ljava/lang/String; INVOKEVIRTUAL com/kevlar/showcase/util/EncryptionUtil.generateKey (Ljava/lang/String;)Ljavax/crypto/SecretKey; INVOKEVIRTUAL com/kevlar/showcase/util/EncryptionUtil.decrypt ([BLjavax/crypto/SecretKey;)Ljava/lang/String; L33 GETSTATIC com/kevlar/showcase/util/EncryptionUtil.INSTANCE : Lcom/kevlar/showcase/util/EncryptionUtil; ALOAD 0 GETFIELD com/kevlar/showcase/data/repo/IntegrityRepository.encryptedSignature : [B GETSTATIC com/kevlar/showcase/util/EncryptionUtil.INSTANCE : Lcom/kevlar/showcase/util/EncryptionUtil; ALOAD 0 GETFIELD com/kevlar/showcase/data/repo/IntegrityRepository.key256 : Ljava/lang/String; INVOKEVIRTUAL com/kevlar/showcase/util/EncryptionUtil.generateKey (Ljava/lang/String;)Ljavax/crypto/SecretKey; INVOKEVIRTUAL com/kevlar/showcase/util/EncryptionUtil.decrypt ([BLjavax/crypto/SecretKey;)Ljava/lang/String; L34 INVOKESPECIAL com/kevlar/integrity/model/HardcodedMetadata.<init> (Ljava/lang/String;Ljava/lang/String;)V PUTFIELD com/kevlar/showcase/data/repo/IntegrityRepository.aes256EncryptedHardcodedMetadata : Lcom/kevlar/integrity/model/HardcodedMetadata; Hashing \u00b6 This hasn't been developed yet, but it may be possible to let kevlar know only the hash of your hardcoded data, and let it match directly on the runtime signatures and package names hashes. This would require multiple options of composite hash functions to be secure enough. It is not implemented. Initialization & Attestations \u00b6 You need to create a KevlarIntegrity instance (which is the way you will be requesting attestations), along with your desired parameters (either global, local or in your repository layer, if you are using MVVM/MVC). Once you have that, you just go ahead and call integrity.attestate() in a coroutine and your application running metadata will be checked, according to the provided parameters. IntegrityAttestation will be returned from the call (it's a sealed class), containing the checks which failed, if any. Note that we will be initializing KevlarIntegrity with custom scan settings, but you could leave it as default. In-Place \u00b6 This is the most concise (and complete) way to implement this package. InPlace.kt /** * Base64 obfuscated package name and signature * */ // Original value is \"com.kevlar.showcase\", the package name hardcoded value private val base64EncodedPackageName = \"\"\"Y29tLmtldmxhci5zaG93Y2FzZQ==\"\"\" . toByteArray () private val base64ObfuscatedHardcodedPackageName = HardcodedPackageName ( packageName = Base64 . decode ( base64EncodedPackageName , Base64 . DEFAULT ). toString ( Charsets . UTF_8 ) ) // Original value is \"J+nqXLfuIO8B2AmhkMYHGE4jDyw=\", the signature hardcoded value private val base64EncodedSignature = \"\"\"SitucVhMZnVJTzhCMkFtaGtNWUhHRTRqRHl3PQ==\"\"\" . toByteArray () private val base64ObfuscatedHardcodedSignatures = HardcodedBase64EncodedSignature ( Base64 . decode ( base64EncodedSignature , Base64 . DEFAULT ). toString ( Charsets . UTF_8 ) ) /** * Integrity package * */ private val integrity = KevlarIntegrity { checks { packageName { hardcodedPackageName ( base64ObfuscatedHardcodedPackageName ) } signature { hardcodedSignatures ( base64ObfuscatedHardcodedSignatures ) } installer () debug () } } /** * Assestation request & callback * +/ CoroutineScope ( Dispatchers . Default ). launch { // Attestation request when ( val attestation = integrity . attestate ( context )) { is IntegrityAttestation . Blank -> { // Pending attestation, no information yet. // Don't do anything. } is IntegrityAttestation . Clear -> { // Good to go. } is IntegrityAttestation . Failed -> { // One or more checks have failed. } } } This packs everything in one file. It is not excellent when writing a modern applications but it does its job. ViewModel + Repository + SharedFlow + DI with Hilt \u00b6 Activity: \u00b6 IntegrityActivity.kt @AndroidEntryPoint class IntegrityActivity : AppCompatActivity () { private val vm : ActivityViewModel by viewModels () override fun onCreate ( savedInstanceState : Bundle?) { super . onCreate ( savedInstanceState ) lifecycleScope . launch { lifecycle . repeatOnLifecycle ( Lifecycle . State . STARTED ) { vm . attestation . collectLatest { when ( it ) { is IntegrityAttestation . Blank -> { // Pending attestation, no information yet. // Don't do anything. } is IntegrityAttestation . Clear -> { // Good to go. } is IntegrityAttestation . Failed -> { // Pirate software detected. } } } } } CoroutineScope ( Dispatchers . Main ). launch { vm . requestAttestation () } } } View model: \u00b6 ActivityViewModel.kt @HiltViewModel class ActivityViewModel @Inject constructor ( private val integrityRepository : IntegrityRepository ) : ViewModel () { private val _attestation = MutableStateFlow ( KevlarIntegrity . blankAttestation ()) internal val attestation : SharedFlow < IntegrityAttestation > = _attestation . stateIn ( viewModelScope , SharingStarted . Eagerly , initialValue = KevlarIntegrity . blankAttestation () ) fun requestAttestation () { viewModelScope . launch { _attestation . value = integrityRepository . attestate () } } } Repository \u00b6 IntegrityRepository.kt class IntegrityRepository @Inject constructor ( @ApplicationContext val context : Context , @IoDispatcher val externalDispatcher : CoroutineDispatcher ) { /** * Base64 obfuscated package name * */ private val base64PackageName = \"\"\"Y29tLmtldmxhci5zaG93Y2FzZQ==\"\"\" . toByteArray () private val base64Signature = \"\"\"SitucVhMZnVJTzhCMkFtaGtNWUhHRTRqRHl3PQ==\"\"\" . toByteArray () private val base64ObfuscatedHardcodedPackageName = HardcodedPackageName ( packageName = Base64 . decode ( base64PackageName , Base64 . DEFAULT ). toString ( Charsets . UTF_8 ) ) private val base64ObfuscatedHardcodedSignatures = HardcodedBase64EncodedSignature ( Base64 . decode ( base64Signature , Base64 . DEFAULT ). toString ( Charsets . UTF_8 ) ) /** * Integrity package * */ private val integrity = KevlarIntegrity { checks { packageName { hardcodedPackageName ( base64ObfuscatedHardcodedPackageName ) } signature { hardcodedSignatures ( base64ObfuscatedHardcodedSignatures ) } installer () debug () } } suspend fun attestate (): IntegrityAttestation = withContext ( externalDispatcher ) { integrity . attestate ( context ) } }","title":"Implementation"},{"location":"pages/modules/integrity/implementation/#implementation","text":"Implementing integrity requires, on top of a KevlarAntipiracy and the attestation infrastructure, a bit of information about your application's metadata, which will be hardcoded inside it. Hardcoded data is necessary to provide kevlar a truth value (essentially, that should be the description of all the scenarios that the application is allowed to run in) to match the runtime values of your binary (which may have been tampered or altered by an attacker) against. That's because, if done well, we can detect almost every kind of attack/tampering attempt through checking various APK metadata, such as the package name, the signature, the installer and debug flags. The obfuscation is necessary because we need to conceal the truth values, since they will be looked for by the attacker (software or human), and make it as hard as possible to automatically find and patch them. A working example for the integrity module can be found in the github repository under the :showcase module.","title":"Implementation"},{"location":"pages/modules/integrity/implementation/#dependency","text":"Gradle dependencies { implementation \"io.github.kevlar-kt:integrity:1.1.1\" } Kotlin DSL dependencies { implementation ( \"io.github.kevlar-kt:integrity:1.1.1\" ) } Maven <dependency> <groupId> io.github.kevlar-kt </groupId> <artifactId> integrity </artifactId> <version> 1.1.1 </version> <type> pom </type> </dependency>","title":"Dependency"},{"location":"pages/modules/integrity/implementation/#hardcoded-metadata","text":"","title":"Hardcoded metadata"},{"location":"pages/modules/integrity/implementation/#understanding-which-metadata-you-need","text":"The first step is choosing which checks to run, and thus which data to provide kevlar. The good news is that they all are stable metadata. This means that once you make the effort of searching the right strings and implementing everything, you are ideally good to go forever. Kevlar has 4 kinds of checks: a package name check, a signature check, an installer check and a debug check. Check Type Required parameters Parameter type Package Name package name String Signature Check app signature String (base64-encoded) Installer Check N/A N/A Debug Check N/A N/A The hardcoded metadata you need to find is the following: Your application package name : Will check that the running binary's package name matches the hardcoded package name; Your application signature : Will check that the running binary's signature is the same as the hardcoded signature. Additionally, you should consider enabling the other two kinds of checks: Debug checks : Is enabled, kevlar autonomously checks for debug flags and bits in your binary; Installer checks : If enabled, kevlar will report any application which has not been installed through an allowed installer (by default it only supports the Play Store, but you can add custom stores if you distribute your software elsewhere). Once you choose which kind of checks you want to run, you get the required metadata hardcoded_metadata.kt // Holds the package name private val packageNameData = HardcodedPackageName ( packageName = \"com.kevlar.showcase\" ) // Holds the signature private val signatureData = HardcodedBase64EncodedSignature ( base64EncodedSignature = \"J+nqXLfuIO8B2AmhkMYHGE4jDyw=\" ) // Combines all the metadata and configuration private val integrity = KevlarIntegrity { checks { packageName { hardcodedPackageName ( packageNameData ) } signature { hardcodedSignatures ( signatureData ) } installer () debug () } } // Runs the checks on the current executing app integrity . attestate ( context ) Do not Maybe, just maybe, you may be tempted to so something like this: VERY_BAD_hardcoded_metadata.kt private val notAtAllHardcodedMetadata = HardcodedMetadata ( packageName = context . getPackageName (), signature = getRuntimeSignature () ) The sole purpose of HardcodedMetadata is hardcoding truth values inside your app, which don't depend on the context or application, which may have been tampered with . This snippet single handedly kills the whole library (because kevlar will check that the (supposedly) hardcoded package name, in this case context.getPackageName() , matches the runtime package name, which is always true since it is gathered via context.getPackageName() too) and is like shooting yourself in the foot with a cannon. Don't.","title":"Understanding which metadata you need"},{"location":"pages/modules/integrity/implementation/#finding-metadata","text":"Finding the package name is easy, since you are the one choosing it for your application. For the signature, it's not so straightforward to extract because it depends on your keystore. You have two different ways to get your keystore signature. In the examples we will find the debug signature, but you need to find the signature of the keystore you use to sign your application when publishing on google play.","title":"Finding metadata"},{"location":"pages/modules/integrity/implementation/#direct-application-extraction","text":"The most practical way to read your keystore it is to put the following line of code in your app, to then sign the application with the key you are interested in acquiring the signature string of, and run it. // This returns the signature of the current running application. val signature : String = KevlarIntegrity . obtainCurrentAppSignature ( context ) This will output the current app signature. That's the reference string you need to give to kevlar (which will extract the runtime signature of your app and match it against that string). Android debug signature Every android application is signed with some key. When an application is signed as \"debug\", it simply means that it is signed with a special key, which is known to be the debug key. Signature extraction & Google Play App Signing API If you are using Google Play App Signing, the key you sign your application with is not the one your app is distributed with (See the official docs regarding the matter, and a relevant issue in kevlar). In this case the easiest way to get your actual signature would be to upload a dummy version of your app (which logs the runtime signature) through google play store, let the backend process and sign it, download it (through the archive manager on the play console), install & run it locally on an emulator/device, and save the runtime signature. Once you have done this (quite tedious) procedure, you have your signature and can pass it to kevlar.","title":"Direct application extraction"},{"location":"pages/modules/integrity/implementation/#android-studio-extraction","text":"Running ./gradlew signingReport will spit out all the details for all the different keystores in your project. The signature we are interested in is the SHA-1 entry. In this case, 27:E9:EA:5C:B7:EE:20:EF:01:D8:09:A1:90:C6:07:18:4E:23:0F:2C . > Task :showcase:signingReport Variant: debug Config: debug Store: /Users/cioccarellia/.android/debug.keystore Alias: AndroidDebugKey MD5: 1B:AF:39:46:4E:13:83:F3:45:E9:0A:5A:53:64:9C:CB SHA1: 27:E9:EA:5C:B7:EE:20:EF:01:D8:09:A1:90:C6:07:18:4E:23:0F:2C SHA-256: 36:C8:C0:A1:8A:DD:6D:0E:34:F9:6E:7E:98:DC:1F:89:08:BC:CD:2E:EF:88:ED:45:DF:79:85:D2:39:BD:E1:54 Valid until: Tuesday, June 25, 2052 ---------- Variant: release Config: null Store: null Alias: null ---------- We then have to convert it in a string form (like that we have the raw hex bytes, we want a base64 encoding of the binary signature). In this case the conversion (you can use online tools to do this) yields J+nqXLfuIO8B2AmhkMYHGE4jDyw= . Play Signing Since we don't have access to the keystore file if we use Play Signing, this method is not viable in that case, and you have to resort to uploading a dummy version of the app, download its play-signed version through the releases page, and extract the signature from that APK file.","title":"Android studio extraction"},{"location":"pages/modules/integrity/implementation/#obfuscating-metadata","text":"The second step (optional but recommended) is obfuscating the metadata you just gathered, so that it is saved in an obfuscated form (in your bytecode, so that automatic tools / unskilled attackers can't easily find it), but passed to kevlar deobfuscated (so that we have the original truth values at run time). This means that we ship with out app the obfuscated data and the way to convert that obfuscated data back to plaintext to feed kevlar. There are a few different ways to do it, all of them are fully implemented in the :showcase module:","title":"Obfuscating metadata"},{"location":"pages/modules/integrity/implementation/#no-obfuscation-not-recommended","text":"In this case you just save the values as they are, and pass them in HardcodedMetadata unobfuscated_hardcoded_metadata.kt private const val packageName = HardcodedPackageName ( \"com.kevlar.showcase\" ) private const val signature = HardcodedBase64EncodedSignature ( \"J+nqXLfuIO8B2AmhkMYHGE4jDyw=\" ) Bytecode The produced kotlin bytecode clearly exposes the raw values: 1 2 3 4 5 6 7 8 9 10 11 L1 ALOAD 0 NEW com/kevlar/integrity/model/HardcodedMetadata DUP L2 LDC \"com.kevlar.showcase\" L3 LDC \"J+nqXLfuIO8B2AmhkMYHGE4jDyw=\" L4 INVOKESPECIAL com/kevlar/integrity/model/HardcodedMetadata.<init> (Ljava/lang/String;Ljava/lang/String;)V PUTFIELD com/kevlar/showcase/data/repo/IntegrityRepository.hardcodedMetadata : Lcom/kevlar/integrity/model/HardcodedMetadata;","title":"No obfuscation (not recommended)"},{"location":"pages/modules/integrity/implementation/#base64-obfuscation","text":"You store the package name and signature values as Base64-encoded byte arrays, and they go through the Base64.decode() function when creating HardcodedMetadata . base64_obfuscated_hardcoded_metadata.kt private val packageName = \"\"\"Y29tLmtldmxhci5zaG93Y2FzZQ==\"\"\" . toByteArray () private val signature = \"\"\"SitucVhMZnVJTzhCMkFtaGtNWUhHRTRqRHl3PQ==\"\"\" . toByteArray () private val base64ObfuscatedHardcodedPackageName = HardcodedPackageName ( packageName = Base64 . decode ( base64PackageName , Base64 . DEFAULT ). toString ( Charsets . UTF_8 ) ) private val base64ObfuscatedHardcodedSignature = HardcodedBase64EncodedSignature ( Base64 . decode ( base64Signature , Base64 . DEFAULT ). toString ( Charsets . UTF_8 ) ) Where Y29tLmtldmxhci5zaG93Y2FzZQ== is the base64 encoding of com.kevlar.showcase , and SitucVhMZnVJTzhCMkFtaGtNWUhHRTRqRHl3PQ== of J+nqXLfuIO8B2AmhkMYHGE4jDyw= (the signature). You can look them up online , grab them from your app or use openssl base64 in the terminal. Base64 flags & charset The flag field and charset don't necessarily need to be Base64.DEFAULT and UTF_8 . Even though they are the most popular, you may choose something else if you prefer, as long as you preserve consistency. Bytecode Here the metadata is hidden and not targetable with basic find-and-replace techniques 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 L6 ALOAD 0 LDC \"Y29tLmtldmxhci5zaG93Y2FzZQ==\" ASTORE 3 GETSTATIC kotlin/text/Charsets.UTF_8 : Ljava/nio/charset/Charset; ASTORE 4 L7 ALOAD 3 L8 ALOAD 4 INVOKEVIRTUAL java/lang/String.getBytes (Ljava/nio/charset/Charset;)[B DUP LDC \"(this as java.lang.String).getBytes(charset)\" INVOKESTATIC kotlin/jvm/internal/Intrinsics.checkNotNullExpressionValue (Ljava/lang/Object;Ljava/lang/String;)V L9 PUTFIELD com/kevlar/showcase/data/repo/IntegrityRepository.packageName : [B L10 ALOAD 0 LDC \"SitucVhMZnVJTzhCMkFtaGtNWUhHRTRqRHl3PQ==\" ASTORE 3 GETSTATIC kotlin/text/Charsets.UTF_8 : Ljava/nio/charset/Charset; ASTORE 4 L11 ALOAD 3 L12 ALOAD 4 INVOKEVIRTUAL java/lang/String.getBytes (Ljava/nio/charset/Charset;)[B DUP LDC \"(this as java.lang.String).getBytes(charset)\" INVOKESTATIC kotlin/jvm/internal/Intrinsics.checkNotNullExpressionValue (Ljava/lang/Object;Ljava/lang/String;)V L13 PUTFIELD com/kevlar/showcase/data/repo/IntegrityRepository.signature : [B L14 ALOAD 0 NEW com/kevlar/integrity/model/HardcodedMetadata DUP L15 ALOAD 0 GETFIELD com/kevlar/showcase/data/repo/IntegrityRepository.packageName : [B ICONST_0 INVOKESTATIC android/util/Base64.decode ([BI)[B DUP LDC \"Base64.decode(packageName, Base64.DEFAULT)\" INVOKESTATIC kotlin/jvm/internal/Intrinsics.checkNotNullExpressionValue (Ljava/lang/Object;Ljava/lang/String;)V ASTORE 3 GETSTATIC kotlin/text/Charsets.UTF_8 : Ljava/nio/charset/Charset; ASTORE 4 L16 NEW java/lang/String DUP ALOAD 3 ALOAD 4 INVOKESPECIAL java/lang/String.<init> ([BLjava/nio/charset/Charset;)V L17 L18 ALOAD 0 GETFIELD com/kevlar/showcase/data/repo/IntegrityRepository.signature : [B ICONST_0 INVOKESTATIC android/util/Base64.decode ([BI)[B DUP LDC \"Base64.decode(signature, Base64.DEFAULT)\" INVOKESTATIC kotlin/jvm/internal/Intrinsics.checkNotNullExpressionValue (Ljava/lang/Object;Ljava/lang/String;)V ASTORE 3 GETSTATIC kotlin/text/Charsets.UTF_8 : Ljava/nio/charset/Charset; ASTORE 4 L19 NEW java/lang/String DUP ALOAD 3 ALOAD 4 INVOKESPECIAL java/lang/String.<init> ([BLjava/nio/charset/Charset;)V L20 L21 INVOKESPECIAL com/kevlar/integrity/model/HardcodedMetadata.<init> (Ljava/lang/String;Ljava/lang/String;)V PUTFIELD com/kevlar/showcase/data/repo/IntegrityRepository.base64ObfuscatedHardcodedMetadata : Lcom/kevlar/integrity/model/HardcodedMetadata;","title":"Base64 obfuscation"},{"location":"pages/modules/integrity/implementation/#encryption-base64","text":"A better alternative is to encrypt the hardcoded metadata, store them in an encrypted form, and send them through a decryption function when creating HardcodedMetadata . encrypted_hardcoded_metadata.kt // Our arbitrary 256-bit encryption key private val aesKey256 = \"\"\"4t7w!z%C*F-JaNcRfUjXn2r5u8x/A?Ds\"\"\" // This is \"com.kevlar.showcase\", encrypted using AES256 with the previous key private val encryptedPackageName = \"\"\"s3wf/AOYtr9BEMVFrweeLnkmerryUykMA8O77S5tMlI=\"\"\" . toByteArray () // This is \"J+nqXLfuIO8B2AmhkMYHGE4jDyw=\", encrypted using AES256 with the previous key private val encryptedSignature = \"\"\"tqMJquO3D+EKx1rx4R7/qzmsuEgpp1bKwxXe9AeB/WU=\"\"\" . toByteArray () private val aes256EncryptedHardcodedPackageName = HardcodedPackageName ( packageName = EncryptionUtil . decrypt ( encryptedPackageName , EncryptionUtil . generateKey ( aesKey256 ) ) ) private val aes256EncryptedHardcodedSignatures = HardcodedBase64EncodedSignature ( EncryptionUtil . decrypt ( encryptedSignature , EncryptionUtil . generateKey ( aesKey256 )) ) Where 7KAa2CFkhPQOUouDu32KZJLqOzGFbTTnJA3rGxMlAg4= is the encrypted value of com.kevlar.showcase , and +ylMx63kwFRmXKHQU0cbzyb8MJ1iiGW1g8+MjDRcS/o= of J+nqXLfuIO8B2AmhkMYHGE4jDyw= . This ensures that there is no possibility that an automatic attack picks up the string as a package name or signature, and trivial string substitutions or encodings like base64 won't give any information away (the ciphertext is encoded in base64). AES128 or AES256 is recommended as the encryption algorithm (it's a little overkill but it does the job). The ciphertext may also be stored as a byte array. Encryption utility This tiny class (from the showcase module in the repository) is a basic AES encryption/decryption utility. EncryptionUtil.kt import android.util.Base64 import javax.crypto.Cipher import javax.crypto.SecretKey import javax.crypto.spec.SecretKeySpec object EncryptionUtil { private const val algorithm = \"AES\" private const val transformation = \"AES/ECB/PKCS5Padding\" fun generateKey ( key : String ): SecretKey = SecretKeySpec ( key . toByteArray (), algorithm ) fun encrypt ( text : ByteArray , secret : SecretKey ): String { val cipher : Cipher = Cipher . getInstance ( transformation ). apply { init ( Cipher . ENCRYPT_MODE , secret ) } return Base64 . encodeToString ( cipher . doFinal ( text ), Base64 . NO_WRAP ) ?: \"\" } fun decrypt ( ciphertext : ByteArray , secret : SecretKey ): String { val cipher : Cipher = Cipher . getInstance ( transformation ). apply { init ( Cipher . DECRYPT_MODE , secret ) } return String ( cipher . doFinal ( Base64 . decode ( ciphertext , Base64 . NO_WRAP )), Charsets . UTF_8 ) } } Bytecode Here detecting and reconstructing the original package name automatically is basically impossible 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 L22 ALOAD 0 LDC \"4t7w!z%C*F-JaNcRfUjXn2r5u8x/A?Ds\" PUTFIELD com/kevlar/showcase/data/repo/IntegrityRepository.key256 : Ljava/lang/String; L23 ALOAD 0 LDC \"s3wf/AOYtr9BEMVFrweeLnkmerryUykMA8O77S5tMlI=\" ASTORE 3 GETSTATIC kotlin/text/Charsets.UTF_8 : Ljava/nio/charset/Charset; ASTORE 4 L24 ALOAD 3 L25 ALOAD 4 INVOKEVIRTUAL java/lang/String.getBytes (Ljava/nio/charset/Charset;)[B DUP LDC \"(this as java.lang.String).getBytes(charset)\" INVOKESTATIC kotlin/jvm/internal/Intrinsics.checkNotNullExpressionValue (Ljava/lang/Object;Ljava/lang/String;)V L26 PUTFIELD com/kevlar/showcase/data/repo/IntegrityRepository.encryptedPackageName : [B L27 ALOAD 0 LDC \"tqMJquO3D+EKx1rx4R7/qzmsuEgpp1bKwxXe9AeB/WU=\" ASTORE 3 GETSTATIC kotlin/text/Charsets.UTF_8 : Ljava/nio/charset/Charset; ASTORE 4 L28 ALOAD 3 L29 ALOAD 4 INVOKEVIRTUAL java/lang/String.getBytes (Ljava/nio/charset/Charset;)[B DUP LDC \"(this as java.lang.String).getBytes(charset)\" INVOKESTATIC kotlin/jvm/internal/Intrinsics.checkNotNullExpressionValue (Ljava/lang/Object;Ljava/lang/String;)V L30 PUTFIELD com/kevlar/showcase/data/repo/IntegrityRepository.encryptedSignature : [B L31 ALOAD 0 NEW com/kevlar/integrity/model/HardcodedMetadata DUP L32 GETSTATIC com/kevlar/showcase/util/EncryptionUtil.INSTANCE : Lcom/kevlar/showcase/util/EncryptionUtil; ALOAD 0 GETFIELD com/kevlar/showcase/data/repo/IntegrityRepository.encryptedPackageName : [B GETSTATIC com/kevlar/showcase/util/EncryptionUtil.INSTANCE : Lcom/kevlar/showcase/util/EncryptionUtil; ALOAD 0 GETFIELD com/kevlar/showcase/data/repo/IntegrityRepository.key256 : Ljava/lang/String; INVOKEVIRTUAL com/kevlar/showcase/util/EncryptionUtil.generateKey (Ljava/lang/String;)Ljavax/crypto/SecretKey; INVOKEVIRTUAL com/kevlar/showcase/util/EncryptionUtil.decrypt ([BLjavax/crypto/SecretKey;)Ljava/lang/String; L33 GETSTATIC com/kevlar/showcase/util/EncryptionUtil.INSTANCE : Lcom/kevlar/showcase/util/EncryptionUtil; ALOAD 0 GETFIELD com/kevlar/showcase/data/repo/IntegrityRepository.encryptedSignature : [B GETSTATIC com/kevlar/showcase/util/EncryptionUtil.INSTANCE : Lcom/kevlar/showcase/util/EncryptionUtil; ALOAD 0 GETFIELD com/kevlar/showcase/data/repo/IntegrityRepository.key256 : Ljava/lang/String; INVOKEVIRTUAL com/kevlar/showcase/util/EncryptionUtil.generateKey (Ljava/lang/String;)Ljavax/crypto/SecretKey; INVOKEVIRTUAL com/kevlar/showcase/util/EncryptionUtil.decrypt ([BLjavax/crypto/SecretKey;)Ljava/lang/String; L34 INVOKESPECIAL com/kevlar/integrity/model/HardcodedMetadata.<init> (Ljava/lang/String;Ljava/lang/String;)V PUTFIELD com/kevlar/showcase/data/repo/IntegrityRepository.aes256EncryptedHardcodedMetadata : Lcom/kevlar/integrity/model/HardcodedMetadata;","title":"Encryption (+base64)"},{"location":"pages/modules/integrity/implementation/#hashing","text":"This hasn't been developed yet, but it may be possible to let kevlar know only the hash of your hardcoded data, and let it match directly on the runtime signatures and package names hashes. This would require multiple options of composite hash functions to be secure enough. It is not implemented.","title":"Hashing"},{"location":"pages/modules/integrity/implementation/#initialization-attestations","text":"You need to create a KevlarIntegrity instance (which is the way you will be requesting attestations), along with your desired parameters (either global, local or in your repository layer, if you are using MVVM/MVC). Once you have that, you just go ahead and call integrity.attestate() in a coroutine and your application running metadata will be checked, according to the provided parameters. IntegrityAttestation will be returned from the call (it's a sealed class), containing the checks which failed, if any. Note that we will be initializing KevlarIntegrity with custom scan settings, but you could leave it as default.","title":"Initialization &amp; Attestations"},{"location":"pages/modules/integrity/implementation/#in-place","text":"This is the most concise (and complete) way to implement this package. InPlace.kt /** * Base64 obfuscated package name and signature * */ // Original value is \"com.kevlar.showcase\", the package name hardcoded value private val base64EncodedPackageName = \"\"\"Y29tLmtldmxhci5zaG93Y2FzZQ==\"\"\" . toByteArray () private val base64ObfuscatedHardcodedPackageName = HardcodedPackageName ( packageName = Base64 . decode ( base64EncodedPackageName , Base64 . DEFAULT ). toString ( Charsets . UTF_8 ) ) // Original value is \"J+nqXLfuIO8B2AmhkMYHGE4jDyw=\", the signature hardcoded value private val base64EncodedSignature = \"\"\"SitucVhMZnVJTzhCMkFtaGtNWUhHRTRqRHl3PQ==\"\"\" . toByteArray () private val base64ObfuscatedHardcodedSignatures = HardcodedBase64EncodedSignature ( Base64 . decode ( base64EncodedSignature , Base64 . DEFAULT ). toString ( Charsets . UTF_8 ) ) /** * Integrity package * */ private val integrity = KevlarIntegrity { checks { packageName { hardcodedPackageName ( base64ObfuscatedHardcodedPackageName ) } signature { hardcodedSignatures ( base64ObfuscatedHardcodedSignatures ) } installer () debug () } } /** * Assestation request & callback * +/ CoroutineScope ( Dispatchers . Default ). launch { // Attestation request when ( val attestation = integrity . attestate ( context )) { is IntegrityAttestation . Blank -> { // Pending attestation, no information yet. // Don't do anything. } is IntegrityAttestation . Clear -> { // Good to go. } is IntegrityAttestation . Failed -> { // One or more checks have failed. } } } This packs everything in one file. It is not excellent when writing a modern applications but it does its job.","title":"In-Place"},{"location":"pages/modules/integrity/implementation/#viewmodel-repository-sharedflow-di-with-hilt","text":"","title":"ViewModel + Repository + SharedFlow + DI with Hilt"},{"location":"pages/modules/integrity/implementation/#activity","text":"IntegrityActivity.kt @AndroidEntryPoint class IntegrityActivity : AppCompatActivity () { private val vm : ActivityViewModel by viewModels () override fun onCreate ( savedInstanceState : Bundle?) { super . onCreate ( savedInstanceState ) lifecycleScope . launch { lifecycle . repeatOnLifecycle ( Lifecycle . State . STARTED ) { vm . attestation . collectLatest { when ( it ) { is IntegrityAttestation . Blank -> { // Pending attestation, no information yet. // Don't do anything. } is IntegrityAttestation . Clear -> { // Good to go. } is IntegrityAttestation . Failed -> { // Pirate software detected. } } } } } CoroutineScope ( Dispatchers . Main ). launch { vm . requestAttestation () } } }","title":"Activity:"},{"location":"pages/modules/integrity/implementation/#view-model","text":"ActivityViewModel.kt @HiltViewModel class ActivityViewModel @Inject constructor ( private val integrityRepository : IntegrityRepository ) : ViewModel () { private val _attestation = MutableStateFlow ( KevlarIntegrity . blankAttestation ()) internal val attestation : SharedFlow < IntegrityAttestation > = _attestation . stateIn ( viewModelScope , SharingStarted . Eagerly , initialValue = KevlarIntegrity . blankAttestation () ) fun requestAttestation () { viewModelScope . launch { _attestation . value = integrityRepository . attestate () } } }","title":"View model:"},{"location":"pages/modules/integrity/implementation/#repository","text":"IntegrityRepository.kt class IntegrityRepository @Inject constructor ( @ApplicationContext val context : Context , @IoDispatcher val externalDispatcher : CoroutineDispatcher ) { /** * Base64 obfuscated package name * */ private val base64PackageName = \"\"\"Y29tLmtldmxhci5zaG93Y2FzZQ==\"\"\" . toByteArray () private val base64Signature = \"\"\"SitucVhMZnVJTzhCMkFtaGtNWUhHRTRqRHl3PQ==\"\"\" . toByteArray () private val base64ObfuscatedHardcodedPackageName = HardcodedPackageName ( packageName = Base64 . decode ( base64PackageName , Base64 . DEFAULT ). toString ( Charsets . UTF_8 ) ) private val base64ObfuscatedHardcodedSignatures = HardcodedBase64EncodedSignature ( Base64 . decode ( base64Signature , Base64 . DEFAULT ). toString ( Charsets . UTF_8 ) ) /** * Integrity package * */ private val integrity = KevlarIntegrity { checks { packageName { hardcodedPackageName ( base64ObfuscatedHardcodedPackageName ) } signature { hardcodedSignatures ( base64ObfuscatedHardcodedSignatures ) } installer () debug () } } suspend fun attestate (): IntegrityAttestation = withContext ( externalDispatcher ) { integrity . attestate ( context ) } }","title":"Repository"},{"location":"pages/modules/integrity/integrity/","text":"Integrity \u00b6 graph LR I[Inizialization] -.Settings..-> K{KevlarIntegrity}; DB([Hardcoded & Obfuscated Metadata]) === K AR1[Attestation Requests] --> K K --> |Clear| P[Passed]; K --> |Failed| NP[Not Passed]; P --> A[IntegrityAssestation] NP --> A The integrity package contains tools for the detection of tampering attempts against your app. It requires a bit of effort to implement (you need to find, code and obfuscate your app metadata, all the instructions are in implementation ), but once you have it runs quickly and works extremely well. It is capable of detecting: Signature mismatches (the running app's signature and the hardcoded signature are different) Package name mismatches (the running app's package name and the hardcoded package name are different) Debuggable flag (the running app is debuggable, which should never happen for production apps) Disallowed Installers (the running app has been installed through a disallowed package installer) Purpose of the integrity package You want to use this package if you need to give your app a layer of protection against tampering attacks (see anatomy for more details). Enabling just a few checks and implementing basic obfuscation will make your app harder to crack. Warning This package is the best defense against automatic and/or unskilled attacks. If implemented well, it will kill off most of them To implement this, you initialize KevlarIntegrity and provide your desired settings (which influence what is to be checked and what not). Then you can submit attestation requests (which will be executed according to your settings). Empty & default settings The settings on integrity are additive. If you leave a blank DSL, nothing will be detected, because no checks will be run, because the settings are empty. By default, only debug and installer checks are enbabled, since you need to provide additional arguments to enable signature and packageName If you do not pass a DSL at all, the default settings will be used (they scan for signature, package name, and debug). Custom (simplified) private val integrity = KevlarIntegrity { checks { packageName () { // Allowed package name hardcodedPackageName ( \"com.kevlar.showcase\" ) } signature () { // Allowed signature hardcodedSignatures ( \"J+nqXLfuIO8B2AmhkMYHGE4jDyw=\" ) } debug () installer () } } Empty private val integrity = KevlarIntegrity { checks { } } Default private val integrity = KevlarIntegrity () Attestation process overview \u00b6 When you require an attestation (through integrity.attestate(context) ), kevlar executes the following operations: Depending on what integrity checks you selected, the appropriate battery of tests for those targets is initialized and run; The results are collected, processed, filtered, and returned. There is only one type of attestation that can be produced. The attestation is returned in IntegrityAttestation (it is a sealed class), which depending on the detection status can be of three types: Blank : This is a non-processed status. It should not be interpreted, as it does not carry any meaning about the attestation result. It is not to be interpreted as Clear ; Clear : The attestation has passed. There is nothing to report. This means that no system modification/status has triggered the detection from the battery of tests that have been executed, in compliance with the given check parameters; Failed : The attestation has not passed. Integrity or tampering issues have been detected. You can check which check has failed (which inconsistency has been found between the hardcoded and runtime values) in the attestation result. Warning Blank is completely different from Clear (or Failed ). It means that the software is initialized but that nothing has been done yet. Do not mix them up. Use cases \u00b6 This is a pretty typical scenario for any application where it is critical to preserve self-integrity and run unmodified code.","title":"Overview"},{"location":"pages/modules/integrity/integrity/#integrity","text":"graph LR I[Inizialization] -.Settings..-> K{KevlarIntegrity}; DB([Hardcoded & Obfuscated Metadata]) === K AR1[Attestation Requests] --> K K --> |Clear| P[Passed]; K --> |Failed| NP[Not Passed]; P --> A[IntegrityAssestation] NP --> A The integrity package contains tools for the detection of tampering attempts against your app. It requires a bit of effort to implement (you need to find, code and obfuscate your app metadata, all the instructions are in implementation ), but once you have it runs quickly and works extremely well. It is capable of detecting: Signature mismatches (the running app's signature and the hardcoded signature are different) Package name mismatches (the running app's package name and the hardcoded package name are different) Debuggable flag (the running app is debuggable, which should never happen for production apps) Disallowed Installers (the running app has been installed through a disallowed package installer) Purpose of the integrity package You want to use this package if you need to give your app a layer of protection against tampering attacks (see anatomy for more details). Enabling just a few checks and implementing basic obfuscation will make your app harder to crack. Warning This package is the best defense against automatic and/or unskilled attacks. If implemented well, it will kill off most of them To implement this, you initialize KevlarIntegrity and provide your desired settings (which influence what is to be checked and what not). Then you can submit attestation requests (which will be executed according to your settings). Empty & default settings The settings on integrity are additive. If you leave a blank DSL, nothing will be detected, because no checks will be run, because the settings are empty. By default, only debug and installer checks are enbabled, since you need to provide additional arguments to enable signature and packageName If you do not pass a DSL at all, the default settings will be used (they scan for signature, package name, and debug). Custom (simplified) private val integrity = KevlarIntegrity { checks { packageName () { // Allowed package name hardcodedPackageName ( \"com.kevlar.showcase\" ) } signature () { // Allowed signature hardcodedSignatures ( \"J+nqXLfuIO8B2AmhkMYHGE4jDyw=\" ) } debug () installer () } } Empty private val integrity = KevlarIntegrity { checks { } } Default private val integrity = KevlarIntegrity ()","title":"Integrity"},{"location":"pages/modules/integrity/integrity/#attestation-process-overview","text":"When you require an attestation (through integrity.attestate(context) ), kevlar executes the following operations: Depending on what integrity checks you selected, the appropriate battery of tests for those targets is initialized and run; The results are collected, processed, filtered, and returned. There is only one type of attestation that can be produced. The attestation is returned in IntegrityAttestation (it is a sealed class), which depending on the detection status can be of three types: Blank : This is a non-processed status. It should not be interpreted, as it does not carry any meaning about the attestation result. It is not to be interpreted as Clear ; Clear : The attestation has passed. There is nothing to report. This means that no system modification/status has triggered the detection from the battery of tests that have been executed, in compliance with the given check parameters; Failed : The attestation has not passed. Integrity or tampering issues have been detected. You can check which check has failed (which inconsistency has been found between the hardcoded and runtime values) in the attestation result. Warning Blank is completely different from Clear (or Failed ). It means that the software is initialized but that nothing has been done yet. Do not mix them up.","title":"Attestation process overview"},{"location":"pages/modules/integrity/integrity/#use-cases","text":"This is a pretty typical scenario for any application where it is critical to preserve self-integrity and run unmodified code.","title":"Use cases"},{"location":"pages/modules/integrity/reference/","text":"Reference \u00b6 The complete integrity configuration is as follows. Complete settings private val integrity = KevlarIntegrity { checks { packageName () { // Allowed package name hardcodedPackageName ( \"com.kevlar.showcase\" ) } signature () { // Allowed signature hardcodedSignatures ( \"J+nqXLfuIO8B2AmhkMYHGE4jDyw=\" ) } debug () installer () } } Once you require the attestation through attestate(context) , any integrity mismatch that you requested will be included in the attestation. withContext ( externalDispatcher ) { val attestation = integrity . attestate ( context ) } Package name check \u00b6 The packageName() function tells kevlar to enable the integrity checks for the application package name. This is a parametric setting, since kevlar needs to know what is the \"right\" application package name is. Once kevlar has all the required data it is able to differentiate between genuine and tampered binaries. private val integrity = KevlarIntegrity { checks { packageName () { // Allowed package name hardcodedPackageName ( \"com.kevlar.showcase\" ) } signature () { // Allowed signature hardcodedSignatures ( \"J+nqXLfuIO8B2AmhkMYHGE4jDyw=\" ) } debug () installer () } } You can find instruction on where to find the right parameters in implementation . In this case you simply have to pass in the package name of your app, so kevlar knows what is the right package. Signature check \u00b6 The signature() function tells kevlar to enable the integrity checks for the application signature. This is a parametric setting, since kevlar needs to know what is the \"right\" application signature is. Once kevlar has all the required data it is able to differentiate between genuine and tampered binaries. private val integrity = KevlarIntegrity { checks { packageName () { // Allowed package name hardcodedPackageName ( \"com.kevlar.showcase\" ) } signature () { // Allowed signature hardcodedSignatures ( \"J+nqXLfuIO8B2AmhkMYHGE4jDyw=\" ) } debug () installer () } } You can find instruction on where to find the right parameters in implementation . Debug check \u00b6 The debug() function tells kevlar to enable integrity debug checks. private val integrity = KevlarIntegrity { checks { packageName () { // Allowed package name hardcodedPackageName ( \"com.kevlar.showcase\" ) } signature () { // Allowed signature hardcodedSignatures ( \"J+nqXLfuIO8B2AmhkMYHGE4jDyw=\" ) } debug () installer () } } If debug flags are found on your application it will be reported. Installer check \u00b6 The installer() function tells kevlar to enable installer checks. Since android R, google introduced APIs to check the original installer of a certain package. With this check, you can instruct kevlar to analyze that installer (if available) and detect whether it is allowed or not by your security policy. In this case, the only allowed installer package is the Google Play Store, but you can always add more through the allowInstaller function. private val integrity = KevlarIntegrity { checks { packageName () { // Allowed package name hardcodedPackageName ( \"com.kevlar.showcase\" ) } signature () { // Allowed signature hardcodedSignatures ( \"J+nqXLfuIO8B2AmhkMYHGE4jDyw=\" ) } debug () installer () { allowInstaller ( \"com.sec.android.app.samsungapps\" ) } } }","title":"Reference"},{"location":"pages/modules/integrity/reference/#reference","text":"The complete integrity configuration is as follows. Complete settings private val integrity = KevlarIntegrity { checks { packageName () { // Allowed package name hardcodedPackageName ( \"com.kevlar.showcase\" ) } signature () { // Allowed signature hardcodedSignatures ( \"J+nqXLfuIO8B2AmhkMYHGE4jDyw=\" ) } debug () installer () } } Once you require the attestation through attestate(context) , any integrity mismatch that you requested will be included in the attestation. withContext ( externalDispatcher ) { val attestation = integrity . attestate ( context ) }","title":"Reference"},{"location":"pages/modules/integrity/reference/#package-name-check","text":"The packageName() function tells kevlar to enable the integrity checks for the application package name. This is a parametric setting, since kevlar needs to know what is the \"right\" application package name is. Once kevlar has all the required data it is able to differentiate between genuine and tampered binaries. private val integrity = KevlarIntegrity { checks { packageName () { // Allowed package name hardcodedPackageName ( \"com.kevlar.showcase\" ) } signature () { // Allowed signature hardcodedSignatures ( \"J+nqXLfuIO8B2AmhkMYHGE4jDyw=\" ) } debug () installer () } } You can find instruction on where to find the right parameters in implementation . In this case you simply have to pass in the package name of your app, so kevlar knows what is the right package.","title":"Package name check"},{"location":"pages/modules/integrity/reference/#signature-check","text":"The signature() function tells kevlar to enable the integrity checks for the application signature. This is a parametric setting, since kevlar needs to know what is the \"right\" application signature is. Once kevlar has all the required data it is able to differentiate between genuine and tampered binaries. private val integrity = KevlarIntegrity { checks { packageName () { // Allowed package name hardcodedPackageName ( \"com.kevlar.showcase\" ) } signature () { // Allowed signature hardcodedSignatures ( \"J+nqXLfuIO8B2AmhkMYHGE4jDyw=\" ) } debug () installer () } } You can find instruction on where to find the right parameters in implementation .","title":"Signature check"},{"location":"pages/modules/integrity/reference/#debug-check","text":"The debug() function tells kevlar to enable integrity debug checks. private val integrity = KevlarIntegrity { checks { packageName () { // Allowed package name hardcodedPackageName ( \"com.kevlar.showcase\" ) } signature () { // Allowed signature hardcodedSignatures ( \"J+nqXLfuIO8B2AmhkMYHGE4jDyw=\" ) } debug () installer () } } If debug flags are found on your application it will be reported.","title":"Debug check"},{"location":"pages/modules/integrity/reference/#installer-check","text":"The installer() function tells kevlar to enable installer checks. Since android R, google introduced APIs to check the original installer of a certain package. With this check, you can instruct kevlar to analyze that installer (if available) and detect whether it is allowed or not by your security policy. In this case, the only allowed installer package is the Google Play Store, but you can always add more through the allowInstaller function. private val integrity = KevlarIntegrity { checks { packageName () { // Allowed package name hardcodedPackageName ( \"com.kevlar.showcase\" ) } signature () { // Allowed signature hardcodedSignatures ( \"J+nqXLfuIO8B2AmhkMYHGE4jDyw=\" ) } debug () installer () { allowInstaller ( \"com.sec.android.app.samsungapps\" ) } } }","title":"Installer check"},{"location":"pages/modules/rooting/implementation/","text":"Implementation \u00b6 A working example for the rooting module can be found in the github repository under the :showcase module. Dependency \u00b6 Gradle dependencies { implementation \"io.github.kevlar-kt:rooting:1.1.1\" } Kotlin DSL dependencies { implementation ( \"io.github.kevlar-kt:rooting:1.1.1\" ) } Maven <dependency> <groupId> io.github.kevlar-kt </groupId> <artifactId> rooting </artifactId> <version> 1.1.1 </version> <type> pom </type> </dependency> The rooting module uses libsu to execute shell commands. You may need to include it in your app's dependencies like so: libsu dependency dependencies { def libsuVersion = \"5.2.0\" implementation \"com.github.topjohnwu.libsu:core:${libsuVersion}\" } Initialization & Attestations \u00b6 You need to create a KevlarRooting instance (which is the way you will be requesting attestations), along with your desired parameters (either global, local or in your repository layer, if you are using MVVM/MVC). The rooting package has 2 attestations: TargetRootingAttestation and StatusRootingAttestation . Depending on what your security requirements impose, you may need to run one or both checks. You go ahead and request whichever attestation(s) you need. The will produce two different sealed classes (since the results will be different in case of failure, the attestations will contain different data). We go ahead and create a working single-attestation example (for system modifications aka targets). For two attestations refer to the sample code in the :showcase module of the github repository. Configuration \u00b6 As we said, the kinds of checks you can run are divided in two different categories, targets and status . The first is to check for eventual system modification, the former to check for eventual in-system status. The following complete configuration runs every check that kevlar disposes. In details: flagPermissive() , if enabled, will report DetectableSystemStatus.SELINUX also if selinux status is set to permissive status (which is a stricter criteria), while by default it will only trip if selinux is disabled; allowExplicitRootCheck() , if enabled, will use more aggressive checks to determine if any of the required targets is installed, including explicitly trying to acquire root access. private val rooting = KevlarRooting { targets { root () magisk () busybox () toybox () xposed () } allowExplicitRootCheck () status { testKeys () emulator () selinux { flagPermissive () } } } In-Place \u00b6 This is the most concise way to implement rooting. InPlace.kt val rooting = KevlarRooting { targets { root () busybox () } } CoroutineScope ( Dispatchers . Default ). launch { // Attestation request when ( val attestation = rooting . attestateTargets ( context )) { is TargetRootingAttestation . Blank -> { // Pending attestation, no information yet. // Don't do anything. } is TargetRootingAttestation . Clear -> { // Good to go. } is TargetRootingAttestation . Failed -> { // System modifications detected. } } } ViewModel + Repository + SharedFlow + DI with Hilt \u00b6 Activity: \u00b6 RootingActivity.kt @AndroidEntryPoint class RootingActivity : AppCompatActivity () { private val vm : ActivityViewModel by viewModels () override fun onCreate ( savedInstanceState : Bundle?) { super . onCreate ( savedInstanceState ) lifecycleScope . launch { lifecycle . repeatOnLifecycle ( Lifecycle . State . STARTED ) { vm . taregtsAttestation . collectLatest { when ( it ) { is TargetRootingAttestation . Blank -> { // Pending attestation, no information yet. // Don't do anything. } is TargetRootingAttestation . Clear -> { // Good to go. } is TargetRootingAttestation . Failed -> { // Pirate software detected. } } } } } CoroutineScope ( Dispatchers . Main ). launch { vm . requestTargetsAttestation () } } } View model: \u00b6 ActivityViewModel.kt @HiltViewModel class ActivityViewModel @Inject constructor ( private val securityRepository : RootingRepository ) : ViewModel () { private val _targetAttestationState = MutableStateFlow ( KevlarRooting . blankTargetAttestation ()) val targetAttestation : SharedFlow < TargetRootingAttestation > = _rootAttestationState . stateIn ( viewModelScope , SharingStarted . Eagerly , initialValue = KevlarRooting . blankTargetAttestation () ) fun requestTargetsAttestation () { viewModelScope . launch { _rootAttestationState . value = rootingRepository . attestateRoot () } } } Repository \u00b6 RootingRepository.kt class RootingRepository @Inject constructor ( @ApplicationContext val context : Context , @IoDispatcher val externalDispatcher : CoroutineDispatcher ) { private val rooting = KevlarRooting { targets { root () busybox () } } suspend fun attestateRoot (): TargetRootingAttestation = withContext ( externalDispatcher ) { rooting . attestateTargets ( context ) } }","title":"Implementation"},{"location":"pages/modules/rooting/implementation/#implementation","text":"A working example for the rooting module can be found in the github repository under the :showcase module.","title":"Implementation"},{"location":"pages/modules/rooting/implementation/#dependency","text":"Gradle dependencies { implementation \"io.github.kevlar-kt:rooting:1.1.1\" } Kotlin DSL dependencies { implementation ( \"io.github.kevlar-kt:rooting:1.1.1\" ) } Maven <dependency> <groupId> io.github.kevlar-kt </groupId> <artifactId> rooting </artifactId> <version> 1.1.1 </version> <type> pom </type> </dependency> The rooting module uses libsu to execute shell commands. You may need to include it in your app's dependencies like so: libsu dependency dependencies { def libsuVersion = \"5.2.0\" implementation \"com.github.topjohnwu.libsu:core:${libsuVersion}\" }","title":"Dependency"},{"location":"pages/modules/rooting/implementation/#initialization-attestations","text":"You need to create a KevlarRooting instance (which is the way you will be requesting attestations), along with your desired parameters (either global, local or in your repository layer, if you are using MVVM/MVC). The rooting package has 2 attestations: TargetRootingAttestation and StatusRootingAttestation . Depending on what your security requirements impose, you may need to run one or both checks. You go ahead and request whichever attestation(s) you need. The will produce two different sealed classes (since the results will be different in case of failure, the attestations will contain different data). We go ahead and create a working single-attestation example (for system modifications aka targets). For two attestations refer to the sample code in the :showcase module of the github repository.","title":"Initialization &amp; Attestations"},{"location":"pages/modules/rooting/implementation/#configuration","text":"As we said, the kinds of checks you can run are divided in two different categories, targets and status . The first is to check for eventual system modification, the former to check for eventual in-system status. The following complete configuration runs every check that kevlar disposes. In details: flagPermissive() , if enabled, will report DetectableSystemStatus.SELINUX also if selinux status is set to permissive status (which is a stricter criteria), while by default it will only trip if selinux is disabled; allowExplicitRootCheck() , if enabled, will use more aggressive checks to determine if any of the required targets is installed, including explicitly trying to acquire root access. private val rooting = KevlarRooting { targets { root () magisk () busybox () toybox () xposed () } allowExplicitRootCheck () status { testKeys () emulator () selinux { flagPermissive () } } }","title":"Configuration"},{"location":"pages/modules/rooting/implementation/#in-place","text":"This is the most concise way to implement rooting. InPlace.kt val rooting = KevlarRooting { targets { root () busybox () } } CoroutineScope ( Dispatchers . Default ). launch { // Attestation request when ( val attestation = rooting . attestateTargets ( context )) { is TargetRootingAttestation . Blank -> { // Pending attestation, no information yet. // Don't do anything. } is TargetRootingAttestation . Clear -> { // Good to go. } is TargetRootingAttestation . Failed -> { // System modifications detected. } } }","title":"In-Place"},{"location":"pages/modules/rooting/implementation/#viewmodel-repository-sharedflow-di-with-hilt","text":"","title":"ViewModel + Repository + SharedFlow + DI with Hilt"},{"location":"pages/modules/rooting/implementation/#activity","text":"RootingActivity.kt @AndroidEntryPoint class RootingActivity : AppCompatActivity () { private val vm : ActivityViewModel by viewModels () override fun onCreate ( savedInstanceState : Bundle?) { super . onCreate ( savedInstanceState ) lifecycleScope . launch { lifecycle . repeatOnLifecycle ( Lifecycle . State . STARTED ) { vm . taregtsAttestation . collectLatest { when ( it ) { is TargetRootingAttestation . Blank -> { // Pending attestation, no information yet. // Don't do anything. } is TargetRootingAttestation . Clear -> { // Good to go. } is TargetRootingAttestation . Failed -> { // Pirate software detected. } } } } } CoroutineScope ( Dispatchers . Main ). launch { vm . requestTargetsAttestation () } } }","title":"Activity:"},{"location":"pages/modules/rooting/implementation/#view-model","text":"ActivityViewModel.kt @HiltViewModel class ActivityViewModel @Inject constructor ( private val securityRepository : RootingRepository ) : ViewModel () { private val _targetAttestationState = MutableStateFlow ( KevlarRooting . blankTargetAttestation ()) val targetAttestation : SharedFlow < TargetRootingAttestation > = _rootAttestationState . stateIn ( viewModelScope , SharingStarted . Eagerly , initialValue = KevlarRooting . blankTargetAttestation () ) fun requestTargetsAttestation () { viewModelScope . launch { _rootAttestationState . value = rootingRepository . attestateRoot () } } }","title":"View model:"},{"location":"pages/modules/rooting/implementation/#repository","text":"RootingRepository.kt class RootingRepository @Inject constructor ( @ApplicationContext val context : Context , @IoDispatcher val externalDispatcher : CoroutineDispatcher ) { private val rooting = KevlarRooting { targets { root () busybox () } } suspend fun attestateRoot (): TargetRootingAttestation = withContext ( externalDispatcher ) { rooting . attestateTargets ( context ) } }","title":"Repository"},{"location":"pages/modules/rooting/internals/","text":"Internals \u00b6 Detecting system targets and statuses is easy and difficult at the same time. There are conditions which are really simple and only require a quick binary check to determine. There are other kind of features which are harder to identify and classify reliably, given how different they get across the spectrum of versions of android, versions of the feature and settings of the feature. Binary dumping \u00b6 For a lot of features we can check if the associated binary executable is present. If it is, then we consider that the feature is present as well. This check can be ran at different permission levels with different results. Custom checking \u00b6 Xposed framework requires a specific check on a system file to determine whether it is active or not. Notes \u00b6 The rooting module relies on libsu for shell command execution. This may be a debatable choice, but it is one of the only well-written libraries and it works both efficiently and reliably. The alternative would have been implementing a custom shell execution mechanism, which is not hard to do, but it is hard to do well .","title":"Internals"},{"location":"pages/modules/rooting/internals/#internals","text":"Detecting system targets and statuses is easy and difficult at the same time. There are conditions which are really simple and only require a quick binary check to determine. There are other kind of features which are harder to identify and classify reliably, given how different they get across the spectrum of versions of android, versions of the feature and settings of the feature.","title":"Internals"},{"location":"pages/modules/rooting/internals/#binary-dumping","text":"For a lot of features we can check if the associated binary executable is present. If it is, then we consider that the feature is present as well. This check can be ran at different permission levels with different results.","title":"Binary dumping"},{"location":"pages/modules/rooting/internals/#custom-checking","text":"Xposed framework requires a specific check on a system file to determine whether it is active or not.","title":"Custom checking"},{"location":"pages/modules/rooting/internals/#notes","text":"The rooting module relies on libsu for shell command execution. This may be a debatable choice, but it is one of the only well-written libraries and it works both efficiently and reliably. The alternative would have been implementing a custom shell execution mechanism, which is not hard to do, but it is hard to do well .","title":"Notes"},{"location":"pages/modules/rooting/rooting/","text":"Rooting \u00b6 graph LR I[Inizialization] -.Settings..-> K{KevlarRooting}; DB([Android OS]) === K AR1[Target Attestation Requests] --> K AR2[Status Attestation Requests] --> K K --> |Clear| P[Passed]; K --> |Failed| NP[Not Passed]; P --> A1[TargetAssestation] NP --> A1 P --> A2[StatusAttestation] NP --> A2 The rooting package contains tools for the detection of system modifications that may be active on the device running your app. Once configured with settings, the package can quickly run different batteries of tests on the operative system (through shell commands) to check if the target modifications are present on the device. It produces two different kinds of attestations: one searching for system modification and one for system conditions. It is capable of detecting the following system modifications (through the targets attestation) root access; magisk installations (not hidden); busybox binaries; toybox binaries; Xposed framework. And the following system conditions (through the status attestation) emulator execution; test keys; SELinux status. Depending on what you need to check, you may choose one or run both. Purpose of the rooting package You may want to use this package if you care about the system-wide security status, or if you consider that your application running on rooted/modified devices is a security risk. Notation In the rooting package, the words \"target\" and \"status\" are used loosely, but they actually have a special meaning. Targets means system modification. Something that may be installed (and detectable) over the operating system. It is a kind of add-on, a custom software component. Status means a system condition. Something that is itself part of the operating system out of the box, and whose status we want to check. To implement this, you initialize KevlarRooting and provide your desired settings (which influence what is to be checked and what not). Then you can submit attestation requests of whichever kind you prefer (which will be executed according to your settings). Empty & default settings The settings on rooting are additive. If you leave a blank DSL, nothing will be detected, because no checks will be run, because the settings are empty. If you do not pass a DSL at all, the default settings will be used (they only scan for root access and emulator + SELinux). Custom private val rooting = KevlarRooting { targets { root () magisk () busybox () } status { emulator () selinux { flagPermissive () } } allowExplicitRootCheck () } Empty private val rooting = KevlarRooting { targets {} status {} } Default private val rooting = KevlarRooting () Attestation process overview \u00b6 This package can produce two different kinds of attestations: a TargetAssestation and a StatusAttestation . When you require an attestation, kevlar performs the following operations: for the targets attestation (through rooting.attestateTargets(context) ): Depending on what system modification you selected, the appropriate battery of tests for that system modification is initialized and run; The results are collected, processed, filtered, and returned. for the status attestation (through rooting.attestateStatus() ): Depending on what system condition you selected, the appropriate check for that system status flag is initialized and ran; The results are collected, processed, filtered, and returned. The attestation is returned either in TargetRootingAttestation or StatusRootingAttestation (both are sealed classes), which depending on the detection status can be of three types (with different fields): Blank : This is a non-processed status. It should not be interpreted, as it does not carry any meaning about the attestation result. It is not to be interpreted as Clear ; Clear : The attestation has passed. There is nothing to report. This means that no system modification/status has triggered the detection from the battery of tests that have been executed, in compliance with the given scan parameters; Failed : The attestation has not passed. A target/status has been detected. You can read which one has tripped the detection in the attestation result. Warning Blank is completely different from Clear (or Failed ). It means that the software is initialized but that nothing has been done yet. Do not mix them up. Use cases \u00b6 This is a pretty typical scenario for any banking/financial application, game, or software managing sensitive resources (files, records, data)","title":"Overview"},{"location":"pages/modules/rooting/rooting/#rooting","text":"graph LR I[Inizialization] -.Settings..-> K{KevlarRooting}; DB([Android OS]) === K AR1[Target Attestation Requests] --> K AR2[Status Attestation Requests] --> K K --> |Clear| P[Passed]; K --> |Failed| NP[Not Passed]; P --> A1[TargetAssestation] NP --> A1 P --> A2[StatusAttestation] NP --> A2 The rooting package contains tools for the detection of system modifications that may be active on the device running your app. Once configured with settings, the package can quickly run different batteries of tests on the operative system (through shell commands) to check if the target modifications are present on the device. It produces two different kinds of attestations: one searching for system modification and one for system conditions. It is capable of detecting the following system modifications (through the targets attestation) root access; magisk installations (not hidden); busybox binaries; toybox binaries; Xposed framework. And the following system conditions (through the status attestation) emulator execution; test keys; SELinux status. Depending on what you need to check, you may choose one or run both. Purpose of the rooting package You may want to use this package if you care about the system-wide security status, or if you consider that your application running on rooted/modified devices is a security risk. Notation In the rooting package, the words \"target\" and \"status\" are used loosely, but they actually have a special meaning. Targets means system modification. Something that may be installed (and detectable) over the operating system. It is a kind of add-on, a custom software component. Status means a system condition. Something that is itself part of the operating system out of the box, and whose status we want to check. To implement this, you initialize KevlarRooting and provide your desired settings (which influence what is to be checked and what not). Then you can submit attestation requests of whichever kind you prefer (which will be executed according to your settings). Empty & default settings The settings on rooting are additive. If you leave a blank DSL, nothing will be detected, because no checks will be run, because the settings are empty. If you do not pass a DSL at all, the default settings will be used (they only scan for root access and emulator + SELinux). Custom private val rooting = KevlarRooting { targets { root () magisk () busybox () } status { emulator () selinux { flagPermissive () } } allowExplicitRootCheck () } Empty private val rooting = KevlarRooting { targets {} status {} } Default private val rooting = KevlarRooting ()","title":"Rooting"},{"location":"pages/modules/rooting/rooting/#attestation-process-overview","text":"This package can produce two different kinds of attestations: a TargetAssestation and a StatusAttestation . When you require an attestation, kevlar performs the following operations: for the targets attestation (through rooting.attestateTargets(context) ): Depending on what system modification you selected, the appropriate battery of tests for that system modification is initialized and run; The results are collected, processed, filtered, and returned. for the status attestation (through rooting.attestateStatus() ): Depending on what system condition you selected, the appropriate check for that system status flag is initialized and ran; The results are collected, processed, filtered, and returned. The attestation is returned either in TargetRootingAttestation or StatusRootingAttestation (both are sealed classes), which depending on the detection status can be of three types (with different fields): Blank : This is a non-processed status. It should not be interpreted, as it does not carry any meaning about the attestation result. It is not to be interpreted as Clear ; Clear : The attestation has passed. There is nothing to report. This means that no system modification/status has triggered the detection from the battery of tests that have been executed, in compliance with the given scan parameters; Failed : The attestation has not passed. A target/status has been detected. You can read which one has tripped the detection in the attestation result. Warning Blank is completely different from Clear (or Failed ). It means that the software is initialized but that nothing has been done yet. Do not mix them up.","title":"Attestation process overview"},{"location":"pages/modules/rooting/rooting/#use-cases","text":"This is a pretty typical scenario for any banking/financial application, game, or software managing sensitive resources (files, records, data)","title":"Use cases"},{"location":"pages/overview/anatomy_of_attacks/","text":"Anatomy of an attack against an Android app \u00b6 This is a general informal introductory text detailing the most well-known and used attack techniques against Android apps. We will start with the most basic and gradually build up to the most skilled ones. Attack techniques are presented in order of time taken to employ (weaponize) them successfully against an unguarded application. While being different in shape and form, all the attacks follow the same basic principle: you have a target application that we want to attack (with a target in mind. Usually bypassing certain mechanisms, overriding rules, or adding/removing features), which is decompiled, then analyzed; its bytecode is modified according to the target of the attack (a payload is inserted, safety checks are removed, code is altered or replaced), then it all gets recompiled, repackaged and possibly resigned into an apk file which is installed and run. Popular tools for this are apktool on desktop and ApkEditor on mobile. Warning This page tends to be a little subjective because there is not a science studying those things and I am not an expert in this field, so take everything with a grain of salt. 0: Automatic patching \u00b6 This is by far the most common since (once the engine is ready) it is done completely automatically, without any human intervention or brainpower. There are various pirate apps able to perform this to some extent (most notably Lucky Patcher ). They all more or less all use a string-matching engine to perform a (very sophisticated) pattern \"find-and-replace\" over your application bytecode. This is done to achieve what the target of the attack is: it may be removing advertising from your app, changing signature verification, disabling or enabling some features, inhibiting security mechanisms, or purchasing protection. The target determines the pattern used to do the dirty work. Then the app is rebuilt and it's done. It is the lowest form of attack since the software itself does not know what it is doing exactly but follows a general rule set. But this does not render it any less dangerous: if your software is unprepared, you will fall for this. Against this level of attack you can employ all kevlar's arsenal with the antipiracy and integrity packages. Kevlar has more or less been built and designed to fight this kind of attack, by performing safety checks over your package metadata and giving you runtime warnings for the presence of malicious software which is interfering or directing your app. The nice thing (for us developers) is that the automation of the attack is very hard to do, even on a basic level, and putting up barriers for this is comparatively quick. 1: Unskilled custom attacks \u00b6 This tends to be a less likely kind of attack because an actual human brain is looking at your decompiled bytecode and trying to figure out what needs to be done to achieve its goal. When I say unskilled I mean done by amateurs without in-depth knowledge of the techniques involved. They will essentially be manually searching through your bytecode and looking for code pieces that they recognize and want to remove/edit/expand. This is usually done by searching a determinate resource, which is referenced somewhere in the code, finding that code, and trying to change its logic. Bytecode note Bytecode is the raw language that the JVM executes. In Android, everything shifts from JVM to ART but it's the same thing. There are reconstruction utilities, which will try to take the bytecode and un-compile it to grab the original source code. Most likely that is what an attacker might want to be looking at. Obfuscation A machine does not care whether your code is obfuscated. A human brain does. You should always heavily shrink, optimize and obfuscate your production code (i.e. using ProGuard on release builds) to make it harder for attackers to make sense of it. 2: Root access enabled attacks \u00b6 When a device is rooted, there are a whole lot of new variables to take into account when looking at security, since the operating system itself is compromised and will obey the user commands. It's not like you can do a lot if you are running on that system, but what you can do is preemptively disable some application features to protect them from modification, if applicable and necessary according to your security standards. That's what a lot of games or bank software do since they are targeted by custom attacks that can, with the help of root access, alter the application behavior without having to recompile it (on the fly). Either they shut down completely or they inhibit come functionality. Casing point every Supercell game. Data editing An easy way to crack many (not well secured) applications is by editing the files (XML SharedPreferences or SQLite databases) on which they store data. I've seen countless \"is_pro\" strings inside SharedPreferences or XML/JSON settings where you can enable paid features without the app checking it, and it only takes a few bytes flips to have complete access to anything you want. That specific attack can be made harder by encrypting and obfuscating your application preference strings. 3: Professional custom attack \u00b6 There is very little to say here: if someone knows what he/she is doing, they are going to strip away every bit of self-checking and security controls you put in place, and they will implement whatever target they have. While obfuscation helps, security through obscurity should not even be an option, and other techniques will make it harder to decipher what your code does, eventually, a determined mind will find a way to do what it wants to, and there is nothing you can do about it. After all, if you can modify your code to write software that adheres to the attack targets, so can they. Cracked software distribution Every commercial app I wrote that surpassed about 100k downloads (TurboUnfollow and Androoster) has been custom patched and redistributed on the internet. This happens regularly and, while being sad, is a reminder that perfect security protection does not exist. This happens because you do not have control over the device your user is running your app on. It stops being your control when the bytes are transferred and installed as a package on the device, then they are binary data open for modifications and hacks. The only efficient way to mitigate this is by regulating what you have control over. Server-side access and APIs, data validation, in-house or professional security checks, and so on, will limit the control your app has over its working and puts it in your secure hands. Extra concepts \u00b6 Conditional Consistency \u00b6 It is a little bit meta to talk about your application code being modified, either by recompilation or root attacks, since you can not know how it will be changed. This process can introduce all sorts of discrepancies and inconsistencies in the newly created software. Coding software with conditional consistency is a practice where you insert security checks that can tell when the software is itself not genuine or modified. And while ALL those checks can theoretically be stripped away or disabled, this makes it harder to find them all and avoid detection. This is a bit overkill for android apps, but more advanced software uses those concepts to add extra nets of protection.","title":"Anatomy of an Attack"},{"location":"pages/overview/anatomy_of_attacks/#anatomy-of-an-attack-against-an-android-app","text":"This is a general informal introductory text detailing the most well-known and used attack techniques against Android apps. We will start with the most basic and gradually build up to the most skilled ones. Attack techniques are presented in order of time taken to employ (weaponize) them successfully against an unguarded application. While being different in shape and form, all the attacks follow the same basic principle: you have a target application that we want to attack (with a target in mind. Usually bypassing certain mechanisms, overriding rules, or adding/removing features), which is decompiled, then analyzed; its bytecode is modified according to the target of the attack (a payload is inserted, safety checks are removed, code is altered or replaced), then it all gets recompiled, repackaged and possibly resigned into an apk file which is installed and run. Popular tools for this are apktool on desktop and ApkEditor on mobile. Warning This page tends to be a little subjective because there is not a science studying those things and I am not an expert in this field, so take everything with a grain of salt.","title":"Anatomy of an attack against an Android app"},{"location":"pages/overview/anatomy_of_attacks/#0-automatic-patching","text":"This is by far the most common since (once the engine is ready) it is done completely automatically, without any human intervention or brainpower. There are various pirate apps able to perform this to some extent (most notably Lucky Patcher ). They all more or less all use a string-matching engine to perform a (very sophisticated) pattern \"find-and-replace\" over your application bytecode. This is done to achieve what the target of the attack is: it may be removing advertising from your app, changing signature verification, disabling or enabling some features, inhibiting security mechanisms, or purchasing protection. The target determines the pattern used to do the dirty work. Then the app is rebuilt and it's done. It is the lowest form of attack since the software itself does not know what it is doing exactly but follows a general rule set. But this does not render it any less dangerous: if your software is unprepared, you will fall for this. Against this level of attack you can employ all kevlar's arsenal with the antipiracy and integrity packages. Kevlar has more or less been built and designed to fight this kind of attack, by performing safety checks over your package metadata and giving you runtime warnings for the presence of malicious software which is interfering or directing your app. The nice thing (for us developers) is that the automation of the attack is very hard to do, even on a basic level, and putting up barriers for this is comparatively quick.","title":"0: Automatic patching"},{"location":"pages/overview/anatomy_of_attacks/#1-unskilled-custom-attacks","text":"This tends to be a less likely kind of attack because an actual human brain is looking at your decompiled bytecode and trying to figure out what needs to be done to achieve its goal. When I say unskilled I mean done by amateurs without in-depth knowledge of the techniques involved. They will essentially be manually searching through your bytecode and looking for code pieces that they recognize and want to remove/edit/expand. This is usually done by searching a determinate resource, which is referenced somewhere in the code, finding that code, and trying to change its logic. Bytecode note Bytecode is the raw language that the JVM executes. In Android, everything shifts from JVM to ART but it's the same thing. There are reconstruction utilities, which will try to take the bytecode and un-compile it to grab the original source code. Most likely that is what an attacker might want to be looking at. Obfuscation A machine does not care whether your code is obfuscated. A human brain does. You should always heavily shrink, optimize and obfuscate your production code (i.e. using ProGuard on release builds) to make it harder for attackers to make sense of it.","title":"1: Unskilled custom attacks"},{"location":"pages/overview/anatomy_of_attacks/#2-root-access-enabled-attacks","text":"When a device is rooted, there are a whole lot of new variables to take into account when looking at security, since the operating system itself is compromised and will obey the user commands. It's not like you can do a lot if you are running on that system, but what you can do is preemptively disable some application features to protect them from modification, if applicable and necessary according to your security standards. That's what a lot of games or bank software do since they are targeted by custom attacks that can, with the help of root access, alter the application behavior without having to recompile it (on the fly). Either they shut down completely or they inhibit come functionality. Casing point every Supercell game. Data editing An easy way to crack many (not well secured) applications is by editing the files (XML SharedPreferences or SQLite databases) on which they store data. I've seen countless \"is_pro\" strings inside SharedPreferences or XML/JSON settings where you can enable paid features without the app checking it, and it only takes a few bytes flips to have complete access to anything you want. That specific attack can be made harder by encrypting and obfuscating your application preference strings.","title":"2: Root access enabled attacks"},{"location":"pages/overview/anatomy_of_attacks/#3-professional-custom-attack","text":"There is very little to say here: if someone knows what he/she is doing, they are going to strip away every bit of self-checking and security controls you put in place, and they will implement whatever target they have. While obfuscation helps, security through obscurity should not even be an option, and other techniques will make it harder to decipher what your code does, eventually, a determined mind will find a way to do what it wants to, and there is nothing you can do about it. After all, if you can modify your code to write software that adheres to the attack targets, so can they. Cracked software distribution Every commercial app I wrote that surpassed about 100k downloads (TurboUnfollow and Androoster) has been custom patched and redistributed on the internet. This happens regularly and, while being sad, is a reminder that perfect security protection does not exist. This happens because you do not have control over the device your user is running your app on. It stops being your control when the bytes are transferred and installed as a package on the device, then they are binary data open for modifications and hacks. The only efficient way to mitigate this is by regulating what you have control over. Server-side access and APIs, data validation, in-house or professional security checks, and so on, will limit the control your app has over its working and puts it in your secure hands.","title":"3: Professional custom attack"},{"location":"pages/overview/anatomy_of_attacks/#extra-concepts","text":"","title":"Extra concepts"},{"location":"pages/overview/anatomy_of_attacks/#conditional-consistency","text":"It is a little bit meta to talk about your application code being modified, either by recompilation or root attacks, since you can not know how it will be changed. This process can introduce all sorts of discrepancies and inconsistencies in the newly created software. Coding software with conditional consistency is a practice where you insert security checks that can tell when the software is itself not genuine or modified. And while ALL those checks can theoretically be stripped away or disabled, this makes it harder to find them all and avoid detection. This is a bit overkill for android apps, but more advanced software uses those concepts to add extra nets of protection.","title":"Conditional Consistency"},{"location":"pages/overview/attitude/","text":"Attitude \u00b6 Kevlar may be used in some instances to gather information and eventually act upon them in ways that can be considered immoral or unjust. Namely, denying service (or parts of service) to some users or systems is a controversial decision. Kevlar is only a tool , and as such has no behaviour or attitude embedded within it. Developers using this library or implementing similar behaviours should choose carefully what to do after the data has been gathered. There is a broad spectrum of opinions regarding this topic. On one end, people will want full freedom and access over the device they bought and use daily, and they are right. On the other end, developers do not want their software to be pirated, hacked, cracked, bypassed, abused as this has negative consequences all around the app, and they are right. Personally I think it depends on what kind of detection you implement: If I try to crack a software and said software doesn't let me I'd feel angry but I know I'm doing something wrong, which would damage the developers. On the other hand, apps denying service because I have a custom ROM or a magisk rooted phone when I had no intention of doing anything really would make me angry. But you shouldn't really care about what my personal views are regarding the matter, you should do what is best for your software.","title":"Attitude"},{"location":"pages/overview/attitude/#attitude","text":"Kevlar may be used in some instances to gather information and eventually act upon them in ways that can be considered immoral or unjust. Namely, denying service (or parts of service) to some users or systems is a controversial decision. Kevlar is only a tool , and as such has no behaviour or attitude embedded within it. Developers using this library or implementing similar behaviours should choose carefully what to do after the data has been gathered. There is a broad spectrum of opinions regarding this topic. On one end, people will want full freedom and access over the device they bought and use daily, and they are right. On the other end, developers do not want their software to be pirated, hacked, cracked, bypassed, abused as this has negative consequences all around the app, and they are right. Personally I think it depends on what kind of detection you implement: If I try to crack a software and said software doesn't let me I'd feel angry but I know I'm doing something wrong, which would damage the developers. On the other hand, apps denying service because I have a custom ROM or a magisk rooted phone when I had no intention of doing anything really would make me angry. But you shouldn't really care about what my personal views are regarding the matter, you should do what is best for your software.","title":"Attitude"},{"location":"pages/overview/choosing/","text":"Choosing packages \u00b6 Kevlar's flexible infrastructure allows for very granular and efficient configuration. it is divided in 3 packages, each targeting a specific scope (system-wise security, user-wise security and app-wise security), and within each package you have fully customizable attestation checks. This is done to help you reach your desired security level and only bundle in your app what you need.","title":"Choosing packages"},{"location":"pages/overview/choosing/#choosing-packages","text":"Kevlar's flexible infrastructure allows for very granular and efficient configuration. it is divided in 3 packages, each targeting a specific scope (system-wise security, user-wise security and app-wise security), and within each package you have fully customizable attestation checks. This is done to help you reach your desired security level and only bundle in your app what you need.","title":"Choosing packages"},{"location":"pages/overview/dependencies_integration/","text":"Dependencies and Integration \u00b6 Publishing \u00b6 All the dependencies are published on MavenCentral. Make sure to have it included in your reporitories block in the top level build.gradle file. repositories { mavenCentral () } Project Requirements \u00b6 Java 8+ is required; compileOptions { sourceCompatibility JavaVersion . VERSION_1_8 targetCompatibility JavaVersion . VERSION_1_8 } minSdk 19+ is required. Antipiracy \u00b6 Gradle dependencies { implementation \"io.github.kevlar-kt:antipiracy:1.1.1\" } Kotlin DSL dependencies { implementation ( \"io.github.kevlar-kt:antipiracy:1.1.1\" ) } Maven <dependency> <groupId> io.github.kevlar-kt </groupId> <artifactId> antipiracy </artifactId> <version> 1.1.1 </version> <type> pom </type> </dependency> Rooting \u00b6 Gradle dependencies { implementation \"io.github.kevlar-kt:rooting:1.1.1\" } Kotlin DSL dependencies { implementation ( \"io.github.kevlar-kt:rooting:1.1.1\" ) } Maven <dependency> <groupId> io.github.kevlar-kt </groupId> <artifactId> rooting </artifactId> <version> 1.1.1 </version> <type> pom </type> </dependency> Integrity \u00b6 Gradle dependencies { implementation \"io.github.kevlar-kt:integrity:1.1.1\" } Kotlin DSL dependencies { implementation ( \"io.github.kevlar-kt:integrity:1.1.1\" ) } Maven <dependency> <groupId> io.github.kevlar-kt </groupId> <artifactId> integrity </artifactId> <version> 1.1.1 </version> <type> pom </type> </dependency>","title":"Dependencies & Integration"},{"location":"pages/overview/dependencies_integration/#dependencies-and-integration","text":"","title":"Dependencies and Integration"},{"location":"pages/overview/dependencies_integration/#publishing","text":"All the dependencies are published on MavenCentral. Make sure to have it included in your reporitories block in the top level build.gradle file. repositories { mavenCentral () }","title":"Publishing"},{"location":"pages/overview/dependencies_integration/#project-requirements","text":"Java 8+ is required; compileOptions { sourceCompatibility JavaVersion . VERSION_1_8 targetCompatibility JavaVersion . VERSION_1_8 } minSdk 19+ is required.","title":"Project Requirements"},{"location":"pages/overview/dependencies_integration/#antipiracy","text":"Gradle dependencies { implementation \"io.github.kevlar-kt:antipiracy:1.1.1\" } Kotlin DSL dependencies { implementation ( \"io.github.kevlar-kt:antipiracy:1.1.1\" ) } Maven <dependency> <groupId> io.github.kevlar-kt </groupId> <artifactId> antipiracy </artifactId> <version> 1.1.1 </version> <type> pom </type> </dependency>","title":"Antipiracy"},{"location":"pages/overview/dependencies_integration/#rooting","text":"Gradle dependencies { implementation \"io.github.kevlar-kt:rooting:1.1.1\" } Kotlin DSL dependencies { implementation ( \"io.github.kevlar-kt:rooting:1.1.1\" ) } Maven <dependency> <groupId> io.github.kevlar-kt </groupId> <artifactId> rooting </artifactId> <version> 1.1.1 </version> <type> pom </type> </dependency>","title":"Rooting"},{"location":"pages/overview/dependencies_integration/#integrity","text":"Gradle dependencies { implementation \"io.github.kevlar-kt:integrity:1.1.1\" } Kotlin DSL dependencies { implementation ( \"io.github.kevlar-kt:integrity:1.1.1\" ) } Maven <dependency> <groupId> io.github.kevlar-kt </groupId> <artifactId> integrity </artifactId> <version> 1.1.1 </version> <type> pom </type> </dependency>","title":"Integrity"},{"location":"pages/overview/material/","text":"Technical Material \u00b6 Prevention material, checking & tamper detection \u00b6 https://www.airpair.com/android/posts/adding-tampering-detection-to-your-android-app https://en.wikipedia.org/wiki/Security_through_obscurity ; https://darvincitech.wordpress.com/2020/03/01/yet-another-tamper-detection-in-android/ ; https://medium.com/avi-parshan-studios/protecting-your-android-app-against-reverse-engineering-and-tampering-a727768b2e9e ; https://medium.com/@mplacona/tampering-detection-in-android-d213998ecc4f https://developer.android.com/google/play/integrity https://developer.android.com/training/safetynet/index.html ; https://www.indusface.com/learning/how-to-implement-root-detection-in-android-applications/ ; https://stackoverflow.com/questions/33850864/how-to-verify-purchase-for-android-app-in-server-side-google-play-in-app-billin . Server-Side checks \u00b6 https://developer.android.com/training/safetynet ; https://medium.com/@lahirumaramba/protecting-your-own-backend-services-with-firebase-app-check-1daaef229f32 . Attack vectors \u00b6 https://mobile-security.gitbook.io/mobile-security-testing-guide/android-testing-guide/0x05c-reverse-engineering-and-tampering . Code \u00b6 https://gist.github.com/scottyab/b849701972d57cf9562e ; https://github.com/mukeshsolanki/Android-Tamper-Detector ; https://stackoverflow.com/questions/50126775/detecting-code-tampering-in-apk ; https://stackoverflow.com/questions/13445598/lucky-patcher-how-can-i-protect-from-it .","title":"Technical Material"},{"location":"pages/overview/material/#technical-material","text":"","title":"Technical Material"},{"location":"pages/overview/material/#prevention-material-checking-tamper-detection","text":"https://www.airpair.com/android/posts/adding-tampering-detection-to-your-android-app https://en.wikipedia.org/wiki/Security_through_obscurity ; https://darvincitech.wordpress.com/2020/03/01/yet-another-tamper-detection-in-android/ ; https://medium.com/avi-parshan-studios/protecting-your-android-app-against-reverse-engineering-and-tampering-a727768b2e9e ; https://medium.com/@mplacona/tampering-detection-in-android-d213998ecc4f https://developer.android.com/google/play/integrity https://developer.android.com/training/safetynet/index.html ; https://www.indusface.com/learning/how-to-implement-root-detection-in-android-applications/ ; https://stackoverflow.com/questions/33850864/how-to-verify-purchase-for-android-app-in-server-side-google-play-in-app-billin .","title":"Prevention material, checking &amp; tamper detection"},{"location":"pages/overview/material/#server-side-checks","text":"https://developer.android.com/training/safetynet ; https://medium.com/@lahirumaramba/protecting-your-own-backend-services-with-firebase-app-check-1daaef229f32 .","title":"Server-Side checks"},{"location":"pages/overview/material/#attack-vectors","text":"https://mobile-security.gitbook.io/mobile-security-testing-guide/android-testing-guide/0x05c-reverse-engineering-and-tampering .","title":"Attack vectors"},{"location":"pages/overview/material/#code","text":"https://gist.github.com/scottyab/b849701972d57cf9562e ; https://github.com/mukeshsolanki/Android-Tamper-Detector ; https://stackoverflow.com/questions/50126775/detecting-code-tampering-in-apk ; https://stackoverflow.com/questions/13445598/lucky-patcher-how-can-i-protect-from-it .","title":"Code"},{"location":"pages/overview/philosophy/","text":"Philosophy \u00b6 What does it do? \u00b6 It warns your application when a specific security requirement is not met by the system, userspace, or app. Each kevlar package shares a common structure: they all produce an attestation regarding (an aspect of) the security state of the Android device running your app. The idea behind it is being able to quickly capture every meaningful security information regarding a certain field, with a certain accuracy. These modules provide an array of detection methods that can be used to ensure the app is running in its proper intended environment Note A general rule of thumb is to include only what you need, and nothing more. There is little to no point in using antipiracy protection if you do not have sensitive in-app material and/or transactions you want to protect, same with rooting or integrity. Does it always work? \u00b6 No. It does most of the time, but there is no guarantee of a 100% success rate. What kevlar provides is an accurate heuristic, which is relatively cheap to run and provides a valuable assessment within an acceptable margin of error. If you require a higher success rate, you will need much more sophisticated and ad-hoc levels of protection. Kevlar catches what can be caught in a reasonable amount of time, space, and lines of code. In a similar fashion as the pareto distribution , to slightly improve the detection rate you will need much more complicated software, much more time, or much more space. And for the record, any software trying to claim that it achieves 100% detection is factually wrong (there is a theorem in computability and decidability theory stating that you can not do that). Naming decisions \u00b6 Kevlar is a material used in bulletproof vests. And besides starting with a k (which at this point appears to be an implicit requirement for any cool kotlin library), it perfectly embodies its philosophy. A soldier in the field is a target for the enemy force. Soldiers shoot bullets at each other and who is hit die. Wearing a bulletproof vest is a way of reducing the chance of you dying. It makes practical sense: it is a light material, not difficult to carry around, and it provides life-saving protection. Kevlar is lightweight body armor for your app, to check and shield against incoming hostile attacks. If you are being targeted with high precision sniper fire, a javelin anti-tank launcher, or a Royal Naval vessel in the immediate vicinity launches a missile strike on your location, even if you are James Bond there is little left to do. If your app is reverse engineered, the security bits stripped away and then recompiled (more details in Anatomy of an Attack ), you are going to be vulnerable, and there is nothing you can do about it. But while being imperfect, it manages to be efficient and deflect the majority of automated and non-specialized patches and attacks, which is the majority of what you will (hopefully) be exposed to. Another similarity is about what you want to protect. People don't usually wear a bulletproof vest at home [redacted U.S. joke] . It doesn't make much sense, since the attack is not likely. The same thing goes with putting kevlar on a calculator app. You can. It does not make much sense if it does not have valuable commercial features or APIs (On WolframAlpha it does). Success rates Given the success rate of this library against patches versus the success rate of kevlar vests against bullets, this could have easily been called full body armor, but that didn't sound as cool. Security Through Obscurity \u00b6 Kevlar does not rely on security through obscurity . Its source code, logic, and dataset is public. Since the purpose of kevlar is to be a generic barrier to defeat automated and unskilled attacks, going to the extent of obfuscating code that, if ever reverse engineered, would just be stripped away, seems like a fruitless idea. It would be necessary to introduce such mechanisms only if hostile software would try to automatically target specific kevlar components. While I doubt this would ever happen, introducing basic internal safety checks or compile-time randomized obfuscation would surely make that kind of detection unfeasible. Accuracy and Precision \u00b6 It is fairly accurate (since there are just a few checks to run to check the security status, we are pretty confident that most of the time we will get the information right), and has excellent precision (since checks are deterministic and predictable, given an initial condition, the result will always be the same, accurate or not) (See accuracy vs precision ) History \u00b6 This project has been alive since 2017 (by the former name billing-protector) to counteract automatic attacks against android applications (AAAAA). The original project was mainly aimed at protecting apps from Lucky Patcher, an infamous patch tool used to modify (recompile with automated code replacement and modification, more details in security/attacks) apps to bypass IAP (In-app purchases), and essentially crack them. It has evolved in a more general and flexible","title":"Philosophy"},{"location":"pages/overview/philosophy/#philosophy","text":"","title":"Philosophy"},{"location":"pages/overview/philosophy/#what-does-it-do","text":"It warns your application when a specific security requirement is not met by the system, userspace, or app. Each kevlar package shares a common structure: they all produce an attestation regarding (an aspect of) the security state of the Android device running your app. The idea behind it is being able to quickly capture every meaningful security information regarding a certain field, with a certain accuracy. These modules provide an array of detection methods that can be used to ensure the app is running in its proper intended environment Note A general rule of thumb is to include only what you need, and nothing more. There is little to no point in using antipiracy protection if you do not have sensitive in-app material and/or transactions you want to protect, same with rooting or integrity.","title":"What does it do?"},{"location":"pages/overview/philosophy/#does-it-always-work","text":"No. It does most of the time, but there is no guarantee of a 100% success rate. What kevlar provides is an accurate heuristic, which is relatively cheap to run and provides a valuable assessment within an acceptable margin of error. If you require a higher success rate, you will need much more sophisticated and ad-hoc levels of protection. Kevlar catches what can be caught in a reasonable amount of time, space, and lines of code. In a similar fashion as the pareto distribution , to slightly improve the detection rate you will need much more complicated software, much more time, or much more space. And for the record, any software trying to claim that it achieves 100% detection is factually wrong (there is a theorem in computability and decidability theory stating that you can not do that).","title":"Does it always work?"},{"location":"pages/overview/philosophy/#naming-decisions","text":"Kevlar is a material used in bulletproof vests. And besides starting with a k (which at this point appears to be an implicit requirement for any cool kotlin library), it perfectly embodies its philosophy. A soldier in the field is a target for the enemy force. Soldiers shoot bullets at each other and who is hit die. Wearing a bulletproof vest is a way of reducing the chance of you dying. It makes practical sense: it is a light material, not difficult to carry around, and it provides life-saving protection. Kevlar is lightweight body armor for your app, to check and shield against incoming hostile attacks. If you are being targeted with high precision sniper fire, a javelin anti-tank launcher, or a Royal Naval vessel in the immediate vicinity launches a missile strike on your location, even if you are James Bond there is little left to do. If your app is reverse engineered, the security bits stripped away and then recompiled (more details in Anatomy of an Attack ), you are going to be vulnerable, and there is nothing you can do about it. But while being imperfect, it manages to be efficient and deflect the majority of automated and non-specialized patches and attacks, which is the majority of what you will (hopefully) be exposed to. Another similarity is about what you want to protect. People don't usually wear a bulletproof vest at home [redacted U.S. joke] . It doesn't make much sense, since the attack is not likely. The same thing goes with putting kevlar on a calculator app. You can. It does not make much sense if it does not have valuable commercial features or APIs (On WolframAlpha it does). Success rates Given the success rate of this library against patches versus the success rate of kevlar vests against bullets, this could have easily been called full body armor, but that didn't sound as cool.","title":"Naming decisions"},{"location":"pages/overview/philosophy/#security-through-obscurity","text":"Kevlar does not rely on security through obscurity . Its source code, logic, and dataset is public. Since the purpose of kevlar is to be a generic barrier to defeat automated and unskilled attacks, going to the extent of obfuscating code that, if ever reverse engineered, would just be stripped away, seems like a fruitless idea. It would be necessary to introduce such mechanisms only if hostile software would try to automatically target specific kevlar components. While I doubt this would ever happen, introducing basic internal safety checks or compile-time randomized obfuscation would surely make that kind of detection unfeasible.","title":"Security Through Obscurity"},{"location":"pages/overview/philosophy/#accuracy-and-precision","text":"It is fairly accurate (since there are just a few checks to run to check the security status, we are pretty confident that most of the time we will get the information right), and has excellent precision (since checks are deterministic and predictable, given an initial condition, the result will always be the same, accurate or not) (See accuracy vs precision )","title":"Accuracy and Precision"},{"location":"pages/overview/philosophy/#history","text":"This project has been alive since 2017 (by the former name billing-protector) to counteract automatic attacks against android applications (AAAAA). The original project was mainly aimed at protecting apps from Lucky Patcher, an infamous patch tool used to modify (recompile with automated code replacement and modification, more details in security/attacks) apps to bypass IAP (In-app purchases), and essentially crack them. It has evolved in a more general and flexible","title":"History"}]}